//
// CameraTag
//
 
if (typeof(CameraTag) == "undefined") {
  CameraTag = new function() {
    (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

'use strict';

var _adapter_factory = require('./adapter_factory.js');

var adapter = (0, _adapter_factory.adapterFactory)({ window: typeof window === 'undefined' ? undefined : window });
module.exports = adapter; // this is the difference from adapter_core.

},{"./adapter_factory.js":2}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = adapterFactory;

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _chrome_shim = require('./chrome/chrome_shim');

var chromeShim = _interopRequireWildcard(_chrome_shim);

var _edge_shim = require('./edge/edge_shim');

var edgeShim = _interopRequireWildcard(_edge_shim);

var _firefox_shim = require('./firefox/firefox_shim');

var firefoxShim = _interopRequireWildcard(_firefox_shim);

var _safari_shim = require('./safari/safari_shim');

var safariShim = _interopRequireWildcard(_safari_shim);

var _common_shim = require('./common_shim');

var commonShim = _interopRequireWildcard(_common_shim);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Shimming starts here.
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
function adapterFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      window = _ref.window;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true
  };

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      if (browserDetails.version === null) {
        logging('Chrome shim can not determine version, not shimming.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimGetStats(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);
      firefoxShim.shimAddTransceiver(window);
      firefoxShim.shimGetParameters(window);
      firefoxShim.shimCreateOffer(window);
      firefoxShim.shimCreateAnswer(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimGetDisplayMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimAudioContext(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}

// Browser shims.

},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimMediaStream = shimMediaStream;
exports.shimOnTrack = shimOnTrack;
exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
exports.shimGetStats = shimGetStats;
exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.fixNegotiationNeeded = fixNegotiationNeeded;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get: function get() {
        return this._ontrack;
      },
      set: function set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },

      enumerable: true,
      configurable: true
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var _this = this;

      if (!this._ontrackpoly) {
        this._ontrackpoly = function (e) {
          // onaddstream does not fire when a track is added to an existing
          // stream. But stream.onaddtrack is implemented so we use that.
          e.stream.addEventListener('addtrack', function (te) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === te.track.id;
              });
            } else {
              receiver = { track: te.track };
            }

            var event = new Event('track');
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function (track) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === track.id;
              });
            } else {
              receiver = { track: track };
            }
            var event = new Event('track');
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
        };
        this.addEventListener('addstream', this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
      return {
        track: track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        var sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };

      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        var idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this2 = this;

      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(function (track) {
        _this2._senders.push(shimSenderWithDtmf(_this2, track));
      });
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);

      stream.getTracks().forEach(function (track) {
        var sender = _this3._senders.find(function (s) {
          return s.track === track;
        });
        if (sender) {
          // remove sender
          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
        }
      });
    };
  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this4 = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this4;
      });
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _this5 = this;

    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.


    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    var fixChromeStats_ = function fixChromeStats_(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function (report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(function (name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    var makeMapStats = function makeMapStats(stats) {
      return new Map(Object.keys(stats).map(function (key) {
        return [key, stats[key]];
      }));
    };

    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function successCallbackWrapper_(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }

    // promise-support
    return new Promise(function (resolve, reject) {
      origGetStats.apply(_this5, [function (response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        var _this6 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this6;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      var sender = this;
      return this._pc.getStats().then(function (result) {
        return (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          utils.filterStats(result, sender.track, true)
        );
      });
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        var _this7 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this7;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      var receiver = this;
      return this._pc.getStats().then(function (result) {
        return utils.filterStats(result, receiver.track, false);
      });
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
      var track = arguments[0];
      var sender = void 0;
      var receiver = void 0;
      var err = void 0;
      this.getSenders().forEach(function (s) {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(function (r) {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this8 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
      return _this8._shimmedLocalStreams[streamId][0];
    });
  };

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    var sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this9 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this9.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    var existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    var newSenders = this.getSenders().filter(function (newSender) {
      return existingSenders.indexOf(newSender) === -1;
    });
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };

  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this10 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          _this10._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (_this10._shimmedLocalStreams[streamId].length === 1) {
          delete _this10._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrack(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this11 = this;

    var nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map(function (stream) {
      return _this11._reverseStreams[stream.id];
    });
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this12 = this;

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this12.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      var newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };

  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    var _this13 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    var streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
      return t === track;
    })) {
      // this is not fully correct but all we can manage without
      // [[associated MediaStreams]] internal slot.
      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
    }

    var alreadyExists = this.getSenders().find(function (s) {
      return s.track === track;
    });
    if (alreadyExists) {
      throw new DOMException('Track already exists.', 'InvalidAccessError');
    }

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    var oldStream = this._streams[stream.id];
    if (oldStream) {
      // this is using odd Chrome behaviour, use with caution:
      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
      // Note: we rely on the high-level addTrack/dtmf shim to
      // create the sender with a dtmf sender.
      oldStream.addTrack(track);

      // Trigger ONN async.
      Promise.resolve().then(function () {
        _this13.dispatchEvent(new Event('negotiationneeded'));
      });
    } else {
      var newStream = new window.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find(function (s) {
      return s.track === track;
    });
  };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function (method) {
    var nativeMethod = window.RTCPeerConnection.prototype[method];
    var methodObj = _defineProperty({}, method, function () {
      var _this14 = this;

      var args = arguments;
      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [function (description) {
          var desc = replaceInternalStreamId(_this14, description);
          args[0].apply(null, [desc]);
        }, function (err) {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then(function (description) {
        return replaceInternalStreamId(_this14, description);
      });
    });
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
    get: function get() {
      var description = origLocalDescription.get.apply(this);
      if (description.type === '') {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });

  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this15 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    // We can not yet check for sender instanceof RTCRtpSender
    // since we shim RTPSender. So we check if sender._pc is set.
    if (!sender._pc) {
      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
    }
    var isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
    }

    // Search for the native stream the senders track belongs to.
    this._streams = this._streams || {};
    var stream = void 0;
    Object.keys(this._streams).forEach(function (streamid) {
      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
        return sender.track === track;
      });
      if (hasTrack) {
        stream = _this15._streams[streamid];
      }
    });

    if (stream) {
      if (stream.getTracks().length === 1) {
        // if this is the last track of the stream, remove the stream. This
        // takes care of any shimmed _senders.
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        // relying on the same odd chrome behaviour as above.
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event('negotiationneeded'));
    }
  };
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  var addIceCandidateNullSupported = window.RTCPeerConnection.prototype.addIceCandidate.length === 0;

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!addIceCandidateNullSupported && !arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
    // in older versions. Native support planned for Chrome M77.
    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}

// Attempt to fix ONN in plan-b mode.
function fixNegotiationNeeded(window) {
  var browserDetails = utils.detectBrowser(window);
  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
    var pc = e.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {
      if (pc.signalingState !== 'stable') {
        return;
      }
    }
    return e;
  });
}

},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then(function (sourceId) {
      var widthSpecified = constraints.video && constraints.video.width;
      var heightSpecified = constraints.video && constraints.video.height;
      var frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

},{}],5:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var logging = utils.log;

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  var browserDetails = utils.detectBrowser(window);

  var constraintsToChrome_ = function constraintsToChrome_(c) {
    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function (key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function oldname_(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === 'deviceId' ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function (mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function shimConstraints_(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && _typeof(constraints.audio) === 'object') {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && _typeof(constraints.video) === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches = void 0;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices().then(function (devices) {
            devices = devices.filter(function (d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function (d) {
              return matches.some(function (match) {
                return d.label.toLowerCase().includes(match);
              });
            });
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function shimError_(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function (c) {
      navigator.webkitGetUserMedia(c, onSuccess, function (e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (cs) {
      return shimConstraints_(cs, function (c) {
        return origGetUserMedia(c).then(function (stream) {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function (e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }
}

},{"../utils.js":15}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimRTCIceCandidate = shimRTCIceCandidate;
exports.shimMaxMessageSize = shimMaxMessageSize;
exports.shimSendThrowTypeError = shimSendThrowTypeError;
exports.shimConnectionState = shimConnectionState;
exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

var _sdp = require('sdp');

var _sdp2 = _interopRequireDefault(_sdp);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
    return;
  }

  var NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get: function get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  var sctpInDescription = function sctpInDescription(description) {
    if (!description || !description.sdp) {
      return false;
    }
    var sections = _sdp2.default.splitSections(description.sdp);
    sections.shift();
    return sections.some(function (mediaSection) {
      var mLine = _sdp2.default.parseMLine(mediaSection);
      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
    // TODO: Is there a better solution for detecting Firefox?
    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    var version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    var canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    var maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    // Chrome decided to not expose .sctp in plan-b mode.
    // As usual, adapter.js has to do an 'ugly worakaround'
    // to cover up the mess.
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
      var _getConfiguration = this.getConfiguration(),
          sdpSemantics = _getConfiguration.sdpSemantics;

      if (sdpSemantics === 'plan-b') {
        Object.defineProperty(this, 'sctp', {
          get: function get() {
            return typeof this._sctp === 'undefined' ? null : this._sctp;
          },

          enumerable: true,
          configurable: true
        });
      }
    }

    if (sctpInDescription(arguments[0])) {
      // Check if the remote is FF.
      var isFirefox = getRemoteFirefoxVersion(arguments[0]);

      // Get the maximum message size the local peer is capable of sending
      var canSendMMS = getCanSendMaxMessageSize(isFirefox);

      // Get the maximum message size of the remote peer.
      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

      // Determine final maximum message size
      var maxMessageSize = void 0;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }

      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
      // attribute.
      var sctp = {};
      Object.defineProperty(sctp, 'maxMessageSize', {
        get: function get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }

    return origSetRemoteDescription.apply(this, arguments);
  };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    var origDataChannelSend = dc.send;
    dc.send = function send() {
      var data = arguments[0];
      var length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    var dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}

/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get: function get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },

    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get: function get() {
      return this._onconnectionstatechange || null;
    },
    set: function set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
      }
    },

    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
    var origMethod = proto[method];
    proto[method] = function () {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = function (e) {
          var pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            var newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeAllowExtmapMixed(window) {
  /* remove a=extmap-allow-mixed for webrtc.org < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
    return;
  }
  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      desc.sdp = desc.sdp.split('\n').filter(function (line) {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
    }
    return nativeSRD.apply(this, arguments);
  };
}

},{"./utils":15,"sdp":17}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimPeerConnection = shimPeerConnection;
exports.shimReplaceTrack = shimReplaceTrack;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _filtericeservers = require('./filtericeservers');

var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (window.RTCIceGatherer) {
    if (!window.RTCIceCandidate) {
      window.RTCIceCandidate = function RTCIceCandidate(args) {
        return args;
      };
    }
    if (!window.RTCSessionDescription) {
      window.RTCSessionDescription = function RTCSessionDescription(args) {
        return args;
      };
    }
    // this adds an additional event listener to MediaStrackTrack that signals
    // when a tracks enabled property was changed. Workaround for a bug in
    // addStream, see below. No longer required in 15025+
    if (browserDetails.version < 15025) {
      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
        set: function set(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }
  }

  // ORTC defines the DTMF sender a bit different.
  // https://github.com/w3c/ortc/issues/714
  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = new window.RTCDtmfSender(this);
          } else if (this.track.kind === 'video') {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
  // Edge currently only implements the RTCDtmfSender, not the
  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
    window.RTCDTMFSender = window.RTCDtmfSender;
  }

  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
  window.RTCPeerConnection = function RTCPeerConnection(config) {
    if (config && config.iceServers) {
      config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
      utils.log('ICE servers after filtering:', config.iceServers);
    }
    return new RTCPeerConnectionShim(config);
  };
  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
}

function shimReplaceTrack(window) {
  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
  }
}

},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterIceServers = filterIceServers;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function (server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function (url) {
        // filter STUN unconditionally.
        if (url.indexOf('stun:') === 0) {
          return false;
        }

        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
        if (validTurn && !hasTurn) {
          hasTurn = true;
          return true;
        }
        return validTurn && !hasTurn;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

},{"../utils":15}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window) {
  if (!('getDisplayMedia' in window.navigator)) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
}

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetUserMedia = shimGetUserMedia;
function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  var shimError_ = function shimError_(e) {
    return {
      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function toString() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function (c) {
    return origGetUserMedia(c).catch(function (e) {
      return Promise.reject(shimError_(e));
    });
  };
}

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimOnTrack = shimOnTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.shimSenderGetStats = shimSenderGetStats;
exports.shimReceiverGetStats = shimReceiverGetStats;
exports.shimRemoveStream = shimRemoveStream;
exports.shimRTCDataChannel = shimRTCDataChannel;
exports.shimAddTransceiver = shimAddTransceiver;
exports.shimGetParameters = shimGetParameters;
exports.shimCreateOffer = shimCreateOffer;
exports.shimCreateAnswer = shimCreateAnswer;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  // as well as ignoring {sdpMid, candidate: ""}
  if (browserDetails.version < 68) {
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      if (arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  var modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
      if (browserDetails.version < 53 && !onSucc) {
        // Shim only promise getStats with spec-hyphens in type names
        // Leave callback version alone; misc old uses of forEach before Map
        try {
          stats.forEach(function (stat) {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== 'TypeError') {
            throw e;
          }
          // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
          stats.forEach(function (stat, i) {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this;
      });
      return senders;
    };
  }

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      var sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      var _this2 = this;

      var receivers = origGetReceivers.apply(this, []);
      receivers.forEach(function (receiver) {
        return receiver._pc = _this2;
      });
      return receivers;
    };
  }
  utils.wrapPeerConnectionEvent(window, 'track', function (e) {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    var _this3 = this;

    utils.deprecated('removeStream', 'removeTrack');
    this.getSenders().forEach(function (sender) {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        _this3.removeTrack(sender);
      }
    });
  };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

function shimAddTransceiver(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      var initParameters = arguments[1];
      var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;
      if (shouldPerformCheck) {
        // If sendEncodings params are provided, validate grammar
        initParameters.sendEncodings.forEach(function (encodingParam) {
          if ('rid' in encodingParam) {
            var ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError('Invalid RID value provided.');
            }
          }
          if ('scaleResolutionDownBy' in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
              throw new RangeError('scale_resolution_down_by must be >= 1.0');
            }
          }
          if ('maxFramerate' in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError('max_framerate must be >= 0.0');
            }
          }
        });
      }
      var transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        // Check if the init options were applied. If not we do this in an
        // asynchronous way and save the promise reference in a global object.
        // This is an ugly hack, but at the same time is way more robust than
        // checking the sender parameters before and after the createOffer
        // Also note that after the createoffer we are not 100% sure that
        // the params were asynchronously applied so we might miss the
        // opportunity to recreate offer.
        var sender = transceiver.sender;

        var params = sender.getParameters();
        if (!('encodings' in params) ||
        // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = initParameters.sendEncodings;
          sender.sendEncodings = initParameters.sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).then(function () {
            delete sender.sendEncodings;
          }).catch(function () {
            delete sender.sendEncodings;
          }));
        }
      }
      return transceiver;
    };
  }
}

function shimGetParameters(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCRtpSender)) {
    return;
  }
  var origGetParameters = window.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window.RTCRtpSender.prototype.getParameters = function getParameters() {
      var params = origGetParameters.apply(this, arguments);
      if (!('encodings' in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}

function shimCreateOffer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer() {
    var _this4 = this,
        _arguments2 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateOffer.apply(_this4, _arguments2);
      }).finally(function () {
        _this4.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimCreateAnswer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var _this5 = this,
        _arguments3 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateAnswer.apply(_this5, _arguments3);
      }).finally(function () {
        _this5.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}

},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
      err.name = 'NotFoundError';
      // from https://heycam.github.io/webidl/#idl-DOMException-error-names
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window.navigator.mediaDevices.getUserMedia(constraints);
  };
}

},{}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimGetUserMedia(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function (constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function remap(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function () {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function (c) {
        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}

},{"../utils":15}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
exports.shimCallbacksAPI = shimCallbacksAPI;
exports.shimGetUserMedia = shimGetUserMedia;
exports.shimConstraints = shimConstraints;
exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
exports.shimCreateOfferLegacy = shimCreateOfferLegacy;
exports.shimAudioContext = shimAudioContext;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimLocalStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    var _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
      stream.getVideoTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
    };

    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      var _this2 = this;

      for (var _len = arguments.length, streams = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        streams[_key - 1] = arguments[_key];
      }

      if (streams) {
        streams.forEach(function (stream) {
          if (!_this2._localStreams) {
            _this2._localStreams = [stream];
          } else if (!_this2._localStreams.includes(stream)) {
            _this2._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      var index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      var tracks = stream.getTracks();
      this.getSenders().forEach(function (sender) {
        if (tracks.includes(sender.track)) {
          _this3.removeTrack(sender);
        }
      });
    };
  }
}

function shimRemoteStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get: function get() {
        return this._onaddstream;
      },
      set: function set(f) {
        var _this4 = this;

        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!_this4._remoteStreams) {
              _this4._remoteStreams = [];
            }
            if (_this4._remoteStreams.includes(stream)) {
              return;
            }
            _this4._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            _this4.dispatchEvent(event);
          });
        });
      }
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}

function shimCallbacksAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  var prototype = window.RTCPeerConnection.prototype;
  var origCreateOffer = prototype.createOffer;
  var origCreateAnswer = prototype.createAnswer;
  var setLocalDescription = prototype.setLocalDescription;
  var setRemoteDescription = prototype.setRemoteDescription;
  var addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  var withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function withCallback(candidate, successCallback, failureCallback) {
    var promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    var mediaDevices = navigator.mediaDevices;
    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = function (constraints) {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  var OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      var newIceServers = [];
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        var server = pcConfig.iceServers[i];
        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in OrigPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      var audioTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'audio';
      });
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === 'sendrecv') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('sendonly');
          } else {
            audioTransceiver.direction = 'sendonly';
          }
        } else if (audioTransceiver.direction === 'recvonly') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('inactive');
          } else {
            audioTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver('audio');
      }

      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      var videoTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'video';
      });
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === 'sendrecv') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('sendonly');
          } else {
            videoTransceiver.direction = 'sendonly';
          }
        } else if (videoTransceiver.direction === 'recvonly') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('inactive');
          } else {
            videoTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver('video');
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimAudioContext(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || window.AudioContext) {
    return;
  }
  window.AudioContext = window.webkitAudioContext;
}

},{"../utils":15}],15:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.extractVersion = extractVersion;
exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
exports.disableLog = disableLog;
exports.disableWarnings = disableWarnings;
exports.log = log;
exports.deprecated = deprecated;
exports.detectBrowser = detectBrowser;
exports.compactObject = compactObject;
exports.walkStats = walkStats;
exports.filterStats = filterStats;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function wrappedCallback(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function get() {
      return this['_on' + eventNameToWrap];
    },
    set: function set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
      }
    },

    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  // Returned result object.
  var result = { browser: null, version: null };

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  var navigator = window.navigator;


  if (navigator.mozGetUserMedia) {
    // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
    // Edge.
    result.browser = 'edge';
    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else {
    // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function (accumulator, key) {
    var isObj = isObject(data[key]);
    var value = isObj ? compactObject(data[key]) : data[key];
    var isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, _defineProperty({}, key, value));
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function (name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function (id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function (value) {
    if (value.type === 'track' && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function (trackStat) {
    result.forEach(function (stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

},{}],16:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldÑ• are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // Ñ•dpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateCompleteâ€¥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        // If the offer contained RTX but the answer did not,
        // remove RTX from sendEncodingParameters.
        var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
      }
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && transceiver.dtlsTransport &&
          !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      }
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":17}],17:[function(require,module,exports){
/* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  var parts = keyParams.substr(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES paramters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substr(12),
    password: pwd.substr(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(obj) {
      return obj.attribute === 'cname';
    })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrÑ–bute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  var mline = SDPUtils.parseMLine(mediaSection);
  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  var maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize: maxMessageSize
    };
  }
  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize: maxMessageSize
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  var output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n'
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
    transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
    transceiver.dtlsTransport.getLocalParameters(),
    type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}]},{},[1])(1)
});
    "use strict";
var exports = {};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebSocketAdaptor = exports.WebRTCAdaptor = exports.PeerStats = void 0;

/**
 *
 * @returns
 */
//
// peer_stats.js
//
class PeerStats {
  constructor(streamId) {
    this.streamId = streamId;
    this.totalBytesReceivedCount = 0;
    this.totalBytesSent = 0;
    this.videoPacketsLost = 0;
    this.fractionLost = 0;
    this.startTime = 0;
    this.lastFramesEncoded = 0;
    this.totalFramesEncodedCount = 0;
    this.lastBytesReceived = 0;
    this.lastBytesSent = 0;
    this.currentTimestamp = 0;
    this.lastTime = 0;
    this.timerId = 0;
    this.firstByteSentCount = 0;
    this.firstBytesReceivedCount = 0;
    this.audioLevel = -1;
    this.qualityLimitationReason = ""; //res width and res height are video source resolutions

    this.resWidth = 0;
    this.resHeight = 0;
    this.srcFps = 0; //frameWidth and frameHeight are the resolutions of the sent video

    this.frameWidth = 0;
    this.frameHeight = 0;
    this.videoRoundTripTime = 0;
    this.videoJitter = 0;
    this.audioRoundTripTime = 0;
    this.audioJitter = 0;
    this.audioPacketsLost = 0;
    this.framesReceived = 0;
    this.framesDropped = 0;
    this.framesDecoded = 0;
    this.audioJitterAverageDelay = 0;
    this.videoJitterAverageDelay = 0;
  } //kbits/sec


  get averageOutgoingBitrate() {
    return Math.floor(8 * (this.totalBytesSentCount - this.firstByteSentCount) / (this.currentTimestamp - this.startTime));
  } //frames per second


  get currentFPS() {
    return ((this.totalFramesEncodedCount - this.lastFramesEncoded) / (this.currentTimestamp - this.lastTime) * 1000).toFixed(1);
  } //kbits/sec


  get averageIncomingBitrate() {
    return Math.floor(8 * (this.totalBytesReceivedCount - this.firstBytesReceivedCount) / (this.currentTimestamp - this.startTime));
  } //kbits/sec


  get currentOutgoingBitrate() {
    return Math.floor(8 * (this.totalBytesSentCount - this.lastBytesSent) / (this.currentTimestamp - this.lastTime));
  } //kbits/sec


  get currentIncomingBitrate() {
    return Math.floor(8 * (this.totalBytesReceivedCount - this.lastBytesReceived) / (this.currentTimestamp - this.lastTime));
  }

  set currentTime(timestamp) {
    this.lastTime = this.currentTimestamp;
    this.currentTimestamp = timestamp;

    if (this.startTime == 0) {
      this.startTime = timestamp - 1; // do not have zero division error
    }
  }

  set totalBytesReceived(bytesReceived) {
    this.lastBytesReceived = this.totalBytesReceivedCount;
    this.totalBytesReceivedCount = bytesReceived;

    if (this.firstBytesReceivedCount == 0) {
      this.firstBytesReceivedCount = bytesReceived;
    }
  }

  set totalBytesSent(bytesSent) {
    this.lastBytesSent = this.totalBytesSentCount;
    this.totalBytesSentCount = bytesSent;

    if (this.firstByteSentCount == 0) {
      this.firstByteSentCount = bytesSent;
    }
  }

  set totalFramesEncoded(framesEncoded) {
    this.lastFramesEncoded = this.totalFramesEncodedCount;
    this.totalFramesEncodedCount = framesEncoded;

    if (this.lastFramesEncoded == 0) {
      this.lastFramesEncoded = framesEncoded;
    }
  }

} //
// websocket_adapter.js
//


exports.PeerStats = PeerStats;

class WebSocketAdaptor {
  constructor(initialValues) {
    this.debug = false;

    for (var key in initialValues) {
      if (initialValues.hasOwnProperty(key)) {
        this[key] = initialValues[key];
      }
    }

    this.initWebSocketConnection();
  }

  initWebSocketConnection(callbackConnected) {
    this.connecting = true;
    this.connected = false;
    this.pingTimerId = -1;
    this.wsConn = new WebSocket(this.websocket_url);

    this.wsConn.onopen = () => {
      if (this.debug) {
        console.debug("websocket connected");
      }

      this.pingTimerId = setInterval(() => {
        this.sendPing();
      }, 3000);
      this.connected = true;
      this.connecting = false;
      this.callback("initialized");

      if (typeof callbackConnected != "undefined") {
        callbackConnected();
      }
    };

    this.wsConn.onmessage = event => {
      var obj = JSON.parse(event.data);

      if (obj.command == "start") {
        //this command is received first, when publishing so playmode is false
        if (this.debug) {
          console.debug("received start command");
        }

        this.webrtcadaptor.startPublishing(obj.streamId);
      } else if (obj.command == "takeCandidate") {
        if (this.debug) {
          console.debug("received ice candidate for stream id " + obj.streamId);
          console.debug(obj.candidate);
        }

        this.webrtcadaptor.takeCandidate(obj.streamId, obj.label, obj.candidate);
      } else if (obj.command == "takeConfiguration") {
        if (this.debug) {
          console.debug("received remote description type for stream id: " + obj.streamId + " type: " + obj.type);
        }

        this.webrtcadaptor.takeConfiguration(obj.streamId, obj.sdp, obj.type);
      } else if (obj.command == "stop") {
        if (this.debug) {
          console.debug("Stop command received");
        }

        this.webrtcadaptor.closePeerConnection(obj.streamId);
      } else if (obj.command == "error") {
        this.callbackError(obj.definition);
      } else if (obj.command == "notification") {
        this.callback(obj.definition, obj);

        if (obj.definition == "play_finished" || obj.definition == "publish_finished") {
          this.webrtcadaptor.closePeerConnection(obj.streamId);
        }
      } else if (obj.command == "streamInformation") {
        this.callback(obj.command, obj);
      } else if (obj.command == "roomInformation") {
        this.callback(obj.command, obj);
      } else if (obj.command == "pong") {
        this.callback(obj.command);
      } else if (obj.command == "trackList") {
        this.callback(obj.command, obj);
      } else if (obj.command == "connectWithNewId") {
        this.multiPeerStreamId = obj.streamId;
        this.join(obj.streamId);
      } else if (obj.command == "peerMessageCommand") {
        this.callback(obj.command, obj);
      }
    };

    this.wsConn.onerror = error => {
      this.connecting = false;
      this.connected = false;
      console.info(" error occured: " + JSON.stringify(error));
      this.clearPingTimer();
      this.callbackError("WebSocketNotConnected", error);
    };

    this.wsConn.onclose = event => {
      this.connecting = false;
      this.connected = false;

      if (this.debug) {
        console.debug("connection closed.");
      }

      this.clearPingTimer();
      this.callback("closed", event);
    };
  }

  clearPingTimer() {
    if (this.pingTimerId != -1) {
      if (this.debug) {
        console.debug("Clearing ping message timer");
      }

      clearInterval(this.pingTimerId);
      this.pingTimerId = -1;
    }
  }

  sendPing() {
    var jsCmd = {
      command: "ping"
    };
    this.wsConn.send(JSON.stringify(jsCmd));
  }

  close() {
    this.wsConn.close();
  }

  send(text) {
    if (this.connecting == false && this.connected == false) {
      //try to reconnect
      this.initWebSocketConnection(() => {
        this.send(text);
      });
      return;
    }

    this.wsConn.send(text);

    if (this.debug) {
      console.debug("sent message:" + text);
    }
  }

  isConnected() {
    return this.connected;
  }

  isConnecting() {
    return this.connecting;
  }

} //
// Original webrtc_adapter
//


exports.WebSocketAdaptor = WebSocketAdaptor;

class ReceivingMessage {
  constructor(size) {
    this.size = size;
    this.received = 0;
    this.data = new ArrayBuffer(size);
  }

}

class WebRTCAdaptor {
  constructor(initialValues) {
    this.peerconnection_config = null;
    this.sdp_constraints = null;
    this.remotePeerConnection = new Array();
    this.remotePeerConnectionStats = new Array();
    this.remoteDescriptionSet = new Array();
    this.iceCandidateList = new Array();
    this.roomName = null;
    this.videoTrackSender = null;
    this.audioTrackSender = null;
    this.playStreamId = new Array();
    this.currentVolume = null;
    this.originalAudioTrackGainNode = null;
    this.videoTrack = null;
    this.audioTrack = null;
    this.smallVideoTrack = null;
    this.audioContext = null;
    this.soundOriginGainNode = null;
    this.secondStreamGainNode = null;
    this.localStream = null;
    this.bandwidth = 900; //default bandwidth kbps

    this.isMultiPeer = false; //used for multiple peer client

    this.multiPeerStreamId = null; //used for multiple peer client

    this.webSocketAdaptor = null;
    this.isPlayMode = false;
    this.debug = false;
    this.viewerInfo = "";
    this.publishStreamId = null;
    this.blackFrameTimer = null;
    /**
     * This is used when only data is brodcasted with the same way video and/or audio.
       * The difference is that no video or audio is sent when this field is true 
     */

    this.onlyDataChannel = false;
    /**
     * While publishing and playing streams data channel is enabled by default
     */

    this.dataChannelEnabled = true;
    this.receivingMessages = new Map();
    this.publishMode = "camera"; //screen, screen+camera

    /**
     * Supported candidate types. Below types are for both sending and receiving candidates.
     * It means if when client receives candidate from STUN server, it sends to the server if candidate's protocol
     * is in the list. Likely, when client receives remote candidate from server, it adds as ice candidate
     * if candidate protocol is in the list below.
     */

    this.candidateTypes = ["udp", "tcp"];
    this.desktopStream = null;
    /**
     * The cam_location below is effective when camera and screen is send at the same time.
     * possible values are top and bottom. It's on right all the time
     */

    this.camera_location = "top";
    /**
     * The cam_margin below is effective when camera and screen is send at the same time.
     * This is the margin value in px from the edges
     */

    this.camera_margin = 15;
    /**
     * this camera_percent is how large the camera view appear on the screen. It's %15 by default.
     */

    this.camera_percent = 15;

    for (var key in initialValues) {
      if (initialValues.hasOwnProperty(key)) {
        this[key] = initialValues[key];
      }
    }

    this.localVideo = document.getElementById(this.localVideoId);
    this.remoteVideo = document.getElementById(this.remoteVideoId); //A dummy stream created to replace the tracks when camera is turned off.

    this.dummyCanvas = document.createElement("canvas"); // It should be compatible with previous version

    // CameraTag Version
    if (this.mediaConstraints?.video?.deviceId?.ideal == "screen") {
      this.publishMode = "screen";
    } else if (this.mediaConstraints?.video?.deviceId?.ideal == "screen+camera") {
      this.publishMode = "screen+camera";
    } else {
      this.publishMode = "camera";
    } 


    // Original AntMedia Version
    // if (this.mediaConstraints.video == "camera") {
    //   this.publishMode = "camera";
    // } else if (this.mediaConstraints.video == "screen") {
    //   this.publishMode = "screen";
    // } else if (this.mediaConstraints.video == "screen+camera") {
    //   this.publishMode = "screen+camera";
    // } //Check browser support for screen share function


    this.checkBrowserScreenShareSupported();

    if (!this.isPlayMode && !this.onlyDataChannel && typeof this.mediaConstraints != "undefined" && this.localStream == null) {
      this.checkWebRTCPermissions(); // Get devices only in publish mode.

      this.getDevices();
      this.trackDeviceChange();

      if (typeof this.mediaConstraints.video != "undefined" && this.mediaConstraints.video != false) {
        this.openStream(this.mediaConstraints, this.mode);
      } else {
        // get only audio
        var media_audio_constraint = {
          audio: this.mediaConstraints.audio
        };
        this.navigatorUserMedia(media_audio_constraint, stream => {
          this.gotStream(stream);
        }, true);
      }
    } else {
      //just playing, it does not open any stream
      this.checkWebSocketConnection();
    }
  }

  setDesktopwithCameraSource(stream, streamId, audioStream, onEndedCallback) {
    this.desktopStream = stream;
    this.navigatorUserMedia({
      video: true,
      audio: false
    }, cameraStream => {
      this.smallVideoTrack = cameraStream.getVideoTracks()[0]; //create a canvas element

      var canvas = document.createElement("canvas");
      var canvasContext = canvas.getContext("2d"); //create video element for screen
      //var screenVideo = document.getElementById('sourceVideo');

      var screenVideo = document.createElement('video');
      screenVideo.srcObject = stream;
      screenVideo.play(); //create video element for camera

      var cameraVideo = document.createElement('video');
      cameraVideo.srcObject = cameraStream;
      cameraVideo.play();
      var canvasStream = canvas.captureStream(15);

      if (this.localStream == null) {
        this.gotStream(canvasStream);
      } else {
        this.updateVideoTrack(canvasStream, streamId, this.mediaConstraints, onended, null);
      }

      if (onEndedCallback != null) {
        stream.getVideoTracks()[0].onended = function (event) {
          onEndedCallback(event);
        };
      } //update the canvas


      setInterval(() => {
        //draw screen to canvas
        canvas.width = screenVideo.videoWidth;
        canvas.height = screenVideo.videoHeight;
        canvasContext.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);
        var cameraWidth = screenVideo.videoWidth * (this.camera_percent / 100);
        var cameraHeight = cameraVideo.videoHeight / cameraVideo.videoWidth * cameraWidth;
        var positionX = canvas.width - cameraWidth - this.camera_margin;
        var positionY;

        if (this.camera_location == "top") {
          positionY = this.camera_margin;
        } else {
          //if not top, make it bottom
          //draw camera on right bottom corner
          positionY = canvas.height - cameraHeight - this.camera_margin;
        }

        canvasContext.drawImage(cameraVideo, positionX, positionY, cameraWidth, cameraHeight);
      }, 66);
    }, true);
  }

  trackDeviceChange() {
    navigator.mediaDevices.ondevicechange = () => {
      this.getDevices();
    };
  }

  getDevices() {
    navigator.mediaDevices.enumerateDevices().then(devices => {
      let deviceArray = new Array();
      let checkAudio = false;
      devices.forEach(device => {
        if (device.kind == "audioinput" || device.kind == "videoinput") {
          deviceArray.push(device);

          if (device.kind == "audioinput") {
            checkAudio = true;
          }
        }
      });
      this.callback("available_devices", deviceArray);

      if (checkAudio == false && this.localStream == null) {
        console.log("Audio input not found");
        console.log("Retrying to get user media without audio");
        this.openStream({
          video: true,
          audio: false
        }, this.mode);
      }
    }).catch(err => {
      console.error("Cannot get devices -> error name: " + err.name + ": " + err.message);
    });
  }

  prepareStreamTracks(mediaConstraints, audioConstraint, stream, streamId) {
    //this trick, getting audio and video separately, make us add or remove tracks on the fly
    var audioTrack = stream.getAudioTracks();

    if (audioTrack.length > 0 && this.publishMode == "camera") {
      audioTrack[0].stop();
      stream.removeTrack(audioTrack[0]);
    } //now get only audio to add this stream


    if (audioConstraint != "undefined" && audioConstraint != false) {
      var media_audio_constraint = {
        audio: audioConstraint
      };
      this.navigatorUserMedia(media_audio_constraint, audioStream => {
        audioStream = this.setGainNodeStream(audioStream);

        if (this.originalAudioTrackGainNode !== null) {
          this.originalAudioTrackGainNode.stop();
        }

        this.originalAudioTrackGainNode = audioStream.getAudioTracks()[1]; //add callback if desktop is sharing

        var onended = event => {
          this.callback("screen_share_stopped");
          this.setVideoCameraSource(streamId, mediaConstraints, null, true);
        };

        if (this.publishMode == "screen") {
          this.updateVideoTrack(stream, streamId, mediaConstraints, onended, true);

          if (audioTrack.length > 0) {
            var mixedStream = this.mixAudioStreams(stream, audioStream, streamId);
            this.updateAudioTrack(mixedStream, streamId, null);
          } else {
            this.updateAudioTrack(audioStream, streamId, null);
          }
        } else if (this.publishMode == "screen+camera") {
          if (audioTrack.length > 0) {
            var mixedStream = this.mixAudioStreams(stream, audioStream, streamId);
            this.updateAudioTrack(mixedStream, streamId, null);
            this.setDesktopwithCameraSource(stream, streamId, mixedStream, onended);
          } else {
            this.updateAudioTrack(audioStream, streamId, null);
            this.setDesktopwithCameraSource(stream, streamId, audioStream, onended);
          }
        } else {
          if (audioConstraint != false && audioConstraint != undefined) {
            stream.addTrack(audioStream.getAudioTracks()[0]);
          }

          this.gotStream(stream);
        }

        this.checkWebSocketConnection();
      }, true);
    } else {
      if (typeof audioStream != "undefined" && audioStream.getAudioTracks()[0] != null) {
        stream.addTrack(audioStream.getAudioTracks()[0]);
      }

      this.gotStream(stream);
    }
  }

  navigatorUserMedia(mediaConstraints, func, catch_error) {
    if (catch_error == true) {
      navigator.mediaDevices.getUserMedia(mediaConstraints).then(func).catch(error => {
        if (error.name == "NotFoundError") {
          this.getDevices();
        } else {
          this.callbackError(error.name, error.message);
        }
      });
    } else {
      navigator.mediaDevices.getUserMedia(mediaConstraints).then(func);
    }
  }
  /**
   * Get user media
   */


  getUserMedia(mediaConstraints, audioConstraint, streamId) {
    const resetTrack = stream => {
      let videoTracks = stream.getVideoTracks();
      let audioTracks = stream.getAudioTracks();

      if (videoTracks.length > 0) {
        if (this.videoTrack !== null) this.videoTrack.stop();
        this.videoTrack = videoTracks[0];
      }

      if (audioTracks.length > 0) {
        if (this.audioTrack !== null) this.audioTrack.stop();
        this.audioTrack = audioTracks[0];
      }

      if (this.smallVideoTrack) this.smallVideoTrack.stop();
      return stream;
    }; // Check Media Constraint video value screen or screen + camera


    if (this.publishMode == "screen+camera" || this.publishMode == "screen") {
      navigator.mediaDevices.getDisplayMedia(mediaConstraints).then(stream => {
        resetTrack(stream);
        this.prepareStreamTracks(mediaConstraints, audioConstraint, stream, streamId);
      }).catch(error => {
        if (error.name === "NotAllowedError") {
          console.debug("Permission denied error");
          this.callbackError("ScreenSharePermissionDenied"); // Redirect Default Stream Camera

          if (this.localStream == null) {
            var mediaConstraints = {
              video: true,
              audio: true
            };
            this.openStream(mediaConstraints);
          } else {
            this.switchVideoCameraCapture(streamId);
          }
        }
      });
    } // If mediaConstraints only user camera
    else {
      this.navigatorUserMedia(mediaConstraints, stream => {
        resetTrack(stream);
        this.prepareStreamTracks(mediaConstraints, audioConstraint, stream, streamId);
      }, true);
    }
  }
  /**
   * Open media stream, it may be screen, camera or audio
   */


  openStream(mediaConstraints) {
    this.mediaConstraints = mediaConstraints;
    var audioConstraint = false;

    if (typeof mediaConstraints.audio != "undefined" && mediaConstraints.audio != false) {
      audioConstraint = mediaConstraints.audio;
    }

    if (typeof mediaConstraints.video != "undefined") {
      this.getUserMedia(mediaConstraints, audioConstraint);
    } else {
      console.error("MediaConstraint video is not defined");
      this.callbackError("media_constraint_video_not_defined");
    }
  }
  /**
   * Closes stream, if you want to stopÂ peer connection, call stop(streamId)
   */


  closeStream() {
    this.localStream.getVideoTracks().forEach(function (track) {
      track.onended = null;
      track.stop();
    });
    this.localStream.getAudioTracks().forEach(function (track) {
      track.onended = null;
      track.stop();
    });

    if (this.videoTrack !== null) {
      this.videoTrack.stop();
    }

    if (this.audioTrack !== null) {
      this.audioTrack.stop();
    }

    if (this.smallVideoTrack !== null) {
      this.smallVideoTrack.stop();
    }

    if (this.originalAudioTrackGainNode) {
      this.originalAudioTrackGainNode.stop();
    }
  }
  /*
  * Checks if we is permitted from browser
  */


  checkWebRTCPermissions() {
    if (!("WebSocket" in window)) {
      console.log("WebSocket not supported.");
      this.callbackError("WebSocketNotSupported");
      return;
    }

    if (typeof navigator.mediaDevices == "undefined" && this.isPlayMode == false) {
      console.log("Cannot open camera and mic because of unsecure context. Please Install SSL(https)");
      this.callbackError("UnsecureContext");
      return;
    }

    if (typeof navigator.mediaDevices == "undefined" || navigator.mediaDevices == undefined || navigator.mediaDevices == null) {
      this.callbackError("getUserMediaIsNotAllowed");
    }
  }
  /**
   * Checks browser supports screen share feature
   * if exist it calls callback with "browser_screen_share_supported"
   */


  checkBrowserScreenShareSupported() {
    if (typeof navigator.mediaDevices != "undefined" && navigator.mediaDevices.getDisplayMedia || navigator.getDisplayMedia) {
      this.callback("browser_screen_share_supported");
    }
  }

  enableSecondStreamInMixedAudio(enable) {
    if (this.secondStreamGainNode != null) {
      if (enable) {
        this.secondStreamGainNode.gain.value = 1;
      } else {
        this.secondStreamGainNode.gain.value = 0;
      }
    }
  }

  publish(streamId, token, subscriberId, subscriberCode, streamName, mainTrack) {
    this.publishStreamId = streamId;

    if (this.onlyDataChannel) {
      var jsCmd = {
        command: "publish",
        streamId: streamId,
        token: token,
        subscriberId: typeof subscriberId !== undefined ? subscriberId : "",
        subscriberCode: typeof subscriberCode !== undefined ? subscriberCode : "",
        streamName: typeof streamName !== undefined ? streamName : "",
        mainTrack: typeof mainTrack !== undefined ? mainTrack : "",
        video: false,
        audio: false
      };
    } //If it started with playOnly mode and wants to publish now
    else if (this.localStream == null) {
      this.navigatorUserMedia(this.mediaConstraints, stream => {
        this.gotStream(stream);
        var jsCmd = {
          command: "publish",
          streamId: streamId,
          token: token,
          subscriberId: typeof subscriberId !== undefined ? subscriberId : "",
          subscriberCode: typeof subscriberCode !== undefined ? subscriberCode : "",
          streamName: typeof streamName !== undefined ? streamName : "",
          mainTrack: typeof mainTrack !== undefined ? mainTrack : "",
          video: this.localStream.getVideoTracks().length > 0 ? true : false,
          audio: this.localStream.getAudioTracks().length > 0 ? true : false
        };
        this.webSocketAdaptor.send(JSON.stringify(jsCmd));
      }, false);
    } else {
      var jsCmd = {
        command: "publish",
        streamId: streamId,
        token: token,
        subscriberId: typeof subscriberId !== undefined ? subscriberId : "",
        subscriberCode: typeof subscriberCode !== undefined ? subscriberCode : "",
        streamName: typeof streamName !== undefined ? streamName : "",
        mainTrack: typeof mainTrack !== undefined ? mainTrack : "",
        video: this.localStream.getVideoTracks().length > 0 ? true : false,
        audio: this.localStream.getAudioTracks().length > 0 ? true : false
      };
    }

    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  joinRoom(roomName, streamId, mode) {
    this.roomName = roomName;
    var jsCmd = {
      command: "joinRoom",
      room: roomName,
      streamId: streamId,
      mode: mode
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  play(streamId, token, roomId, enableTracks, subscriberId, subscriberCode) {
    this.playStreamId.push(streamId);
    var jsCmd = {
      command: "play",
      streamId: streamId,
      token: token,
      room: roomId,
      trackList: enableTracks,
      subscriberId: typeof subscriberId !== undefined ? subscriberId : "",
      subscriberCode: typeof subscriberCode !== undefined ? subscriberCode : "",
      viewerInfo: this.viewerInfo
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  stop(streamId) {
    this.closePeerConnection(streamId);
    var jsCmd = {
      command: "stop",
      streamId: streamId
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  join(streamId) {
    var jsCmd = {
      command: "join",
      streamId: streamId,
      multiPeer: this.isMultiPeer && this.multiPeerStreamId == null,
      mode: this.isPlayMode ? "play" : "both"
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  leaveFromRoom(roomName) {
    this.roomName = roomName;
    var jsCmd = {
      command: "leaveFromRoom",
      room: roomName
    };
    console.log("leave request is sent for " + roomName);
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  leave(streamId) {
    var jsCmd = {
      command: "leave",
      streamId: this.isMultiPeer && this.multiPeerStreamId != null ? this.multiPeerStreamId : streamId
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
    this.closePeerConnection(streamId);
    this.multiPeerStreamId = null;
  }

  getStreamInfo(streamId) {
    var jsCmd = {
      command: "getStreamInfo",
      streamId: streamId
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  getRoomInfo(roomName, streamId) {
    var jsCmd = {
      command: "getRoomInfo",
      streamId: streamId,
      room: roomName
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  enableTrack(mainTrackId, trackId, enabled) {
    var jsCmd = {
      command: "enableTrack",
      streamId: mainTrackId,
      trackId: trackId,
      enabled: enabled
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  getTracks(streamId, token) {
    this.playStreamId.push(streamId);
    var jsCmd = {
      command: "getTrackList",
      streamId: streamId,
      token: token
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  gotStream(stream) {
    stream = this.setGainNodeStream(stream);
    this.localStream = stream;
    this.localVideo.srcObject = stream;
    this.checkWebSocketConnection();
    this.getDevices();
  }
  /**
  * Toggle video track on the server side.
  *
  * streamId is the id of the stream
  * trackId is the id of the track. streamId is also one of the trackId of the stream. If you are having just a single track on your 
  *         stream, you need to give streamId as trackId parameter as well.  
  * enabled is the enable/disable video track. If it's true, server sends video track. If it's false, server does not send video
  
  */


  toggleVideo(streamId, trackId, enabled) {
    var jsCmd = {
      command: "toggleVideo",
      streamId: streamId,
      trackId: trackId,
      enabled: enabled
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }
  /**
  * Toggle audio track on the server side.
  *
  * streamId is the id of the stream
  * trackId is the id of the track. streamId is also one of the trackId of the stream. If you are having just a single track on your 
  *         stream, you need to give streamId as trackId parameter as well.  
  * enabled is the enable/disable video track. If it's true, server sends audio track. If it's false, server does not send audio
  *
  */


  toggleAudio(streamId, trackId, enabled) {
    var jsCmd = {
      command: "toggleAudio",
      streamId: streamId,
      trackId: trackId,
      enabled: enabled
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  switchDesktopCapture(streamId) {
    this.publishMode = "screen";
    var audioConstraint = false;

    if (typeof this.mediaConstraints.audio != "undefined" && this.mediaConstraints.audio != false) {
      audioConstraint = this.mediaConstraints.audio;
    }

    if (typeof this.mediaConstraints.video != "undefined" && this.mediaConstraints.video != false) {
      this.mediaConstraints.video = true;
    }

    this.getUserMedia(this.mediaConstraints, audioConstraint, streamId);
  }
  /*
  * This method mixed the first stream audio to the second stream audio and 
  * returns mixed stream. 
  * stream: Initiali stream that contain video and audio
  * 
  */


  mixAudioStreams(stream, secondStream, streamId) {
    //console.debug("audio stream track count: " + audioStream.getAudioTracks().length);
    var composedStream = new MediaStream(); //added the video stream from the screen

    stream.getVideoTracks().forEach(function (videoTrack) {
      composedStream.addTrack(videoTrack);
    });
    this.audioContext = new AudioContext();
    var audioDestionation = this.audioContext.createMediaStreamDestination();

    if (stream.getAudioTracks().length > 0) {
      this.soundOriginGainNode = this.audioContext.createGain(); //Adjust the gain for screen sound

      this.soundOriginGainNode.gain.value = 1;
      var audioSource = this.audioContext.createMediaStreamSource(stream);
      audioSource.connect(this.soundOriginGainNode).connect(audioDestionation);
    } else {
      console.debug("Origin stream does not have audio track");
    }

    if (secondStream.getAudioTracks().length > 0) {
      this.secondStreamGainNode = this.audioContext.createGain(); //Adjust the gain for second sound

      this.secondStreamGainNode.gain.value = 1;
      var audioSource2 = this.audioContext.createMediaStreamSource(secondStream);
      audioSource2.connect(this.secondStreamGainNode).connect(audioDestionation);
    } else {
      console.debug("Second stream does not have audio track");
    }

    audioDestionation.stream.getAudioTracks().forEach(function (track) {
      composedStream.addTrack(track);
      console.log("audio destination add track");
    });
    return composedStream;
  }

  setGainNodeStream(stream) {
    // Get the videoTracks from the stream.
    const videoTracks = stream.getVideoTracks(); // Get the audioTracks from the stream.

    const audioTracks = stream.getAudioTracks();
    /**
    * Create a new audio context and build a stream source,
    * stream destination and a gain node. Pass the stream into 
    * the mediaStreamSource so we can use it in the Web Audio API.
    */

    this.audioContext = new AudioContext();
    let mediaStreamSource = this.audioContext.createMediaStreamSource(stream);
    let mediaStreamDestination = this.audioContext.createMediaStreamDestination();
    this.soundOriginGainNode = this.audioContext.createGain();
    /**
    * Connect the stream to the gainNode so that all audio
    * passes through the gain and can be controlled by it.
    * Then pass the stream from the gain to the mediaStreamDestination
    * which can pass it back to the RTC client.
    */

    mediaStreamSource.connect(this.soundOriginGainNode);
    this.soundOriginGainNode.connect(mediaStreamDestination);

    if (this.currentVolume == null) {
      this.soundOriginGainNode.gain.value = 1;
    } else {
      this.soundOriginGainNode.gain.value = this.currentVolume;
    }
    /**
    * The mediaStreamDestination.stream outputs a MediaStream object
    * containing a single AudioMediaStreamTrack. Add the video track
    * to the new stream to rejoin the video with the controlled audio.
    */


    const controlledStream = mediaStreamDestination.stream;

    for (const videoTrack of videoTracks) {
      controlledStream.addTrack(videoTrack);
    }

    for (const audioTrack of audioTracks) {
      controlledStream.addTrack(audioTrack);
    }
    /**
    * Use the stream that went through the gainNode. This
    * is the same stream but with altered input volume levels.
    */


    return controlledStream;
  }

  switchAudioInputSource(streamId, deviceId) {
    //stop the track because in some android devices need to close the current camera stream
    var audioTrack = this.localStream.getAudioTracks()[0];

    if (audioTrack) {
      audioTrack.stop();
    } else {
      console.warn("There is no audio track in local stream");
    }

    if (typeof deviceId != "undefined") {
      if (this.mediaConstraints.audio !== true) this.mediaConstraints.audio.deviceId = deviceId;else this.mediaConstraints.audio = {
        "deviceId": deviceId
      };
    }

    this.setAudioInputSource(streamId, this.mediaConstraints, null, true, deviceId);
  }

  switchVideoCameraCapture(streamId, deviceId) {
    //stop the track because in some android devices need to close the current camera stream
    var videoTrack = this.localStream.getVideoTracks()[0];

    if (videoTrack) {
      videoTrack.stop();
    } else {
      console.warn("There is no video track in local stream");
    }

    this.publishMode = "camera";

    if (typeof deviceId != "undefined") {
      if (this.mediaConstraints.video !== true) this.mediaConstraints.video.deviceId = {
        exact: deviceId
      };else this.mediaConstraints.video = {
        deviceId: {
          exact: deviceId
        }
      };
    }

    this.setVideoCameraSource(streamId, this.mediaConstraints, null, true, deviceId);
  }

  switchDesktopCaptureWithCamera(streamId) {
    this.publishMode = "screen+camera";
    var audioConstraint = false;

    if (typeof this.mediaConstraints.audio != "undefined" && this.mediaConstraints.audio != false) {
      audioConstraint = this.mediaConstraints.audio;
    }

    this.getUserMedia(this.mediaConstraints, audioConstraint, streamId);
  }
  /**
   * This method updates the local stream. It removes existant audio track from the local stream
   * and add the audio track in `stream` parameter to the local stream
   */


  updateLocalAudioStream(stream, onEndedCallback) {
    var newAudioTrack = stream.getAudioTracks()[0];

    if (this.localStream != null && this.localStream.getAudioTracks()[0] != null) {
      var audioTrack = this.localStream.getAudioTracks()[0];
      this.localStream.removeTrack(audioTrack);
      audioTrack.stop();
      this.localStream.addTrack(newAudioTrack);
    } else if (this.localStream != null) {
      this.localStream.addTrack(newAudioTrack);
    } else {
      this.localStream = stream;
    }

    if (this.localVideo != null) {
      //it can be null
      this.localVideo.srcObject = this.localStream;
    }

    if (onEndedCallback != null) {
      stream.getAudioTracks()[0].onended = function (event) {
        onEndedCallback(event);
      };
    }
  }
  /**
   * This method updates the local stream. It removes existant video track from the local stream
   * and add the video track in `stream` parameter to the local stream
   */


  updateLocalVideoStream(stream, onEndedCallback, stopDesktop) {
    if (stopDesktop && this.desktopStream != null) {
      this.desktopStream.getVideoTracks()[0].stop();
    }

    var newVideoTrack = stream.getVideoTracks()[0];

    if (this.localStream != null && this.localStream.getVideoTracks()[0] != null) {
      var videoTrack = this.localStream.getVideoTracks()[0];
      this.localStream.removeTrack(videoTrack);
      videoTrack.stop();
      this.localStream.addTrack(newVideoTrack);
    } else if (this.localStream != null) {
      this.localStream.addTrack(newVideoTrack);
    } else {
      this.localStream = stream;
    }

    if (this.localVideo) {
      this.localVideo.srcObject = this.localStream;
    }

    if (onEndedCallback != null) {
      stream.getVideoTracks()[0].onended = function (event) {
        onEndedCallback(event);
      };
    }
  }
  /**
   * This method sets Audio Input Source. 
   * It calls updateAudioTrack function for the update local audio stream.
   */


  setAudioInputSource(streamId, mediaConstraints, onEndedCallback) {
    this.navigatorUserMedia(mediaConstraints, stream => {
      this.updateAudioTrack(stream, streamId, mediaConstraints, onEndedCallback);
    }, true);
  }
  /**
   * This method sets Video Input Source. 
   * It calls updateVideoTrack function for the update local video stream.
   */


  setVideoCameraSource(streamId, mediaConstraints, onEndedCallback, stopDesktop) {
    this.navigatorUserMedia(mediaConstraints, stream => {
      stream = this.setGainNodeStream(stream);
      this.updateVideoTrack(stream, streamId, mediaConstraints, onEndedCallback, stopDesktop);
      this.updateAudioTrack(stream, streamId, mediaConstraints, onEndedCallback);
    }, true);
  }

  updateAudioTrack(stream, streamId, onEndedCallback) {
    if (this.remotePeerConnection[streamId] != null) {
      var audioTrackSender = this.remotePeerConnection[streamId].getSenders().find(function (s) {
        return s.track.kind == "audio";
      });

      if (audioTrackSender) {
        audioTrackSender.replaceTrack(stream.getAudioTracks()[0]).then(result => {
          this.updateLocalAudioStream(stream, onEndedCallback);
        }).catch(function (error) {
          console.log(error.name);
        });
      } else {
        console.error("AudioTrackSender is undefined or null");
      }
    } else {
      this.updateLocalAudioStream(stream, onEndedCallback);
    }
  }

  updateVideoTrack(stream, streamId, mediaConstraints, onEndedCallback, stopDesktop) {
    if (this.remotePeerConnection[streamId] != null) {
      var videoTrackSender = this.remotePeerConnection[streamId].getSenders().find(function (s) {
        return s.track.kind == "video";
      });

      if (videoTrackSender) {
        videoTrackSender.replaceTrack(stream.getVideoTracks()[0]).then(result => {
          this.updateLocalVideoStream(stream, onEndedCallback, stopDesktop);
        }).catch(error => {
          console.log(error.name);
        });
      } else {
        console.error("VideoTrackSender is undefined or null");
      }
    } else {
      this.updateLocalVideoStream(stream, onEndedCallback, stopDesktop);
    }
  }

  onTrack(event, streamId) {
    console.log("onTrack");

    if (this.remoteVideo != null) {
      //this.remoteVideo.srcObject = event.streams[0];
      if (this.remoteVideo.srcObject !== event.streams[0]) {
        this.remoteVideo.srcObject = event.streams[0];
        console.log('Received remote stream');
      }
    } else {
      var dataObj = {
        stream: event.streams[0],
        track: event.track,
        streamId: streamId
      };
      this.callback("newStreamAvailable", dataObj);
    }
  }

  iceCandidateReceived(event, streamId) {
    if (event.candidate) {
      var protocolSupported = false;

      if (event.candidate.candidate == "") {
        //event candidate can be received and its value can be "".
        //don't compare the protocols
        protocolSupported = true;
      } else if (typeof event.candidate.protocol == "undefined") {
        this.candidateTypes.forEach(element => {
          if (event.candidate.candidate.toLowerCase().includes(element)) {
            protocolSupported = true;
          }
        });
      } else {
        protocolSupported = this.candidateTypes.includes(event.candidate.protocol.toLowerCase());
      }

      if (protocolSupported) {
        var jsCmd = {
          command: "takeCandidate",
          streamId: streamId,
          label: event.candidate.sdpMLineIndex,
          id: event.candidate.sdpMid,
          candidate: event.candidate.candidate
        };

        if (this.debug) {
          console.log("sending ice candiate for stream Id " + streamId);
          console.log(JSON.stringify(event.candidate));
        }

        this.webSocketAdaptor.send(JSON.stringify(jsCmd));
      } else {
        console.log("Candidate's protocol(full sdp: " + event.candidate.candidate + ") is not supported. Supported protocols: " + this.candidateTypes);

        if (event.candidate.candidate != "") {
          //
          this.callbackError("protocol_not_supported", "Support protocols: " + this.candidateTypes.toString() + " candidate: " + event.candidate.candidate);
        }
      }
    } else {
      console.log("No event.candidate in the iceCandidate event");
    }
  }

  initDataChannel(streamId, dataChannel) {
    dataChannel.onerror = error => {
      console.log("Data Channel Error:", error);
      var obj = {
        streamId: streamId,
        error: error
      };
      console.log("channel status: ", dataChannel.readyState);

      if (dataChannel.readyState != "closed") {
        this.callbackError("data_channel_error", obj);
      }
    };

    dataChannel.onmessage = event => {
      var obj = {
        streamId: streamId,
        data: event.data
      };
      var data = obj.data;

      if (typeof data === 'string' || data instanceof String) {
        this.callback("data_received", obj);
      } else {
        var length = data.length || data.size || data.byteLength;
        var view = new Int32Array(data, 0, 1);
        var token = view[0];
        var msg = this.receivingMessages[token];

        if (msg == undefined) {
          var view = new Int32Array(data, 0, 2);
          var size = view[1];
          msg = new ReceivingMessage(size);
          this.receivingMessages[token] = msg;

          if (length > 8) {
            console.error("something went wrong in msg receiving");
          }

          return;
        }

        var rawData = data.slice(4, length);
        var dataView = new Uint8Array(msg.data);
        dataView.set(new Uint8Array(rawData), msg.received, length - 4);
        msg.received += length - 4;

        if (msg.size == msg.received) {
          obj.data = msg.data;
          this.callback("data_received", obj);
        }
      }
    };

    dataChannel.onopen = () => {
      this.remotePeerConnection[streamId].dataChannel = dataChannel;
      console.log("Data channel is opened");
      this.callback("data_channel_opened", streamId);
    };

    dataChannel.onclose = () => {
      console.log("Data channel is closed");
      this.callback("data_channel_closed", streamId);
    };
  } // data channel mode can be "publish" , "play" or "peer" based on this it is decided which way data channel is created


  initPeerConnection(streamId, dataChannelMode) {
    if (this.remotePeerConnection[streamId] == null) {
      var closedStreamId = streamId;
      console.log("stream id in init peer connection: " + streamId + " close stream id: " + closedStreamId);
      this.remotePeerConnection[streamId] = new RTCPeerConnection(this.peerconnection_config);
      this.remoteDescriptionSet[streamId] = false;
      this.iceCandidateList[streamId] = new Array();

      if (!this.playStreamId.includes(streamId)) {
        if (this.localStream != null) {
          this.remotePeerConnection[streamId].addStream(this.localStream);
        }
      }

      this.remotePeerConnection[streamId].onicecandidate = event => {
        this.iceCandidateReceived(event, closedStreamId);
      };

      this.remotePeerConnection[streamId].ontrack = event => {
        this.onTrack(event, closedStreamId);
      };

      if (this.dataChannelEnabled) {
        // skip initializing data channel if it is disabled
        if (dataChannelMode == "publish") {
          //open data channel if it's publish mode peer connection 
          const dataChannelOptions = {
            ordered: true
          };

          if (this.remotePeerConnection[streamId].createDataChannel) {
            var dataChannel = this.remotePeerConnection[streamId].createDataChannel(streamId, dataChannelOptions);
            this.initDataChannel(streamId, dataChannel);
          } else {
            console.warn("CreateDataChannel is not supported");
          }
        } else if (dataChannelMode == "play") {
          //in play mode, server opens the data channel 
          this.remotePeerConnection[streamId].ondatachannel = ev => {
            this.initDataChannel(streamId, ev.channel);
          };
        } else {
          //for peer mode do both for now
          const dataChannelOptions = {
            ordered: true
          };

          if (this.remotePeerConnection[streamId].createDataChannel) {
            var dataChannelPeer = this.remotePeerConnection[streamId].createDataChannel(streamId, dataChannelOptions);
            this.initDataChannel(streamId, dataChannelPeer);

            this.remotePeerConnection[streamId].ondatachannel = ev => {
              this.initDataChannel(streamId, ev.channel);
            };
          } else {
            console.warn("CreateDataChannel is not supported");
          }
        }
      }

      this.remotePeerConnection[streamId].oniceconnectionstatechange = event => {
        var obj = {
          state: this.remotePeerConnection[streamId].iceConnectionState,
          streamId: streamId
        };
        this.callback("ice_connection_state_changed", obj);

        if (!this.isPlayMode) {
          if (this.remotePeerConnection[streamId].iceConnectionState == "connected") {
            this.changeBandwidth(this.bandwidth, streamId).then(() => {
              console.log("Bandwidth is changed to " + this.bandwidth);
            }).catch(e => console.warn(e));
          }
        }
      };
    }
  }

  closePeerConnection(streamId) {
    if (this.remotePeerConnection[streamId] != null) {
      if (this.remotePeerConnection[streamId].dataChannel != null) {
        this.remotePeerConnection[streamId].dataChannel.close();
      }

      if (this.remotePeerConnection[streamId].signalingState != "closed") {
        this.remotePeerConnection[streamId].close();
        this.remotePeerConnection[streamId] = null;
        delete this.remotePeerConnection[streamId];
        var playStreamIndex = this.playStreamId.indexOf(streamId);

        if (playStreamIndex != -1) {
          this.playStreamId.splice(playStreamIndex, 1);
        }
      }
    }

    if (this.remotePeerConnectionStats[streamId] != null) {
      clearInterval(this.remotePeerConnectionStats[streamId].timerId);
      delete this.remotePeerConnectionStats[streamId];
    }
  }

  signallingState(streamId) {
    if (this.remotePeerConnection[streamId] != null) {
      return this.remotePeerConnection[streamId].signalingState;
    }

    return null;
  }

  iceConnectionState(streamId) {
    if (this.remotePeerConnection[streamId] != null) {
      return this.remotePeerConnection[streamId].iceConnectionState;
    }

    return null;
  }

  gotDescription(configuration, streamId) {
    this.remotePeerConnection[streamId].setLocalDescription(configuration).then(responose => {
      console.debug("Set local description successfully for stream Id " + streamId);
      var jsCmd = {
        command: "takeConfiguration",
        streamId: streamId,
        type: configuration.type,
        sdp: configuration.sdp
      };

      if (this.debug) {
        console.debug("local sdp: ");
        console.debug(configuration.sdp);
      }

      this.webSocketAdaptor.send(JSON.stringify(jsCmd));
    }).catch(error => {
      console.error("Cannot set local description. Error is: " + error);
    });
  }

  initializeDummyFrame() {
    this.dummyCanvas.getContext('2d').fillRect(0, 0, 320, 240);
    this.replacementStream = this.dummyCanvas.captureStream();
  }

  turnOffLocalCamera(streamId) {
    //Initialize the first dummy frame for switching.
    this.initializeDummyFrame();

    if (this.remotePeerConnection != null) {
      let choosenId;

      if (streamId != null || typeof streamId != "undefined") {
        choosenId = streamId;
      } else {
        choosenId = this.publishStreamId;
      }

      this.updateVideoTrack(this.replacementStream, choosenId, this.mediaConstraints, null, true);
    } else {
      this.callbackError("NoActiveConnection");
    } //We need to send black frames within a time interval, because when the user turn off the camera,
    //player can't connect to the sender since there is no data flowing. Sending a black frame in each 3 seconds resolves it.


    if (this.blackFrameTimer == null) {
      this.blackFrameTimer = setInterval(() => {
        this.initializeDummyFrame();
      }, 3000);
    }
  }

  turnOnLocalCamera(streamId) {
    if (this.blackFrameTimer != null) {
      clearInterval(this.blackFrameTimer);
      this.blackFrameTimer = null;
    }

    if (this.localStream == null) {
      this.navigatorUserMedia(this.mediaConstraints, stream => {
        this.gotStream(stream);
      }, false);
    } //This method will get the camera track and replace it with dummy track
    else if (this.remotePeerConnection != null) {
      this.navigatorUserMedia(this.mediaConstraints, stream => {
        let choosenId;

        if (streamId != null || typeof streamId != "undefined") {
          choosenId = streamId;
        } else {
          choosenId = this.publishStreamId;
        }

        this.updateVideoTrack(stream, choosenId, this.mediaConstraints, null, true);
      }, false);
    } else {
      this.callbackError("NoActiveConnection");
    }
  }

  muteLocalMic() {
    if (this.remotePeerConnection != null) {
      var track = this.localStream.getAudioTracks()[0];
      track.enabled = false;
    } else {
      this.callbackError("NoActiveConnection");
    }
  }
  /**
   * if there is audio it calls callbackError with "AudioAlreadyActive" parameter
   */


  unmuteLocalMic() {
    if (this.remotePeerConnection != null) {
      var track = this.localStream.getAudioTracks()[0];
      track.enabled = true;
    } else {
      this.callbackError("NoActiveConnection");
    }
  }

  takeConfiguration(idOfStream, configuration, typeOfConfiguration) {
    var streamId = idOfStream;
    var type = typeOfConfiguration;
    var conf = configuration;
    var isTypeOffer = type == "offer";
    var dataChannelMode = "publish";

    if (isTypeOffer) {
      dataChannelMode = "play";
    }

    this.initPeerConnection(streamId, dataChannelMode);
    this.remotePeerConnection[streamId].setRemoteDescription(new RTCSessionDescription({
      sdp: conf,
      type: type
    })).then(response => {
      if (this.debug) {
        console.debug("set remote description is succesfull with response: " + response + " for stream : " + streamId + " and type: " + type);
        console.debug(conf);
      }

      this.remoteDescriptionSet[streamId] = true;
      var length = this.iceCandidateList[streamId].length;
      console.debug("Ice candidate list size to be added: " + length);

      for (var i = 0; i < length; i++) {
        this.addIceCandidate(streamId, this.iceCandidateList[streamId][i]);
      }

      this.iceCandidateList[streamId] = [];

      if (isTypeOffer) {
        //SDP constraints may be different in play mode
        console.log("try to create answer for stream id: " + streamId);
        this.remotePeerConnection[streamId].createAnswer(this.sdp_constraints).then(configuration => {
          console.log("created answer for stream id: " + streamId); //support for stereo

          configuration.sdp = configuration.sdp.replace("useinbandfec=1", "useinbandfec=1; stereo=1");
          this.gotDescription(configuration, streamId);
        }).catch(error => {
          console.error("create answer error :" + error);
        });
      }
    }).catch(error => {
      if (this.debug) {
        console.error("set remote description is failed with error: " + error);
      }

      if (error.toString().indexOf("InvalidAccessError") > -1 || error.toString().indexOf("setRemoteDescription") > -1) {
        /**
         * This error generally occurs in codec incompatibility.
         * AMS for a now supports H.264 codec. This error happens when some browsers try to open it from VP8.
         */
        this.callbackError("notSetRemoteDescription");
      }
    });
  }

  takeCandidate(idOfTheStream, tmpLabel, tmpCandidate) {
    var streamId = idOfTheStream;
    var label = tmpLabel;
    var candidateSdp = tmpCandidate;
    var candidate = new RTCIceCandidate({
      sdpMLineIndex: label,
      candidate: candidateSdp
    });
    var dataChannelMode = "peer";
    this.initPeerConnection(streamId, dataChannelMode);

    if (this.remoteDescriptionSet[streamId] == true) {
      this.addIceCandidate(streamId, candidate);
    } else {
      console.debug("Ice candidate is added to list because remote description is not set yet");
      this.iceCandidateList[streamId].push(candidate);
    }
  }

  addIceCandidate(streamId, candidate) {
    var protocolSupported = false;

    if (candidate.candidate == "") {
      //candidate can be received and its value can be "".
      //don't compare the protocols
      protocolSupported = true;
    } else if (typeof candidate.protocol == "undefined") {
      this.candidateTypes.forEach(element => {
        if (candidate.candidate.toLowerCase().includes(element)) {
          protocolSupported = true;
        }
      });
    } else {
      protocolSupported = this.candidateTypes.includes(candidate.protocol.toLowerCase());
    }

    if (protocolSupported) {
      this.remotePeerConnection[streamId].addIceCandidate(candidate).then(response => {
        if (this.debug) {
          console.log("Candidate is added for stream " + streamId);
        }
      }).catch(error => {
        console.error("ice candiate cannot be added for stream id: " + streamId + " error is: " + error);
        console.error(candidate);
      });
    } else {
      if (this.debug) {
        console.log("Candidate's protocol(" + candidate.protocol + ") is not supported." + "Candidate: " + candidate.candidate + " Supported protocols:" + this.candidateTypes);
      }
    }
  }

  startPublishing(idOfStream) {
    var streamId = idOfStream;
    this.initPeerConnection(streamId, "publish");
    this.remotePeerConnection[streamId].createOffer(this.sdp_constraints).then(configuration => {
      this.gotDescription(configuration, streamId);
    }).catch(error => {
      console.error("create offer error for stream id: " + streamId + " error: " + error);
    });
  }

  /**
   * If we have multiple videoÂ tracks in coming versions, this method may cause some issues
   */
  getVideoSender(streamId) {
    var videoSender = null;

    if ((adapter.browserDetails.browser === 'chrome' || adapter.browserDetails.browser === 'firefox' || adapter.browserDetails.browser === 'safari' && adapter.browserDetails.version >= 64) && 'RTCRtpSender' in window && 'setParameters' in window.RTCRtpSender.prototype) {
      if (this.remotePeerConnection[streamId] != null) {
        const senders = this.remotePeerConnection[streamId].getSenders();

        for (let i = 0; i < senders.length; i++) {
          if (senders[i].track != null && senders[i].track.kind == "video") {
            videoSender = senders[i];
            break;
          }
        }
      }
    }

    return videoSender;
  }
  /**
   * bandwidth is in kbps
   */


  changeBandwidth(bandwidth, streamId) {
    var errorDefinition = "";
    var videoSender = this.getVideoSender(streamId);

    if (videoSender != null) {
      const parameters = videoSender.getParameters();

      if (!parameters.encodings) {
        parameters.encodings = [{}];
      }

      if (bandwidth === 'unlimited') {
        delete parameters.encodings[0].maxBitrate;
      } else {
        parameters.encodings[0].maxBitrate = bandwidth * 1000;
      }

      return videoSender.setParameters(parameters);
    } else {
      errorDefinition = "Video sender not found to change bandwidth. Streaming may not be active";
    }

    return Promise.reject(errorDefinition);
  }

  getStats(streamId) {
    console.log("peerstatsgetstats = " + this.remotePeerConnectionStats[streamId]);
    this.remotePeerConnection[streamId].getStats(null).then(stats => {
      var bytesReceived = -1;
      var videoPacketsLost = -1;
      var audioPacketsLost = -1;
      var fractionLost = -1;
      var currentTime = -1;
      var bytesSent = -1;
      var audioLevel = -1;
      var qlr = "";
      var framesEncoded = -1;
      var width = -1;
      var height = -1;
      var fps = -1;
      var frameWidth = -1;
      var frameHeight = -1;
      var videoRoundTripTime = -1;
      var videoJitter = -1;
      var audioRoundTripTime = -1;
      var audioJitter = -1;
      var framesDecoded = -1;
      var framesDropped = -1;
      var framesReceived = -1;
      var audioJitterAverageDelay = -1;
      var videoJitterAverageDelay = -1;
      stats.forEach(value => {
        //console.log(value);
        if (value.type == "inbound-rtp" && typeof value.kind != "undefined") {
          bytesReceived += value.bytesReceived;

          if (value.kind == "audio") {
            audioPacketsLost = value.packetsLost;
          } else if (value.kind == "video") {
            videoPacketsLost = value.packetsLost;
          }

          fractionLost += value.fractionLost;
          currentTime = value.timestamp;
        } else if (value.type == "outbound-rtp") {
          //TODO: SPLIT AUDIO AND VIDEO BITRATES
          bytesSent += value.bytesSent;
          currentTime = value.timestamp;
          qlr = value.qualityLimitationReason;

          if (value.framesEncoded != null) {
            //audio tracks are undefined here
            framesEncoded += value.framesEncoded;
          }
        } else if (value.type == "track" && typeof value.kind != "undefined" && value.kind == "audio") {
          if (typeof value.audioLevel != "undefined") {
            audioLevel = value.audioLevel;
          }

          if (typeof value.jitterBufferDelay != "undefined" && typeof value.jitterBufferEmittedCount != "undefined") {
            audioJitterAverageDelay = value.jitterBufferDelay / value.jitterBufferEmittedCount;
          }
        } else if (value.type == "track" && typeof value.kind != "undefined" && value.kind == "video") {
          if (typeof value.frameWidth != "undefined") {
            frameWidth = value.frameWidth;
          }

          if (typeof value.frameHeight != "undefined") {
            frameHeight = value.frameHeight;
          }

          if (typeof value.framesDecoded != "undefined") {
            framesDecoded = value.framesDecoded;
          }

          if (typeof value.framesDropped != "undefined") {
            framesDropped = value.framesDropped;
          }

          if (typeof value.framesReceived != "undefined") {
            framesReceived = value.framesReceived;
          }

          if (typeof value.jitterBufferDelay != "undefined" && typeof value.jitterBufferEmittedCount != "undefined") {
            videoJitterAverageDelay = value.jitterBufferDelay / value.jitterBufferEmittedCount;
          }
        } else if (value.type == "remote-inbound-rtp" && typeof value.kind != "undefined") {
          if (typeof value.packetsLost != "undefined") {
            if (value.kind == "video") {
              //this is the packetsLost for publishing
              videoPacketsLost = value.packetsLost;
            } else if (value.kind == "audio") {
              //this is the packetsLost for publishing
              audioPacketsLost = value.packetsLost;
            }
          }

          if (typeof value.roundTripTime != "undefined") {
            if (value.kind == "video") {
              videoRoundTripTime = value.roundTripTime;
            } else if (value.kind == "audio") {
              audioRoundTripTime = value.roundTripTime;
            }
          }

          if (typeof value.jitter != "undefined") {
            if (value.kind == "video") {
              videoJitter = value.jitter;
            } else if (value.kind == "audio") {
              audioJitter = value.jitter;
            }
          }
        } else if (value.type == "media-source") {
          if (value.kind == "video") {
            //returns video source dimensions, not necessarily dimensions being encoded by browser
            width = value.width;
            height = value.height;
            fps = value.framesPerSecond;
          }
        }
      });
      this.remotePeerConnectionStats[streamId].totalBytesReceived = bytesReceived;
      this.remotePeerConnectionStats[streamId].videoPacketsLost = videoPacketsLost;
      this.remotePeerConnectionStats[streamId].audioPacketsLost = audioPacketsLost;
      this.remotePeerConnectionStats[streamId].fractionLost = fractionLost;
      this.remotePeerConnectionStats[streamId].currentTime = currentTime;
      this.remotePeerConnectionStats[streamId].totalBytesSent = bytesSent;
      this.remotePeerConnectionStats[streamId].audioLevel = audioLevel;
      this.remotePeerConnectionStats[streamId].qualityLimitationReason = qlr;
      this.remotePeerConnectionStats[streamId].totalFramesEncoded = framesEncoded;
      this.remotePeerConnectionStats[streamId].resWidth = width;
      this.remotePeerConnectionStats[streamId].resHeight = height;
      this.remotePeerConnectionStats[streamId].srcFps = fps;
      this.remotePeerConnectionStats[streamId].frameWidth = frameWidth;
      this.remotePeerConnectionStats[streamId].frameHeight = frameHeight;
      this.remotePeerConnectionStats[streamId].videoRoundTripTime = videoRoundTripTime;
      this.remotePeerConnectionStats[streamId].videoJitter = videoJitter;
      this.remotePeerConnectionStats[streamId].audioRoundTripTime = audioRoundTripTime;
      this.remotePeerConnectionStats[streamId].audioJitter = audioJitter;
      this.remotePeerConnectionStats[streamId].framesDecoded = framesDecoded;
      this.remotePeerConnectionStats[streamId].framesDropped = framesDropped;
      this.remotePeerConnectionStats[streamId].framesReceived = framesReceived;
      this.remotePeerConnectionStats[streamId].videoJitterAverageDelay = videoJitterAverageDelay;
      this.remotePeerConnectionStats[streamId].audioJitterAverageDelay = audioJitterAverageDelay;
      this.callback("updated_stats", this.remotePeerConnectionStats[streamId]);
    });
  }

  disableStats(streamId) {
    if (this.remotePeerConnectionStats[streamId] != null || typeof this.remotePeerConnectionStats[streamId] != 'undefined') {
      clearInterval(this.remotePeerConnectionStats[streamId].timerId);
    }
  }

  enableStats(streamId) {
    if (this.remotePeerConnectionStats[streamId] == null) {
      this.remotePeerConnectionStats[streamId] = new PeerStats(streamId);
      this.remotePeerConnectionStats[streamId].timerId = setInterval(() => {
        this.getStats(streamId);
      }, 5000);
    }
  }
  /**
   * After calling this function, create new WebRTCAdaptor instance, don't use the the same objectone
   * Because all streams are closed on server side as well when websocket connection is closed.
   */


  closeWebSocket() {
    for (var key in this.remotePeerConnection) {
      this.remotePeerConnection[key].close();
    } //free the remote peer connection by initializing again


    this.remotePeerConnection = new Array();
    this.webSocketAdaptor.close();
  }

  checkWebSocketConnection() {
    if (this.webSocketAdaptor == null || this.webSocketAdaptor.isConnected() == false && this.webSocketAdaptor.isConnecting() == false) {
      this.webSocketAdaptor = new WebSocketAdaptor({
        websocket_url: this.websocket_url,
        webrtcadaptor: this,
        callback: this.callback,
        callbackError: this.callbackError,
        debug: this.debug
      });
    }
  }

  peerMessage(streamId, definition, data) {
    var jsCmd = {
      command: "peerMessageCommand",
      streamId: streamId,
      definition: definition,
      data: data
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  forceStreamQuality(streamId, resolution) {
    var jsCmd = {
      command: "forceStreamQuality",
      streamId: streamId,
      streamHeight: resolution
    };
    this.webSocketAdaptor.send(JSON.stringify(jsCmd));
  }

  sendData(streamId, data) {
    var CHUNK_SIZE = 16000;
    var dataChannel = this.remotePeerConnection[streamId].dataChannel;
    var length = data.length || data.size || data.byteLength;
    var sent = 0;

    if (typeof data === 'string' || data instanceof String) {
      dataChannel.send(data);
    } else {
      var token = Math.floor(Math.random() * 999999);
      let header = new Int32Array(2);
      header[0] = token;
      header[1] = length;
      dataChannel.send(header);
      var sent = 0;

      while (sent < length) {
        var size = Math.min(length - sent, CHUNK_SIZE);
        var buffer = new Uint8Array(size + 4);
        var tokenArray = new Int32Array(1);
        tokenArray[0] = token;
        buffer.set(new Uint8Array(tokenArray.buffer, 0, 4), 0);
        var chunk = data.slice(sent, sent + size);
        buffer.set(new Uint8Array(chunk), 4);
        sent += size;
        dataChannel.send(buffer);
      }
    }
  }

}

exports.WebRTCAdaptor = WebRTCAdaptor;
    !(function (t, i) {
  SiriWave = i();
})(this, function () {
  "use strict";
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */ var t =
    function () {
      return (
        (t =
          Object.assign ||
          function (t) {
            for (var i, s = 1, e = arguments.length; s < e; s++)
              for (var n in (i = arguments[s]))
                Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
            return t;
          }),
        t.apply(this, arguments)
      );
    };
  var i = (function () {
      function t(t, i) {
        (this.ATT_FACTOR = 4),
          (this.GRAPH_X = 2),
          (this.AMPLITUDE_FACTOR = 0.6),
          (this.ctrl = t),
          (this.definition = i);
      }
      return (
        (t.prototype.globalAttFn = function (t) {
          return Math.pow(
            this.ATT_FACTOR / (this.ATT_FACTOR + Math.pow(t, this.ATT_FACTOR)),
            this.ATT_FACTOR
          );
        }),
        (t.prototype.xPos = function (t) {
          return this.ctrl.width * ((t + this.GRAPH_X) / (2 * this.GRAPH_X));
        }),
        (t.prototype.yPos = function (t) {
          return (
            this.AMPLITUDE_FACTOR *
            (this.globalAttFn(t) *
              (this.ctrl.heightMax * this.ctrl.amplitude) *
              (1 / this.definition.attenuation) *
              Math.sin(this.ctrl.opt.frequency * t - this.ctrl.phase))
          );
        }),
        (t.prototype.draw = function () {
          var t = this.ctrl.ctx;
          t.moveTo(0, 0), t.beginPath();
          var i = (this.definition.color || this.ctrl.color)
            .replace(/rgb\(/g, "")
            .replace(/\)/g, "");
          (t.strokeStyle = "rgba("
            .concat(i, ",")
            .concat(this.definition.opacity, ")")),
            (t.lineWidth = this.definition.lineWidth);
          for (
            var s = -this.GRAPH_X;
            s <= this.GRAPH_X;
            s += this.ctrl.opt.pixelDepth
          )
            t.lineTo(this.xPos(s), this.ctrl.heightMax + this.yPos(s));
          t.stroke();
        }),
        (t.getDefinition = function () {
          return [
            { attenuation: -2, lineWidth: 1, opacity: 0.1 },
            { attenuation: -6, lineWidth: 1, opacity: 0.2 },
            { attenuation: 4, lineWidth: 1, opacity: 0.4 },
            { attenuation: 2, lineWidth: 1, opacity: 0.6 },
            { attenuation: 1, lineWidth: 1.5, opacity: 1 },
          ];
        }),
        t
      );
    })(),
    s = (function () {
      function t(t, i) {
        (this.GRAPH_X = 25),
          (this.AMPLITUDE_FACTOR = 0.8),
          (this.SPEED_FACTOR = 1),
          (this.DEAD_PX = 2),
          (this.ATT_FACTOR = 4),
          (this.DESPAWN_FACTOR = 0.02),
          (this.NOOFCURVES_RANGES = [2, 5]),
          (this.AMPLITUDE_RANGES = [0.3, 1]),
          (this.OFFSET_RANGES = [-3, 3]),
          (this.WIDTH_RANGES = [1, 3]),
          (this.SPEED_RANGES = [0.5, 1]),
          (this.DESPAWN_TIMEOUT_RANGES = [500, 2e3]),
          (this.ctrl = t),
          (this.definition = i),
          (this.noOfCurves = 0),
          (this.spawnAt = 0),
          (this.prevMaxY = 0),
          (this.phases = []),
          (this.offsets = []),
          (this.speeds = []),
          (this.finalAmplitudes = []),
          (this.widths = []),
          (this.amplitudes = []),
          (this.despawnTimeouts = []),
          (this.verses = []);
      }
      return (
        (t.prototype.getRandomRange = function (t) {
          return t[0] + Math.random() * (t[1] - t[0]);
        }),
        (t.prototype.spawnSingle = function (t) {
          (this.phases[t] = 0),
            (this.amplitudes[t] = 0),
            (this.despawnTimeouts[t] = this.getRandomRange(
              this.DESPAWN_TIMEOUT_RANGES
            )),
            (this.offsets[t] = this.getRandomRange(this.OFFSET_RANGES)),
            (this.speeds[t] = this.getRandomRange(this.SPEED_RANGES)),
            (this.finalAmplitudes[t] = this.getRandomRange(
              this.AMPLITUDE_RANGES
            )),
            (this.widths[t] = this.getRandomRange(this.WIDTH_RANGES)),
            (this.verses[t] = this.getRandomRange([-1, 1]));
        }),
        (t.prototype.getEmptyArray = function (t) {
          return new Array(t);
        }),
        (t.prototype.spawn = function () {
          (this.spawnAt = Date.now()),
            (this.noOfCurves = Math.floor(
              this.getRandomRange(this.NOOFCURVES_RANGES)
            )),
            (this.phases = this.getEmptyArray(this.noOfCurves)),
            (this.offsets = this.getEmptyArray(this.noOfCurves)),
            (this.speeds = this.getEmptyArray(this.noOfCurves)),
            (this.finalAmplitudes = this.getEmptyArray(this.noOfCurves)),
            (this.widths = this.getEmptyArray(this.noOfCurves)),
            (this.amplitudes = this.getEmptyArray(this.noOfCurves)),
            (this.despawnTimeouts = this.getEmptyArray(this.noOfCurves)),
            (this.verses = this.getEmptyArray(this.noOfCurves));
          for (var t = 0; t < this.noOfCurves; t++) this.spawnSingle(t);
        }),
        (t.prototype.globalAttFn = function (t) {
          return Math.pow(
            this.ATT_FACTOR / (this.ATT_FACTOR + Math.pow(t, 2)),
            this.ATT_FACTOR
          );
        }),
        (t.prototype.sin = function (t, i) {
          return Math.sin(t - i);
        }),
        (t.prototype.yRelativePos = function (t) {
          for (var i = 0, s = 0; s < this.noOfCurves; s++) {
            var e = 4 * ((s / (this.noOfCurves - 1)) * 2 - 1);
            e += this.offsets[s];
            var n = t * (1 / this.widths[s]) - e;
            i += Math.abs(
              this.amplitudes[s] *
                this.sin(this.verses[s] * n, this.phases[s]) *
                this.globalAttFn(n)
            );
          }
          return i / this.noOfCurves;
        }),
        (t.prototype.yPos = function (t) {
          return (
            this.AMPLITUDE_FACTOR *
            this.ctrl.heightMax *
            this.ctrl.amplitude *
            this.yRelativePos(t) *
            this.globalAttFn((t / this.GRAPH_X) * 2)
          );
        }),
        (t.prototype.xPos = function (t) {
          return this.ctrl.width * ((t + this.GRAPH_X) / (2 * this.GRAPH_X));
        }),
        (t.prototype.drawSupportLine = function () {
          var t = this.ctrl.ctx,
            i = [0, this.ctrl.heightMax, this.ctrl.width, 1],
            s = t.createLinearGradient.apply(t, i);
          s.addColorStop(0, "transparent"),
            s.addColorStop(0.1, "rgba(255,255,255,.5)"),
            s.addColorStop(0.8, "rgba(255,255,255,.5)"),
            s.addColorStop(1, "transparent"),
            (t.fillStyle = s),
            t.fillRect.apply(t, i);
        }),
        (t.prototype.draw = function () {
          var t = this.ctrl.ctx;
          if (
            ((t.globalAlpha = 0.7),
            (t.globalCompositeOperation = "lighter"),
            0 === this.spawnAt && this.spawn(),
            this.definition.supportLine)
          )
            return this.drawSupportLine();
          for (var i = 0; i < this.noOfCurves; i++)
            this.spawnAt + this.despawnTimeouts[i] <= Date.now()
              ? (this.amplitudes[i] -= this.DESPAWN_FACTOR)
              : (this.amplitudes[i] += this.DESPAWN_FACTOR),
              (this.amplitudes[i] = Math.min(
                Math.max(this.amplitudes[i], 0),
                this.finalAmplitudes[i]
              )),
              (this.phases[i] =
                (this.phases[i] +
                  this.ctrl.speed * this.speeds[i] * this.SPEED_FACTOR) %
                (2 * Math.PI));
          for (var s = -1 / 0, e = 0, n = [1, -1]; e < n.length; e++) {
            var o = n[e];
            t.beginPath();
            for (
              var h = -this.GRAPH_X;
              h <= this.GRAPH_X;
              h += this.ctrl.opt.pixelDepth
            ) {
              var r = this.xPos(h),
                a = this.yPos(h);
              t.lineTo(r, this.ctrl.heightMax - o * a), (s = Math.max(s, a));
            }
            t.closePath(),
              (t.fillStyle = "rgba(".concat(this.definition.color, ", 1)")),
              (t.strokeStyle = "rgba(".concat(this.definition.color, ", 1)")),
              t.fill();
          }
          return (
            s < this.DEAD_PX && this.prevMaxY > s && (this.spawnAt = 0),
            (this.prevMaxY = s),
            null
          );
        }),
        (t.getDefinition = function () {
          return [
            { color: "255,255,255", supportLine: !0 },
            { color: "15, 82, 169" },
            { color: "173, 57, 76" },
            { color: "48, 220, 155" },
          ];
        }),
        t
      );
    })();
  return (function () {
    function e(e) {
      var n = this,
        o = e.container,
        h = (function (t, i) {
          var s = {};
          for (var e in t)
            Object.prototype.hasOwnProperty.call(t, e) &&
              i.indexOf(e) < 0 &&
              (s[e] = t[e]);
          if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
            var n = 0;
            for (e = Object.getOwnPropertySymbols(t); n < e.length; n++)
              i.indexOf(e[n]) < 0 &&
                Object.prototype.propertyIsEnumerable.call(t, e[n]) &&
                (s[e[n]] = t[e[n]]);
          }
          return s;
        })(e, ["container"]);
      (this.phase = 0), (this.run = !1), (this.curves = []);
      var r = window.getComputedStyle(o);
      (this.opt = t(
        {
          container: o,
          style: "ios",
          ratio: window.devicePixelRatio || 1,
          speed: 0.2,
          amplitude: 1,
          frequency: 6,
          color: "#fff",
          cover: !1,
          width: parseInt(r.width.replace("px", ""), 10),
          height: parseInt(r.height.replace("px", ""), 10),
          autostart: !0,
          pixelDepth: 0.02,
          lerpSpeed: 0.1,
        },
        h
      )),
        (this.speed = Number(this.opt.speed)),
        (this.amplitude = Number(this.opt.amplitude)),
        (this.width = Number(this.opt.ratio * this.opt.width)),
        (this.height = Number(this.opt.ratio * this.opt.height)),
        (this.heightMax = Number(this.height / 2) - 6),
        (this.color = "rgb(".concat(this.hex2rgb(this.opt.color), ")")),
        (this.interpolation = { speed: this.speed, amplitude: this.amplitude }),
        (this.canvas = document.createElement("canvas"));
      var a = this.canvas.getContext("2d");
      if (null === a) throw new Error("Unable to create 2D Context");
      if (
        ((this.ctx = a),
        (this.canvas.width = this.width),
        (this.canvas.height = this.height),
        !0 === this.opt.cover
          ? (this.canvas.style.width = this.canvas.style.height = "100%")
          : ((this.canvas.style.width = "".concat(
              this.width / this.opt.ratio,
              "px"
            )),
            (this.canvas.style.height = "".concat(
              this.height / this.opt.ratio,
              "px"
            ))),
        "ios9" === this.opt.style)
      )
        this.curves = (this.opt.curveDefinition || s.getDefinition()).map(
          function (t) {
            return new s(n, t);
          }
        );
      else
        this.curves = (this.opt.curveDefinition || i.getDefinition()).map(
          function (t) {
            return new i(n, t);
          }
        );
      this.opt.container.appendChild(this.canvas),
        this.opt.autostart && this.start();
    }
    return (
      (e.prototype.hex2rgb = function (t) {
        t = t.replace(
          /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
          function (t, i, s, e) {
            return i + i + s + s + e + e;
          }
        );
        var i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
        return i
          ? ""
              .concat(parseInt(i[1], 16).toString(), ",")
              .concat(parseInt(i[2], 16).toString(), ",")
              .concat(parseInt(i[3], 16).toString())
          : null;
      }),
      (e.prototype.intLerp = function (t, i, s) {
        return t * (1 - s) + i * s;
      }),
      (e.prototype.lerp = function (t) {
        var i = this.interpolation[t];
        return (
          null !== i &&
            ((this[t] = this.intLerp(this[t], i, this.opt.lerpSpeed)),
            this[t] - i == 0 && (this.interpolation[t] = null)),
          this[t]
        );
      }),
      (e.prototype.clear = function () {
        (this.ctx.globalCompositeOperation = "destination-out"),
          this.ctx.fillRect(0, 0, this.width, this.height),
          (this.ctx.globalCompositeOperation = "source-over");
      }),
      (e.prototype.draw = function () {
        this.curves.forEach(function (t) {
          return t.draw();
        });
      }),
      (e.prototype.startDrawCycle = function () {
        this.clear(),
          this.lerp("amplitude"),
          this.lerp("speed"),
          this.draw(),
          (this.phase =
            (this.phase + (Math.PI / 2) * this.speed) % (2 * Math.PI)),
          window.requestAnimationFrame
            ? (this.animationFrameId = window.requestAnimationFrame(
                this.startDrawCycle.bind(this)
              ))
            : (this.timeoutId = setTimeout(this.startDrawCycle.bind(this), 20));
      }),
      (e.prototype.start = function () {
        if (!this.canvas)
          throw new Error(
            "This instance of SiriWave has been disposed, please create a new instance"
          );
        (this.phase = 0), this.run || ((this.run = !0), this.startDrawCycle());
      }),
      (e.prototype.stop = function () {
        (this.phase = 0),
          (this.run = !1),
          this.animationFrameId &&
            window.cancelAnimationFrame(this.animationFrameId),
          this.timeoutId && clearTimeout(this.timeoutId);
      }),
      (e.prototype.dispose = function () {
        this.stop(),
          this.canvas && (this.canvas.remove(), (this.canvas = null));
      }),
      (e.prototype.set = function (t, i) {
        this.interpolation[t] = i;
      }),
      (e.prototype.setSpeed = function (t) {
        this.set("speed", t);
      }),
      (e.prototype.setAmplitude = function (t) {
        this.set("amplitude", t);
      }),
      e
    );
  })();
});


    var scripts = document.getElementsByTagName('script');
    var currentScriptSrc = scripts[scripts.length-1].src;
    if (currentScriptSrc.match("cameratag.com") == null){
      console.warn("ERROR: Please load cameratag.js from cameratag.com. See http://cameratag.com/v15/docs/camera_embed");
    }

    var mobileUploadSupported = function () {
       // Handle devices which falsely report support
       if (navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/)) {
         return false;
       }
       // Create test element
       var el = document.createElement("input");
       el.type = "file";
       return !el.disabled;
    };

    // check for mobile browser
    var isMobileDevice = !!(/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''));

    var self = this;
    self.version = "15";

    var appServer = "www.cameratag.com";
    var BUCKET_NAME;
    
    self.cameras = {};
    self.players = {};
    self.video_walls = {};
    self.photobooths = {};
    self.captures = {};
    self.photos = {};
    self.microphones = {};
    self.rooms = {};

    var session_id;
    var token;
    var apiKey;

    var callbacks = {};
    var settingUp = false;
    var webrtc_enabled;

    var selected_cam_id;
    var selected_mic_id;
    
    var allow_play_count = true;
    var initialized = false;

    if (typeof(CT_verbose_mode) == "undefined") {
      CT_verbose_mode = false;
    }

    if (typeof(AudioContext) == "undefined" && typeof(webkitAudioContext) == "undefined") {
      // this must be IE
    } else {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      var audioContext = new AudioContext() || new webkitAudioContext();

    }
    
    // i18n
if (typeof(CT_i18n) == "undefined") {
  CT_i18n = []
}

CT_i18n[0] = CT_i18n[0] || "To record this video using your mobile phone please visit <<url>> in your mobile browser"
CT_i18n[1] = CT_i18n[1] || "Your mobile device does not support video uploading"
CT_i18n[2] = CT_i18n[2] || "Recording in this browser requires Flash player 11 or higher. Would you like to install it now?"
CT_i18n[3] = CT_i18n[3] || "Unable to embed recorder. Please make sure you have Flash Player 11 or higher installed"
CT_i18n[4] = CT_i18n[4] || "choose a method below to submit your video"
CT_i18n[5] = CT_i18n[5] || "record"
CT_i18n[6] = CT_i18n[6] || "upload"
CT_i18n[7] = CT_i18n[7] || "use phone"
CT_i18n[8] = CT_i18n[8] || "wave to the camera"
CT_i18n[9] = CT_i18n[9] || "recording in"
CT_i18n[10] = CT_i18n[10] || "uploading..."
CT_i18n[11] = CT_i18n[11] || "click to stop recording"
CT_i18n[12] = CT_i18n[12] || "click to skip review"
CT_i18n[13] = CT_i18n[13] || "Accept"
CT_i18n[14] = CT_i18n[14] || "Re-Record"
CT_i18n[15] = CT_i18n[15] || "Review Recording"
CT_i18n[16] = CT_i18n[16] || "please wait while we push pixels"
CT_i18n[17] = CT_i18n[17] || "published"
CT_i18n[18] = CT_i18n[18] || "Enter your <b>mobile phone number</b> below and we will text you a link for mobile recording"
CT_i18n[19] = CT_i18n[19] || "Send Mobile Link"
CT_i18n[20] = CT_i18n[20] || "cancel"
CT_i18n[21] = CT_i18n[21] || "Check your phone for mobile recording instructions"
CT_i18n[22] = CT_i18n[22] || "or point your mobile browser to"
CT_i18n[23] = CT_i18n[23] || "drop file to upload"
CT_i18n[24] = CT_i18n[24] || "sending your message"
CT_i18n[25] = CT_i18n[25] || "please enter your phone number!"
CT_i18n[26] = CT_i18n[26] || "that does not appear to be a valid phone number"
CT_i18n[27] = CT_i18n[27] || "Unable to send SMS."
CT_i18n[28] = CT_i18n[28] || "No Camera Detected"
CT_i18n[29] = CT_i18n[29] || "No Microphone Detected"
CT_i18n[30] = CT_i18n[30] || "Hardware Access Denied"
CT_i18n[31] = CT_i18n[31] || "Lost connection to server"
CT_i18n[32] = CT_i18n[32] || "Playback failed"
CT_i18n[33] = CT_i18n[33] || "Unable To Connect"
CT_i18n[34] = CT_i18n[34] || "Unable to publish your recording"
CT_i18n[35] = CT_i18n[35] || "Unable to submit form data"
CT_i18n[36] = CT_i18n[36] || "uploading your video"
CT_i18n[37] = CT_i18n[37] || "buffering video playback"
CT_i18n[38] = CT_i18n[38] || "publishing"
CT_i18n[39] = CT_i18n[39] || "connecting..."
CT_i18n[40] = CT_i18n[40] || "negotiating firewall..."
CT_i18n[41] = CT_i18n[41] || "Oh No! It looks like your browser paused the recorder"
CT_i18n[42] = CT_i18n[42] || "That does not appear to be a valid video file. Proceed anyway?"
CT_i18n[43] = CT_i18n[43] || "Record or Upload a Video"
CT_i18n[44] = CT_i18n[44] || "Tap to get started"
CT_i18n[45] = CT_i18n[45] || "Choose a method to submit your photo"
CT_i18n[46] = CT_i18n[46] || "Camera"
CT_i18n[47] = CT_i18n[47] || "Upload"
CT_i18n[48] = CT_i18n[48] || "Choose which device(s) you would like to use"
CT_i18n[49] = CT_i18n[49] || "Tap here to snap or upload a photo"
CT_i18n[50] = CT_i18n[50] || "Photo Filters"
CT_i18n[51] = CT_i18n[51] || "Pan & Zoom"
CT_i18n[52] = CT_i18n[52] || "Smoke"
CT_i18n[53] = CT_i18n[53] || "Murica"
CT_i18n[54] = CT_i18n[54] || "Brightness / Contrast"
CT_i18n[55] = CT_i18n[55] || "Night Vision"
CT_i18n[56] = CT_i18n[56] || "Posterize"
CT_i18n[57] = CT_i18n[57] || "Zinc"
CT_i18n[58] = CT_i18n[58] || "Berry"
CT_i18n[59] = CT_i18n[59] || "Spy Cam"
CT_i18n[60] = CT_i18n[60] || "Magazine"
CT_i18n[61] = CT_i18n[61] || "Cross Hatch"
CT_i18n[62] = CT_i18n[62] || "Flare"
CT_i18n[63] = CT_i18n[63] || "Hue / Saturation"
CT_i18n[64] = CT_i18n[64] || "Vibrance"
CT_i18n[65] = CT_i18n[65] || "Denoise"
CT_i18n[66] = CT_i18n[66] || "Unsharp Mask"
CT_i18n[67] = CT_i18n[67] || "Noise"
CT_i18n[68] = CT_i18n[68] || "Sepia"
CT_i18n[69] = CT_i18n[69] || "Vignette"
CT_i18n[70] = CT_i18n[70] || "Zoom Blur"
CT_i18n[71] = CT_i18n[71] || "Triangle Blur"
CT_i18n[72] = CT_i18n[72] || "Tilt Shift"
CT_i18n[73] = CT_i18n[73] || "Lens Blur"
CT_i18n[74] = CT_i18n[74] || "Swirl"
CT_i18n[75] = CT_i18n[75] || "Bulge / Pinch"
CT_i18n[76] = CT_i18n[76] || "Ink"
CT_i18n[77] = CT_i18n[77] || "Edge Work"
CT_i18n[78] = CT_i18n[78] || "Hexagonal Pixelate"
CT_i18n[79] = CT_i18n[79] || "Dot Screen"
CT_i18n[80] = CT_i18n[80] || "Color Halftone"
CT_i18n[82] = CT_i18n[82] || "Angle"
CT_i18n[83] = CT_i18n[83] || "Size"
CT_i18n[84] = CT_i18n[84] || "Scale"
CT_i18n[85] = CT_i18n[85] || "Radius"
CT_i18n[86] = CT_i18n[86] || "Strength"
CT_i18n[87] = CT_i18n[87] || "Brightness"
CT_i18n[88] = CT_i18n[88] || "Blur Radius"
CT_i18n[89] = CT_i18n[89] || "Gradient Radius"
CT_i18n[90] = CT_i18n[90] || "Hue"
CT_i18n[91] = CT_i18n[91] || "Saturation"
CT_i18n[92] = CT_i18n[92] || "Motion"
CT_i18n[93] = CT_i18n[93] || "Number of Colors"
CT_i18n[94] = CT_i18n[94] || "Gamma"
CT_i18n[95] = CT_i18n[95] || "Color"
CT_i18n[96] = CT_i18n[96] || "Luminance"
CT_i18n[97] = CT_i18n[97] || "Contrast"
CT_i18n[98] = CT_i18n[98] || "Stopping"
CT_i18n[99] = CT_i18n[99] || "Unable to activate camera or microphone"
CT_i18n[100] = CT_i18n[100] || "Waiting for hardware"
CT_i18n[101] = CT_i18n[101] || "Resume Recording"
CT_i18n[102] = CT_i18n[102] || "Recording Paused"
CT_i18n[103] = CT_i18n[103] || "choose a method below to submit your audio"
CT_i18n[104] = CT_i18n[104] || "microphone"
CT_i18n[105] = CT_i18n[105] || "Which microphone would you would like to use"
CT_i18n[106] = CT_i18n[106] || "this video is longer than the maximum allowed length of ## seconds. Please try again."
CT_i18n[107] = CT_i18n[107] || "That does not appear to be a valid audio file. Proceed anyway?"
CT_i18n[108] = CT_i18n[108] || 'We were unable to parse the file you selected. Please try again.'
CT_i18n[109] = CT_i18n[109] || 'This browser does not support hardware access from insecure origins. Please use https://'
CT_i18n[110] = CT_i18n[110] || 'Your video is still uploading to ther server. Please try again a few seconds.'
CT_i18n[111] = CT_i18n[111] || 'An error has occured.'
CT_i18n[112] = CT_i18n[112] || "please make sure your room tag has an id attribute"
CT_i18n[113] = CT_i18n[113] || "please make sure your room tag has a data-app-id attribute"
CT_i18n[114] = CT_i18n[114] || "Camera or Mic are not found or not allowed in your device."
CT_i18n[115] = CT_i18n[115] || "Camera or Mic is being used by some other process that does not not allow these devices to be read."
CT_i18n[116] = CT_i18n[116] || "There is no device found that fits your video and audio constraints. You may change video and audio constraints."
CT_i18n[117] = CT_i18n[117] || "You are not allowed to access camera and mic."
CT_i18n[118] = CT_i18n[118] || "Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https"
CT_i18n[119] = CT_i18n[119] || "WebSocket not supported in this browser"
CT_i18n[120] = CT_i18n[120] || "Please select your audio and video devices below"
CT_i18n[121] = CT_i18n[121] || "Please enter your info below to start chatting"
CT_i18n[122] = CT_i18n[122] || "Join Room"
CT_i18n[123] = CT_i18n[123] || "Room Name"
CT_i18n[124] = CT_i18n[124] || "User Name"
CT_i18n[125] = CT_i18n[125] || "The Flash recording stack is no longer supported"
CT_i18n[126] = CT_i18n[126] || "This browser does not support video recording. Please make sure you're loading this page securely (using https) and using a recent version of Chrome, Firefox, Safari or Edge."
CT_i18n[127] = CT_i18n[127] || "Apply"
CT_i18n[128] = CT_i18n[128] || "Save"
CT_i18n[129] = CT_i18n[129] || "Retake"
CT_i18n[130] = CT_i18n[130] || "Cancel"
CT_i18n[131] = CT_i18n[131] || "Zoom Level"
CT_i18n[132] = CT_i18n[132] || "Camera or Mic is being used by some other process that does not not allow these devices to be read."
CT_i18n[133] = CT_i18n[133] || "There is no device found that fits your video and audio constraints. You may change video and audio constraints."
CT_i18n[134] = CT_i18n[134] || "You are not allowed to access camera and mic."
CT_i18n[135] = CT_i18n[135] || "Video/Audio is required."
CT_i18n[136] = CT_i18n[136] || "Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https"
CT_i18n[137] = CT_i18n[137] || "Fatal Error: WebSocket not supported in this browser"
CT_i18n[138] = CT_i18n[138] || "There was a error during data channel communication"
CT_i18n[139] = CT_i18n[139] || "You are not allowed to access screen share"
CT_i18n[140] = CT_i18n[140] || "Please enter a room name"
CT_i18n[141] = CT_i18n[141] || "please enter a username"
CT_i18n[142] = CT_i18n[142] || "Camera or Mic are not found or not allowed in your device."


    var init = function() {
      webrtc_enabled = !!window.RTCPeerConnection;
      initialized = true;
      // $(document).one("click", function(){
      //   audioContext && audioContext.resume();
      // })
      self.setup()
    }

    self.setup = function() {
      if (initialized) {
        // create instances for each camera tag in the page
        instantiateCameras();

        // create instances for each video tag in the page
        instantiatePlayers();

        // create instances for each video tag in the page
        instantiateVideoWalls();

        // create instances for each video tag in the page
        instantiatePhotoBooths();

        // create instances for each video tag in the page
        instantiateScreenCaptures();

        // create instances for each video tag in the page
        instantiatePhotos();

        // create instances of audio recorder
        instantiateAudioRecorders();

        // create instances for each room tag in the page
        instantiateRooms();

      } else {
        console.warn("CameraTag not initialized yet. Please wait to call setup()")
      }
    }

    self.scan = self.setup;

    self.init = function(el_id, product_name, opts) {
      var el = $("#"+el_id)[0];
      
      if (!$(el).attr("data-initializing")) {
        switch(product_name) {
          case "camera":
            new CameraTagMediaRecorder(el, false, opts);
            $(el).attr("data-initializing", true);
            break;

          case "microphone":
            new CameraTagMediaRecorder(el, true, opts);
            $(el).attr("data-initializing", true);
            break;

          case "photobooth":
            new CameraTagPhotoCamera(booth_el, opts);
            $(el).attr("data-initializing", true);
            break;

          case "photo":
            new CameraTagPhoto(el, opts);
            $(el).attr("data-initializing", true);
            break;

          case "room":
            new CameraTagRoom(el, opts);
            $(el).attr("data-initializing", true);
            break;

          case "player":
            new CameraTagPlayer(el, opts);
            $(el).attr("data-initializing", true);
            break;

          case "wall":
            new CameraTagVideoWall(el, opts);
            $(el).attr("data-initializing", true);
            break;

          default:
            // do nothing
        }
      }
    }

    self.defaultStack = function(tag) {
      // <camera> and <microphone>
      var stack = "unknown tag";

      if (tag == "camera" || tag == "<camera>" || tag == "<microphone>" || tag == "microphone") {
        if (isMobileDevice) {
          if ((adapter.browserDetails.browser == "safari" && adapter.browserDetails.version >= 14) || (adapter.browserDetails.browser != "safari" && typeof(MediaRecorder) == "function")) {
            stack = "MediaRecorder";
          } else if (webrtc_enabled && !navigator.userAgent.match("CriOS")) {
            stack = "WebRTC";
          } else {
            stack = "Mobile";
          }
          // webrtc enabled browsers 
          // if (webrtc_enabled && !navigator.userAgent.match("CriOS")) {
          //   stack = "WebRTC"
          // } else if (typeof(MediaRecorder) == "function"){
          //   stack = "MediaRecorder"
          // } else {
          //   stack = "Mobile"
          // }
        }

        // desktop browsers 
        else {
          if ((navigator.mediaDevices && typeof(MediaRecorder) == "function" && adapter.browserDetails.browser != "edge") || (navigator.mediaDevices && typeof(MediaRecorder) == "function" && adapter.browserDetails.browser == "edge" && adapter.browserDetails.version >= 79)) {
            stack = "MediaRecorder"
          } else if (webrtc_enabled)  {
            stack = "WebRTC"
          } else {
            stack = "Unsupported"
          }

          // Safari 11
          // if ((navigator.mediaDevices && adapter.browserDetails.browser == "safari" && adapter.browserDetails.version >= 11))  {
          //   stack = "WebRTC"
          // } else if ((navigator.mediaDevices && typeof(MediaRecorder) == "function" && adapter.browserDetails.browser != "edge") || (navigator.mediaDevices && typeof(MediaRecorder) == "function" && adapter.browserDetails.browser == "edge" && adapter.browserDetails.version >= 79)) {
          //   stack = "MediaRecorder"
          // } else {
          //   stack = "Unsupported"
          // }
        }

      // <photobooth>
      } else if (tag == "photobooth" || tag == "<photobooth>") {
        if (navigator.mediaDevices && typeof(navigator.mediaDevices.getUserMedia) == "function") {
          stack = "MediaRecorder"
        } else {
          stack = "Unsupported"
        }
      }

      return stack
    }

    var get_camera = function(camera_uuid, callback) {
      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+camera_uuid+"/new_video.json",
        type:"get",
        success: function(response) {
          if (response.app_uuid != undefined) {
            // build response
            BUCKET_NAME = response.bucket_name;
            session_id = response.session_id;
            token = response.token;
            apiKey = response.api_key;
            
            callback({
              success: true,
              app_uuid: response.app_uuid,
              video_media_factories: response.video_media_factories,
              audio_media_factories: response.audio_media_factories,
              photo_media_factories: response.photo_media_factories,
              videoServer: response.videoServer,
              use_twilio: response.use_twilio
            });
          }
          else {
            callback({ success: false, message: response.message });
          }
        },

        error: function(jqXHR, textStatus, errorThrown) {
          callback({ 
            success: false, 
            message: "error initializing recorder",
            jqXHR: jqXHR,
            textStatus: textStatus,
            errorThrown: errorThrown
          });
        }
      });
    }

    var generateUUID = function(prefix){
        var d = new Date().getTime();
        var uuid = prefix+'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = (d + Math.random()*16)%16 | 0;
            d = Math.floor(d/16);
            return (c=='x' ? r : (r&0x3|0x8)).toString(16);
        });
        return uuid;
    };

    var instantiateCameras = function() {
      $("camera:not([data-initializing])").each(function(index, camera_el) {
        $(camera_el).attr("data-initializing", true);
        new CameraTagMediaRecorder(camera_el, false);
      });
    };

    var instantiatePlayers = function() {
      $("video:not([data-initializing]),player:not([data-initializing])").each(function(index, video_el){
        if ($(video_el).attr("data-assets") || $(video_el).attr("data-uuid") || $(video_el).attr("data-video-id")) {
          $(video_el).attr("data-initializing", true);
          new CameraTagPlayer(video_el);
        }
      });
    };

    var instantiateVideoWalls = function() {
      $("videowall:not([data-initializing]),wall:not([data-initializing])").each(function(index, wall_el){
        $(wall_el).attr("data-initializing", true);
        new CameraTagVideoWall(wall_el);
      });

      $("wall:not([data-initializing])").each(function(index, wall_el){
        $(wall_el).attr("data-initializing", true);
        new CameraTagVideoWall(wall_el);
      });
    };

    var instantiatePhotoBooths = function() {
      $("photobooth:not([data-initializing])").each(function(index, booth_el){
        $(booth_el).attr("data-initializing", true);
        new CameraTagPhotoCamera(booth_el);
      });
    };

    var instantiateScreenCaptures = function() {
      $("capture:not([data-initializing])").each(function(index, capture_el){
        $(capture_el).attr("data-initializing", true);
        new CameraTagScreenCapture(capture_el);
      });
    };

    var instantiatePhotos = function() {
      $("photo:not([data-initializing])").each(function(index, photo_el){
        $(photo_el).attr("data-initializing", true);
        new CameraTagPhoto(photo_el);
      });
    };

    var instantiateAudioRecorders = function() {
      $("microphone:not([data-initializing])").each(function(index, audio_el){
        $(audio_el).attr("data-initializing", true);
        new CameraTagMediaRecorder(audio_el, true);
      });
    };

    var instantiateRooms = function() {
      $("room:not([data-initializing])").each(function(index, room_el){
        $(room_el).attr("data-initializing", true);
        new CameraTagRoom(room_el);
      });
    };

    // EVENT OBSERVATION
    self.observe = function(camera_dom_id,event_name,callback,priority) {
      priority = priority || false;
      if ( !callbacks[camera_dom_id] )
        callbacks[camera_dom_id] = {};
      if ( !callbacks[camera_dom_id][event_name] )
        callbacks[camera_dom_id][event_name] = [];

      if (priority) {
        callbacks[camera_dom_id][event_name].splice(0,0,callback);
      }
      else {
        callbacks[camera_dom_id][event_name].push(callback);  
      }
    };

    self.fire = function(camera_dom_id,event_name,data) {
      if ( !callbacks[camera_dom_id] )
        callbacks[camera_dom_id] = {};
      if ( !callbacks[camera_dom_id][event_name] )
        callbacks[camera_dom_id][event_name] = [];
    
      fire_handlers(camera_dom_id,event_name,data);
    };

    self.find_ct_object_from_dom_id = function(dom_id) {
      found_object = null;
      $.each(self.cameras, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.players, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.video_walls, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.photobooths, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.captures, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.photos, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.microphones, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })
      $.each(self.rooms, function(key, object){
        if (key == dom_id) {
          found_object = object;
        }
      })

      return found_object;
    }

    var fire_handlers = function(camera_dom_id,event_name,data) {
      if (typeof(callbacks[camera_dom_id][event_name]) == "object") {
        for( i = 0; i < callbacks[camera_dom_id][event_name].length; i++ ) {
          try {
            callbacks[camera_dom_id][event_name][i].apply(self.find_ct_object_from_dom_id(camera_dom_id), [data]);
          }
          catch(err) {}
        }
      }
    }

    self.stopObserving = function(camera_dom_id,event_name,callback) {
      if ( !callbacks[camera_dom_id] )
        callbacks[camera_dom_id] = {};
      if ( !callbacks[camera_dom_id][event_name] )
        callbacks[camera_dom_id][event_name] = [];
      

      for( i = 0; i < callbacks[camera_dom_id][event_name].length; i++ ) {
        if( callbacks[camera_dom_id][event_name][i] == callback )
          callbacks[camera_dom_id][event_name].splice(i,1);
      }
    };

    var formatted_seconds = function(s) {
      var minutes = Math.floor(s / 60);
      var seconds  = s - (minutes * 60);
      if (minutes > 0) {
        if (seconds < 10) {
          return minutes + ":0" + seconds;
        } else {
          return minutes + ":" + seconds;
        }  
      } else {
        return seconds
      }      
    }

    var publish_asset = function(options) {
      //camera_uuid, asset_uuid, type, videoServer, signature, signature_expiration, video_data_object, video_name, video_description, asset_type
      prompt_response_times = options["prompt_response_times"] ? JSON.stringify(options["prompt_response_times"]) : null;
      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+options["camera_uuid"]+"/assets/"+options["asset_uuid"]+"/publish.json",
        type:"post",
        data: {
          original_filename: options["original_filename"],
          original_url: options["original_url"],
          asset_type: options["asset_type"],
          publish_type: options["type"], 
          archive_id: options["archive_id"],
          server: options["videoServer"],
          referer: window.location.toString(),
          version: self.version,
          signature: options["signature"],
          signature_expiration: options["signature_expiration"],
          metadata: JSON.stringify(options["metadata"]),
          asset_name: options["asset_name"],
          asset_description: options["asset_description"],
          bucket_name: BUCKET_NAME,
          prompt_response_times: prompt_response_times
        },
        success: function(response) {
          if (response["uuid"]) {
            self.fire(options["asset_uuid"], "published", response);
          }
          else {
            self.fire(options["asset_uuid"], "publishFailed", {success: false, asset_uuid: options["asset_uuid"], message: response.error});
          }
        },
        error: function() {
          self.fire(options["asset_uuid"], "publishFailed", {success: false, asset_uuid: options["asset_uuid"], message: "unkown error"});
        }
      })
    };

    self.prototype = self; // legacy support



    // Included Products
    var CameraTagMediaRecorder = function(camera_el, audio_only, opts) {
  opts = opts || {};


  var app_uuid;
  var media_factories = {};
  var asset = {};
  var uploader;
  var defaultSmsMessage;
  var input_name;
  var countdown_timer;
  var countdown_overlay;
  var record_start_time; 
  var record_timer;
  var paused_timer;
  var record_timer_count = 0;
  var record_timer_prompt = 0;
  var processed_timer;
  var published_timer;
  var audioLevel = 0;
  var audio_meter_on = false;
  var audio_viz;


  // overwritable params
  var sources;
  var videoServer; // gets set by server in auth callback
  var height;
  var width;
  var aspect_ratio;
  var hResolution;
  var vResolution;
  var maxLength;
  var minLength;
  var skipPreview;
  var skipFontAwesome;
  var audioBitRate;
  var sampleRate;
  var sampleSize;
  var preRollLength;
  var publishOnUpload;
  var flipRecordPreview;
  var font_size;
  var smsCountries;
  var defaultSmsCountry;
  var enforceMobileLength;
  var inline_styles;
  var selected_cam_id = getCookie("CameraTagSelectedCameraId");
  var selected_mic_id = getCookie("CameraTagSelectedMicId");;
  var constraints = {
    audio: {},
    video: {}
  };
  var prompt_response_times = [];


  // DOM references
  var container;
  var recorder;
  var audioCanvas;
  var canvasContext;
  var start_screen;
  var settings_screen;
  var settings_btn
  var mobile_start_screen;
  var throttled_screen;
  var paused_screen;
  var playback_screen;
  var recording_screen;
  var camera_detection_screen;
  var countdown_screen;
  var upload_screen;
  var upload_status;
  var accept_screen;
  var wait_screen;
  var wait_message;
  var completed_screen;
  var error_screen;
  var error_message;
  var sms_screen;
  var sms_input;
  var thumb_bg;
  var check_phone_screen;
  var alternative_prompt;
  var camera_options;
  var mic_options;
  var device_selection_screen;



  // main data objects
  var cachebuster = parseInt( Math.random() * 100000000 );
  var self = this;
  var this_recorder = this;
  
  //
  // GENERATED FROM SCHEMA
  //
    var appUuid = opts["appUuid"] || $(camera_el).attr("data-appUuid") || $(camera_el).attr("data-uuid") || "";




    var id = opts["id"] || $(camera_el).attr("data-id") || $(camera_el).attr("id") || "myCamera";




    var name = opts["name"] || $(camera_el).attr("data-name") || $(camera_el).attr("data-name") || "";




    var description = opts["description"] || $(camera_el).attr("data-description") || $(camera_el).attr("data-description") || "";




    var metadata = opts["metadata"] || $(camera_el).attr("data-metadata") || $(camera_el).attr("data-metadata") || null;



      // make sure metadata is an object
      if (typeof(metadata) == "string") {
        try {
          metadata = JSON.parse(metadata);
        } catch {
          console.log("metadata could not be parsed as an Object");
          metadata = {};
        }
      }

    var sources = opts["sources"] || $(camera_el).attr("data-sources") || $(camera_el).attr("data-sources") || ["record", "upload", "sms"];

      // make sure sources is an array
      if (typeof(sources) == "string") {
        try {
          sources = JSON.parse(sources);
        } catch {
          console.log("sources could not be parsed as an Array")
          sources = [];
        }
      }



    var facingMode = opts["facingMode"] || $(camera_el).attr("data-facingMode") || $(camera_el).attr("data-facing-mode") || null;




    var preroll = opts["preroll"] || $(camera_el).attr("data-preroll") || $(camera_el).attr("data-pre-roll-length") || 3;




      // make sure preroll is an object
      if (typeof(preroll) == "string") {
        try {
          preroll = parseInt(preroll);
        } catch {
          console.log("preroll could not be parsed as an Integer");
          preroll = null;
        }
      }
    var maxLength = opts["maxLength"] || $(camera_el).attr("data-maxLength") || $(camera_el).attr("data-maxlength") || 30;




      // make sure maxLength is an object
      if (typeof(maxLength) == "string") {
        try {
          maxLength = parseInt(maxLength);
        } catch {
          console.log("maxLength could not be parsed as an Integer");
          maxLength = null;
        }
      }
    var minLength = opts["minLength"] || $(camera_el).attr("data-minLength") || $(camera_el).attr("data-minlength") || 3;




      // make sure minLength is an object
      if (typeof(minLength) == "string") {
        try {
          minLength = parseInt(minLength);
        } catch {
          console.log("minLength could not be parsed as an Integer");
          minLength = null;
        }
      }
    var pollForProcessed = opts["pollForProcessed"] || $(camera_el).attr("data-pollForProcessed") || $(camera_el).attr("data-poll-for-processed") || true;


      // make sure pollForProcessed is a boolean
      if (typeof(pollForProcessed) == "string") {
        pollForProcessed = (pollForProcessed == "false" ? false : true);
      }


    var prompts = opts["prompts"] || $(camera_el).attr("data-prompts") || $(camera_el).attr("data-prompts") || [];

      // make sure prompts is an array
      if (typeof(prompts) == "string") {
        try {
          prompts = JSON.parse(prompts);
        } catch {
          console.log("prompts could not be parsed as an Array")
          prompts = [];
        }
      }



    var defaultSmsCountry = opts["defaultSmsCountry"] || $(camera_el).attr("data-defaultSmsCountry") || $(camera_el).attr("data-default-sms-country") || "us";




    var smsCountries = opts["smsCountries"] || $(camera_el).attr("data-smsCountries") || $(camera_el).attr("data-sms-countries") || ["af", "al", "dz", "as", "ad", "ao", "ai", "ag", "ar", "am", "aw", "au", "at", "az", "bs", "bh", "bd", "bb", "by", "be", "bz", "bj", "bm", "bt", "bo", "ba", "bw", "br", "io", "vg", "bn", "bg", "bf", "bi", "kh", "cm", "ca", "cv", "bq", "ky", "cf", "td", "cl", "cn", "co", "km", "cd", "cg", "ck", "cr", "ci", "hr", "cu", "cw", "cy", "cz", "dk", "dj", "dm", "do", "ec", "eg", "sv", "gq", "er", "ee", "et", "fk", "fo", "fj", "fi", "fr", "gf", "pf", "ga", "gm", "ge", "de", "gh", "gi", "gr", "gl", "gd", "gp", "gu", "gt", "gn", "gw", "gy", "ht", "hn", "hk", "hu", "is", "in", "id", "ir", "iq", "ie", "il", "it", "jm", "jp", "jo", "kz", "ke", "ki", "kw", "kg", "la", "lv", "lb", "ls", "lr", "ly", "li", "lt", "lu", "mo", "mk", "mg", "mw", "my", "mv", "ml", "mt", "mh", "mq", "mr", "mu", "mx", "fm", "md", "mc", "mn", "me", "ms", "ma", "mz", "mm", "na", "nr", "np", "nl", "nc", "nz", "ni", "ne", "ng", "nu", "nf", "kp", "mp", "no", "om", "pk", "pw", "ps", "pa", "pg", "py", "pe", "ph", "pl", "pt", "pr", "qa", "re", "ro", "ru", "rw", "bl", "sh", "kn", "lc", "mf", "pm", "vc", "ws", "sm", "st", "sa", "sn", "rs", "sc", "sl", "sg", "sx", "sk", "si", "sb", "so", "za", "kr", "ss", "es", "lk", "sd", "sr", "sz", "se", "ch", "sy", "tw", "tj", "tz", "th", "tl", "tg", "tk", "to", "tt", "tn", "tr", "tm", "tc", "tv", "vi", "ug", "ua", "ae", "gb", "us", "uy", "uz", "vu", "va", "ve", "vn", "wf", "ye", "zm", "zw"];

      // make sure smsCountries is an array
      if (typeof(smsCountries) == "string") {
        try {
          smsCountries = JSON.parse(smsCountries);
        } catch {
          console.log("smsCountries could not be parsed as an Array")
          smsCountries = [];
        }
      }



    var defaultSmsMessage = opts["defaultSmsMessage"] || $(camera_el).attr("data-defaultSmsMessage") || $(camera_el).attr("data-txt-message") || "To record this video using your mobile phone please visit <<url>> in your mobile browser";




    var defaultStack = opts["defaultStack"] || $(camera_el).attr("data-defaultStack") || $(camera_el).attr("data-stack") || "auto";




    var permittedExtensions = opts["permittedExtensions"] || $(camera_el).attr("data-permittedExtensions") || $(camera_el).attr("data-sms-countries") || ["mov", "mp4", "webm", "flv", "mv4", "mov", "avi", "wmv", "mpeg", "mpg", "m4v", "wav", "mp3", "aif", "aiff", "aifc"];




    var existingUuid = opts["existingUuid"] || $(camera_el).attr("data-existingUuid") || $(camera_el).attr("data-asset-uuid") || null;




    var flipRecordPreview = opts["flipRecordPreview"] || $(camera_el).attr("data-flipRecordPreview") || $(camera_el).attr("data-mirror-recording") || true;


      // make sure flipRecordPreview is a boolean
      if (typeof(flipRecordPreview) == "string") {
        flipRecordPreview = (flipRecordPreview == "false" ? false : true);
      }


    var screenShare = opts["screenShare"] || $(camera_el).attr("data-screenShare") || $(camera_el).attr("data-share-screen") || false;


      // make sure screenShare is a boolean
      if (typeof(screenShare) == "string") {
        screenShare = (screenShare == "false" ? false : true);
      }


    var disableAudioProcessing = opts["disableAudioProcessing"] || $(camera_el).attr("data-disableAudioProcessing") || $(camera_el).attr("data-disable-audio-processing") || false;


      // make sure disableAudioProcessing is a boolean
      if (typeof(disableAudioProcessing) == "string") {
        disableAudioProcessing = (disableAudioProcessing == "false" ? false : true);
      }


    var showVisualization = opts["showVisualization"] || $(camera_el).attr("data-showVisualization") || $(camera_el).attr("data-show-visualization") || true;


      // make sure showVisualization is a boolean
      if (typeof(showVisualization) == "string") {
        showVisualization = (showVisualization == "false" ? false : true);
      }


    var enforceMobileLength = opts["enforceMobileLength"] || $(camera_el).attr("data-enforceMobileLength") || $(camera_el).attr("data-enforce-mobile-length") || true;


      // make sure enforceMobileLength is a boolean
      if (typeof(enforceMobileLength) == "string") {
        enforceMobileLength = (enforceMobileLength == "false" ? false : true);
      }


    var playerOnProcess = opts["playerOnProcess"] || $(camera_el).attr("data-playerOnProcess") || $(camera_el).attr("data-player-on-processed") || false;


      // make sure playerOnProcess is a boolean
      if (typeof(playerOnProcess) == "string") {
        playerOnProcess = (playerOnProcess == "false" ? false : true);
      }


    var pollServer = opts["pollServer"] || $(camera_el).attr("data-pollServer") || $(camera_el).attr("data-poll-for-processed") || false;


      // make sure pollServer is a boolean
      if (typeof(pollServer) == "string") {
        pollServer = (pollServer == "false" ? false : true);
      }


    var skipPreview = opts["skipPreview"] || $(camera_el).attr("data-skipPreview") || $(camera_el).attr("data-poll-for-processed") || false;


      // make sure skipPreview is a boolean
      if (typeof(skipPreview) == "string") {
        skipPreview = (skipPreview == "false" ? false : true);
      }


    var skipFontAwesome = opts["skipFontAwesome"] || $(camera_el).attr("data-skipFontAwesome") || $(camera_el).attr("data-skip-font-awesome") || false;


      // make sure skipFontAwesome is a boolean
      if (typeof(skipFontAwesome) == "string") {
        skipFontAwesome = (skipFontAwesome == "false" ? false : true);
      }


    var skipHairCheck = opts["skipHairCheck"] || $(camera_el).attr("data-skipHairCheck") || $(camera_el).attr("data-skip-hair-check") || false;


      // make sure skipHairCheck is a boolean
      if (typeof(skipHairCheck) == "string") {
        skipHairCheck = (skipHairCheck == "false" ? false : true);
      }


    var videoBitRate = opts["videoBitRate"] || $(camera_el).attr("data-videoBitRate") || $(camera_el).attr("data-videobitrate") || 1200000;




      // make sure videoBitRate is an object
      if (typeof(videoBitRate) == "string") {
        try {
          videoBitRate = parseInt(videoBitRate);
        } catch {
          console.log("videoBitRate could not be parsed as an Integer");
          videoBitRate = null;
        }
      }
    var audioBitRate = opts["audioBitRate"] || $(camera_el).attr("data-audioBitRate") || $(camera_el).attr("data-videobitrate") || 128000;




      // make sure audioBitRate is an object
      if (typeof(audioBitRate) == "string") {
        try {
          audioBitRate = parseInt(audioBitRate);
        } catch {
          console.log("audioBitRate could not be parsed as an Integer");
          audioBitRate = null;
        }
      }
    var disconnectOnStop = opts["disconnectOnStop"] || $(camera_el).attr("data-disconnectOnStop") || $(camera_el).attr("data-disconnect-on-stop") || true;


      // make sure disconnectOnStop is a boolean
      if (typeof(disconnectOnStop) == "string") {
        disconnectOnStop = (disconnectOnStop == "false" ? false : true);
      }


    var signature = opts["signature"] || $(camera_el).attr("data-signature") || $(camera_el).attr("data-signature") || "";




    var signatureExpiration = opts["signatureExpiration"] || $(camera_el).attr("data-signatureExpiration") || $(camera_el).attr("data-signature-expiration") || "";




    var publishOnUpload = opts["publishOnUpload"] || $(camera_el).attr("data-publishOnUpload") || $(camera_el).attr("data-publish-on-upload") || true;


      // make sure publishOnUpload is a boolean
      if (typeof(publishOnUpload) == "string") {
        publishOnUpload = (publishOnUpload == "false" ? false : true);
      }



  // metadata is handeled specially
  if (metadata == "string") {
    try {
      metadata = JSON.parse(metadata);
    } catch {
      console.log("metadata could not be parsed as an Object")
      metadata = {};
    }
  }
  metadata_object = metadata;

  //
  // END FORM SCHEMA VARS
  //

  // backwards compatability
  var camera_uuid = appUuid || $(camera_el).attr("data-appId") || $(camera_el).attr("data-uuid") || $(camera_el).attr("data-app-id") || $(camera_el).attr("id");
  var asset_name = name
  var asset_description = description
  var dom_id = id || $(camera_el).attr("id") || cachebuster;
  var manual_stack = defaultStack;
  var signature_expiration = signatureExpiration;
  var preRollLength = preroll;
  // var asset_name = $(camera_el).attr("data-name");
  // var asset_description = $(camera_el).attr("data-description");
  // var metadata = $(camera_el).attr("data-metadata") || $(camera_el).attr("data-video-data");
  // var permittedExtensions = ["mov", "mp4", "webm", "flv", "mv4", "mov", "avi", "wmv", "mpeg", "mpg", "m4v", "wav", "mp3", "aif", "aiff", "aifc"];
  // var playerOnProcess = $(camera_el).attr("data-player-on-processed") == "true";
  // var disableAudioProcessing = $(camera_el).attr("data-disable-audio-processing") == "true";
  // var manual_stack = $(camera_el).attr("data-stack");
  // var facingMode = $(camera_el).attr("data-facing-mode");
  // var screenShare = $(camera_el).attr("data-share-screen") == "true";
  // var prompts = $(camera_el).attr("data-prompts");
  
  // var existingUuid = $(camera_el).attr("data-asset-uuid") || $(camera_el).attr("data-video-uuid");
  // sources = $(camera_el).attr("data-sources") || '["record","upload","sms"]';
  // sources = JSON.parse(sources);
  // maxLength = $(camera_el).attr("data-maxlength") || $(camera_el).attr("data-max-length") || 30;
  // minLength = $(camera_el).attr("data-minlength") || $(camera_el).attr("data-min-length") || 3;
  // audioBitRate = $(camera_el).attr("data-audiobitrate") || 128000;
  // defaultSmsMessage = $(camera_el).attr("data-txt-message") || CT_i18n[0];
  // skipPreview = false;
  // pollServer = $(camera_el).attr("data-poll-for-processed") != "false";
  // publishOnUpload = $(camera_el).attr("data-publish-on-upload") != "false";
  // skipFontAwesome = $(camera_el).attr("data-skip-font-awesome") == "true";
  // skipHairCheck = $(camera_el).attr("data-skip-hair-check") == "true";
  // flipRecordPreview = $(camera_el).attr("data-mirror-recording") != "false";
  // defaultSmsCountry = $(camera_el).attr("data-default-sms-country");
  // smsCountries = $(camera_el).attr("data-sms-countries");
  // enforceMobileLength = $(camera_el).attr("data-enforce-mobile-length") != "false";
  // showVisualization = $(camera_el).attr("data-show-visualization") != "false";
  // camera_uuid = opts["appUuid"] == null ? camera_uuid : opts["appUuid"];
  // signature = opts["signature"] == null ? signature : opts["signature"];
  // signature_expiration = opts["signatureExpiration"] == null ? signature_expiration : opts["signatureExpiration"];
  // asset_name = opts["assetName"] == null ? asset_name : opts["assetName"];
  // asset_description = opts["assetDescription"] == null ? asset_description : opts["assetDescription"];
  // metadata = opts["metadata"] == null ? metadata : opts["metadata"];
  // permittedExtensions = opts["permittedExtensions"] == null ? permittedExtensions : opts["permittedExtensions"];
  // playerOnProcess = opts["playerOnProcess"] == null ? playerOnProcess : opts["playerOnProcess"];
  // disableAudioProcessing = opts["disableAudioProcessing"] == null ? disableAudioProcessing : opts["disableAudioProcessing"];
  // manual_stack = opts["manual_stack"] == null ? manual_stack : opts["manual_stack"];
  // facingMode = opts["facingMode"] == null ? facingMode : opts["facingMode"];
  // screenShare = opts["screenShare"] == null ? screenShare : opts["screenShare"];
  // prompts = opts["promptJson"] == null ? prompts : opts["promptJson"];
  // existingUuid = opts["existingUuid"] == null ? existingUuid : opts["existingUuid"];
  // sources = opts["sources"] == null ? sources : opts["sources"];
  // maxLength = opts["maxLength"] == null ? maxLength : opts["maxLength"];
  // minLength = opts["minLength"] == null ? minLength : opts["minLength"];
  // defaultSmsMessage = opts["txtMessage"] == null ? defaultSmsMessage : opts["txtMessage"];
  // flipRecordPreview = opts["flipRecordPreview"] == null ? flipRecordPreview : opts["flipRecordPreview"];
  // defaultSmsCountry = opts["defaultSmsCountry"] == null ? defaultSmsCountry : opts["defaultSmsCountry"];
  // smsCountries = opts["smsCountries"] == null ? smsCountries : opts["smsCountries"];
  // enforceMobileLength = opts["enforceMobileLength"] == null ? enforceMobileLength : opts["enforceMobileLength"];
  // showVisualization = opts["showVisualization"] == null ? showVisualization : opts["showVisualization"];
  // skipPreview = opts["skipPreview"] == null ? skipPreview : opts["skipPreview"];
  // pollServer = opts["pollServer"] == null ? pollServer : opts["pollServer"];
  // skipFontAwesome = opts["skipFontAwesome"] == null ? skipFontAwesome : opts["skipFontAwesome"];

  // IN PURGATORY
  // publishOnUpload = opts["publishOnUpload"] == null ? publishOnUpload : opts["publishOnUpload"];
  // sampleSize = $(camera_el).attr("data-sample-size");
  // sampleRate = $(camera_el).attr("data-sample-rate");
  // audioBitRate = opts["audioBitRate"] == null ? audioBitRate : opts["audioBitRate"];

  var video_mimes = "video/*,video/mp4,video/m4v,video/x-flv,video/flv,video/wmv,video/mpg,video/quicktime,video/webm,video/x-ms-wmv,video/ogg,video/avi,video/mov,video/x-m4v"
  var audio_mimes = "audio/*"

  var metadata_object;
  var upload_pending_publish;
  var use_twilio;
  var prompts; 

  if (Array.isArray(prompts)) {
    $(prompts).each(function(index, prompt){
      prompts[index]["maxLength"] ||= 30;
      prompts[index]["minLength"] ||= 0;
    })
  } else {
    prompts = [];
  }
  current_prompt_index = 0;

  // Control functions
  self.connect = function(){};
  self.play = function(){};
  self.record = function(){};
  self.stopRecording = function(){};
  self.stopPlayback = function(){};
  self.showFlashSettings = function(){};
  self.getFrame = function(){};
  var connect_callback = function(){};
  
  // state management 
  var state;
  var current_screen;
  var paused = false;
  var throttled = false;
  var connected = false;
  var readyToRecord = false;
  var countdown_counter = 0;
  var uploading = false;
  var error_messages = [];
  var readyToPublish = false;
  var initialized = false;
  // var publishType;
  var file_to_upload;



  //
  // RECORDING STACKS
  //

  // Mobile Recorder
  var MobileRecorder = function() {
  var self = this;
  var file;
  cams = [];
  mics = [];
  var URL = window.URL || window.webkitURL;
  var videoPreview = $('<video id="'+dom_id+'-video-preview" webkit-playsinline style="width:100%; height:100%; object-fit: contain; visibility:visible; display:block;"></video>');
  container.prepend(videoPreview);
  videoPreview.hide();
  var videoPreview = videoPreview[0];
  var upload_input;

  var setup = function() {
    connected = true;
    var browse_element = mobile_start_screen;
    var upload_source_index = sources.indexOf("upload");
    if (upload_source_index == -1) {
      upload_input = $('<input id="'+dom_id+'_upload_file" style="position:absolute;" type="file" accept="video/*" capture="camcorder">');
    } else {
      upload_input = $('<input id="'+dom_id+'_upload_file" style="position:absolute;" type="file" accept="video/*">');
    }
    $(mobile_start_screen).append(upload_input);
    $(upload_input).css({
      left: 0,
      top: 0,
      width: 1,
      height: 1,
      opacity: 0
    })
    container.find(".cameratag_record").click(function(e){
      if (e.target != upload_input[0]) {
        e.stopPropagation();
        $(upload_input).click();
      }
    })
    
    $(upload_input).change(function(evt){
      file = upload_input[0].files[0];
      CameraTag.fire(dom_id, "recordingStopped");
      CameraTag.fire(dom_id, "readyToPublish");        
    });

    videoPreview.addEventListener('loadedmetadata', validateLength);
    CameraTag.fire(dom_id, "initialized");
  }

  var validateLength = function() {
    if (enforceMobileLength && videoPreview.duration > maxLength) {
      alert(CT_i18n[106].replace("##", maxLength));
      videoPreview.src = null;
      this_recorder.loadInterface(mobile_start_screen);
    }
  }

  self.stack = "Mobile";

  self.setUUID = function(new_uuid) {
    // this stub is needed to comply with the expected recorder API
  };

  self.listCameras = function() {
    return cams;
  }

  self.listMicrophones = function() {
    return mics;
  }

  self.setCamera = function(id) {
    // not used in mobile
  }

  self.setMicrophone = function(id) {
    // not used in mobile
  }

  self.showNothing = function() {
    videoPreview.src = null;
  };

  self.showRecorder = function() {
    // not used in mobile
  };

  self.showPlayer = function() {
    $(videoPreview).show();
    videoPreview.src = URL.createObjectURL(file);
    videoPreview.load();
  };

  self.stopPlayback = function() {
    $(videoPreview).hide();
    videoPreview.muted = true;
    videoPreview.pause();
    CameraTag.fire(dom_id, "playbackStopped");
  };

  self.startPlayback = function() {
    $(videoPreview).show();
    videoPreview.src = URL.createObjectURL(file);
    videoPreview.muted = false;
    videoPreview.play();
    CameraTag.fire(dom_id, "playbackStarted");
  
    $(videoPreview).bind("ended", function() {
       CameraTag.fire(dom_id, "playbackStopped");
    });
  };

  self.pausePlayback = function() {
    videoPreview.pause();
    CameraTag.fire(dom_id, "playbackPaused");
  };

  self.seekPlayback = function(new_position) {
    videoPreview.currentTime = new_position;
    CameraTag.fire(dom_id, "playbackSeeked"); 
  };

  self.publish = function() {
    CameraTag.fire(dom_id, "uploadStarted");

    uploader.add({
      file: file,
      name: 'recordings/' + asset.uuid + '.flv',
      complete: function(){
        start_screen.css("left", "0px");
        start_screen.css("right", "0px");

        wait(CT_i18n[38]);

        publish_asset({
          original_filename: file.name, 
          original_url: "https://cameratag-upload.s3.amazonaws.com/recordings/"+asset.uuid+".flv",
          camera_uuid: app_uuid, 
          asset_uuid: asset.uuid, 
          asset_type: "Video",
          type: "mobile", 
          videoServer: videoServer, 
          signature: signature, 
          signature_expiration: signature_expiration, 
          metadata: metadata_object, 
          asset_name: asset_name, 
          asset_description: asset_description,
          prompt_response_times: prompt_response_times
        });
      },
      progress: function(progress){
        progress = progress;
        CameraTag.fire(dom_id, "UploadProgress", progress);
        CameraTag.fire(dom_id, "uploadProgress", progress);
        upload_status.html((progress * 100).toFixed(1) + "%");
        setUploadPercentage(progress);
      },
      error: function(error) {
        throw_error("There was an error uploading your file");
        CameraTag.fire(dom_id, "uploadAborted", {
          error: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
        return;
      }
    })
  }

  self.connect = function() {
  };

  self.disconnect = function() {
    CameraTag.fire(dom_id, "serverDisconnected");
  };

  self.startRecording = function() {
    $(upload_input).click();
  };

  self.stopRecording = function() {
  };

  setup();
}

  // CTMediaRecorder
  var CTMediaRecorder = function() {
  var self = this;
  
  var mediaRecorder;
  var playPreview, recordPreview;

  $("#"+dom_id+"_player_placeholder").html('<video id="'+dom_id+'_player_preview" width="100%" height="100%" playsinline="true" loop="true"></video>');
  playPreview = $("#"+dom_id+"_player_placeholder").find("video")[0];
  playPreview.addEventListener('error', function(event) { 
    alert(CT_i18n[110]);
    CameraTag.fire(dom_id, "playbackStopped");
  }, true);

  $(playPreview).bind("ended", function() {
    if (playPreview.src != "https://static.cameratag.com/blank.mp4") {
      CameraTag.fire(dom_id, "playbackStopped");  
    }
  });

  $(container).one("click", function(){
    console.log("Cliked!");
    playPreview.src = "https://static.cameratag.com/blank.mp4";
    playPreview.play();
  })

  $("#"+dom_id+"_recorder_placeholder").html('<video id="'+dom_id+'_recorder_preview" width="100%" height="100%" playsinline="true" autoplay="true" muted="true"></video>');
  recordPreview = $("#"+dom_id+"_recorder_placeholder").find("video")[0];
  if (flipRecordPreview) {
    recordPreview.style.transform = "scaleX(-1)";
  }

  
  var webcam_url;
  
  var chunks = [];
  var blob;
  var data_url;

  var cams = [];
  var mics = [];

  var recording_source;
  var playback_source;
  var meter;
  var audioLevelInterval;

  if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
    navigator.mediaDevices.enumerateDevices().then(function(devices){
      $(devices).each(function(index, device){
        device_name = (device.label == "" ? device.deviceId : device.label);
        if (device.kind === 'audioinput') {
          mics.push({
            label: device_name,
            deviceId: device.deviceId
          });
        } else if (device.kind === 'videoinput') {
          cams.push({
            label: device_name,
            deviceId: device.deviceId
          });
        }
      })
      if (!audio_only && cams.length == 0) {
        CameraTag.fire(dom_id, "noCamera");
      } else if (mics.length == 0) {
        CameraTag.fire(dom_id, "noMic");
      } else {
        if (!audio_only) {
          if (getCookie("CameraTagSelectedCameraId") && getCookie("CameraTagSelectedCameraId") != "default") {
            selected_cam_id = getCookie("CameraTagSelectedCameraId")
          } else {
            // selected_cam_id = cams[0].deviceId;  
          }
        }

        if (getCookie("CameraTagSelectedMicId") && getCookie("CameraTagSelectedMicId") != "default") {
          selected_mic_id = getCookie("CameraTagSelectedMicId")
        } else {
          selected_mic_id = mics[0].deviceId;  
        }
      }
      CameraTag.fire(dom_id, "initialized");
    });
  } else {
    CameraTag.fire(dom_id, "initialized");
    // no device enumeration supported
  }

  if (flipRecordPreview) {
    recordPreview.style.transform = "scaleX(-1)";
  }

  var wrtc_stream;

  self.stack = "MediaRecorder";

  self.setUUID = function(new_uuid) {
    // this stub is needed to comply with the expected recorder API
  };

  self.listCameras = function() {
    return cams;
  }

  self.listMicrophones = function() {
    return mics;
  }

  self.setCamera = function(id) {
    facingMode = null;
    delete constraints["video"]["facingMode"];
    delete constraints["facingMode"];
    constraints["video"]["deviceId"] = {ideal: id};
    selected_cam_id = id;
    if (id != "screen") {
      createCookie("CameraTagSelectedCameraId", id);
    }
  }

  self.getCamera = function() {
    constraints["video"]["deviceId"]
  }

  self.setMicrophone = function(id) {
    constraints["audio"]["deviceId"] = {ideal: id};
    selected_mic_id = id;
    createCookie("CameraTagSelectedMicId", id);
  }

  self.showNothing = function() {
    $("#"+dom_id+"_recorder_placeholder").hide();
    $("#"+dom_id+"_player_placeholder").hide();
  };

  self.showRecorder = function() {
    playPreview.pause();
    if (audio_only) {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").hide();
    } else {
      $("#"+dom_id+"_recorder_placeholder").show();
      $("#"+dom_id+"_player_placeholder").hide();
    }
  };

  self.showPlayer = function() {
    if (audio_only) {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").hide();
    } else {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").show();
    }
  };

  self.stopPlayback = function() {
    playPreview.pause();
    playPreview.muted = true;
    CameraTag.fire(dom_id, "playbackStopped");
  };

  self.startPlayback = function() {
    playPreview.srcObject = null;
    playPreview.src = data_url;
    playPreview.muted = false;

    playPreview.play().catch(function(e){
      console.log(e)
    });
    playPreview.muted = false;
    CameraTag.fire(dom_id, "playbackStarted");
  };

  self.pausePlayback = function() {
    playPreview.pause();
    CameraTag.fire(dom_id, "playbackPaused");
  };

  self.seekPlayback = function(new_position) {
    playPreview.currentTime = new_position;
    CameraTag.fire(dom_id, "playbackSeeked"); 
  };

  self.connect = function() {
    publishType = audio_only ? "rtc_audio" : "mediarecorder";
    var aspect_ratio = hResolution / vResolution;
    CameraTag.fire(dom_id, "waitingForCameraActivity");

    // empty constraints
    // var constraints = {
    //   audio: {},
    //   video: {}
    // };

    // // device constraints
    // if (facingMode) {
    //   constraints["facingMode"] = { exact: facingMode };
    // } else {
    //   constraints["audio"]["deviceId"] = selected_mic_id;
    //   constraints["video"]["deviceId"] = selected_cam_id;
    // }

    // // audio constraints
    // constraints["audio"]["audioBitRate"] = audioBitRate;     
    // if (disableAudioProcessing) {
    //   constraints["audio"]["echoCancellation"] = false;
    //   constraints["audio"]["noiseSuppression"] = false;
    //   constraints["audio"]["autoGainControl"] = false;
    // }

    // // video constraints
    // if (audio_only) {
    //   constraints["video"] = false;
    // } else {
    //   constraints["video"]["width"] = {ideal: hResolution};
    //   constraints["video"]["height"] = {ideal: vResolution};
    //   constraints["video"]["aspectRatio"] = {ideal: aspect_ratio};
    // }

    // grab a stream
    if (constraints?.video?.deviceId?.ideal == "screen") {
      // get screen and audio streams
      navigator.mediaDevices.getDisplayMedia(constraints).then(function(screenStream){
        navigator.mediaDevices.getUserMedia({audio: constraints["audio"]}).then(function(audioStream){
          $(audioStream.getAudioTracks()).each(function(index, audioTrack){
            screenStream.addTrack(audioTrack);
          });
          streamSuccess(screenStream);
        }).catch(streamError);
      }).catch(streamError);
      
    } else {
      navigator.mediaDevices.getUserMedia(constraints).then(streamSuccess).catch(streamError);
    }

  };

  var streamSuccess = function(stream) {
    wrtc_stream = stream;

    recording_source = audioContext.createMediaStreamSource(wrtc_stream);
    meter = createAudioMeter(audioContext);
    recording_source.connect(meter);
    meter.connect(audioContext.destination);
    audioLevelInterval = setInterval(sendAudioLevel,100);
    
    var urlCreator = window.URL || window.webkitURL;

    try {
      webcam_url = urlCreator.createObjectURL(wrtc_stream);
      recordPreview.src = webcam_url;
    } catch(error) {
      recordPreview.srcObject = wrtc_stream;
    }
    recordPreview.play();
    recordPreview.muted = true;

    var options = {};

    // audio recording options
    options["audioBitsPerSecond"] = audioBitRate;

    // video recording options
    if (!audio_only) {
      options["videoBitsPerSecond"] = videoBitRate;  

      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
        options["mimeType"] = 'video/webm;codecs=vp9';

      } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
        options["mimeType"] = 'video/webm;codecs=h264';

      } else  if (MediaRecorder.isTypeSupported('video/webm')) {
        options["mimeType"] = 'video/webm';

      } else if (MediaRecorder.isTypeSupported('video/mp4')) {
        options["mimeType"] = 'video/mp4';
      }
    } else {
        if ( MediaRecorder.isTypeSupported("audio/mp4") ) {
          options["mimeType"] = "audio/mp4";
        } else if ( MediaRecorder.isTypeSupported("audio/webm") ){
          options["mimeType"] = "audio/webm";  
        } else {
          options["mimeType"] = "audio/ogg";  
        }
    }

    try {
      mediaRecorder = new MediaRecorder(wrtc_stream, options);
    } catch (e) {
      throw_error("Error creating MediaRecorder");
      return;
    }

    
    mediaRecorder.ondataavailable = function(e) {
      if (state == "recording") {
        if (e.data && e.data.size > 0) {
          chunks.push(e.data);
        }
      }
    };

    mediaRecorder.onerror = function(e){
      throw_error(e);
    };

    mediaRecorder.onwarning = function(e){
      // console.log('Warning: ' + e);
    };

    mediaRecorder.onstop = function(){
      if (state == "recording") {
        blob = new Blob(chunks, {type: options["mimeType"]});
      
        let urlCreator = window.URL || window.webkitURL;
        data_url = urlCreator.createObjectURL(blob);

        chunks = [];

        if (mediaRecorder.stream && mediaRecorder.stream.getTracks()) {
          $(mediaRecorder.stream.getTracks()).each(function(index, track){
            track.stop(); // this helps prevent Android 11 freezing?
          })  
        } 

        CameraTag.fire(dom_id, "recordingStopped");
        CameraTag.fire(dom_id, "readyToPublish");

        if (skipPreview) {
          this_recorder.publish();
          // recorder.showPlayer();
          // self.loadInterface(accept_screen);
        }
        else {
          self.showPlayer();
          this_recorder.play();
        }
      }
    };

    // get device labels now that we have permission
    cams = [];
    mics = [];
    if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
      navigator.mediaDevices.enumerateDevices().then(function(devices){
        $(devices).each(function(index, device){
          device_name = (device.label == "" ? device.deviceId : device.label);
          if (device.kind === 'audioinput') {
            mics.push({
              label: device_name,
              deviceId: device.deviceId
            });
          } else if (device.kind === 'videoinput') {
            cams.push({
              label: device_name,
              deviceId: device.deviceId
            });
          }
        })
        if (!audio_only && cams.length == 0) {
          CameraTag.fire(dom_id, "noCamera");
        } else if (mics.length == 0) {
          CameraTag.fire(dom_id, "noMic");
        } else {
          if (!audio_only) {
            // selected_cam_id = selected_cam_id || cams[0].deviceId;
          }
          // selected_mic_id = selected_mic_id || mics[0].deviceId;
        }
        setTimeout(function(){
          CameraTag.fire(dom_id, "serverConnected");
          CameraTag.fire(dom_id, "readyToRecord");  
        }, 250)
        
        // audioLevelInterval = setInterval(sendAudioLevel,100);
      });

    } else {
      setTimeout(function(){
        CameraTag.fire(dom_id, "serverConnected");
        CameraTag.fire(dom_id, "readyToRecord");  
      }, 250)
      // audioLevelInterval = setInterval(sendAudioLevel,100);
    }


  }

  var streamError = function(error) { 
    console.log(error);
    CameraTag.fire(dom_id, "cameraDenied");
  }

  var sendAudioLevel = function() {
    var level = parseInt(meter.volume * 300); // this seems to the right multiplier but I dont know why
    CameraTag.fire(dom_id, "audioLevel", level);
  }

  self.getAudioTracks = function() {
    return wrtc_stream.getAudioTracks();
  }

  self.getVideoTracks = function() {
    return wrtc_stream.getVideoTracks(); 
  }

  self.disconnect = function() {
    recordPreview.srcObject = null;
    if (mediaRecorder.state != "inactive") {
      mediaRecorder.stop();
    }
    
    // mediaRecorder.ondataavailable = function(e) {
    // };
    // mediaRecorder.onerror = function(e){
    // };
    // mediaRecorder.onwarning = function(e){
    // };
    // mediaRecorder.onstop = function(e){
    // }
    CameraTag.fire(dom_id, "serverDisconnected");
  };

  self.startRecording = function() {
    recordPreview.muted = true;
    recordPreview.play();
    if (adapter.browserDetails.browser == "firefox") {
      mediaRecorder.start(100);  // this is a bug in firefox media recorder which prevent audio only playback with slices > 250ms
    } else {
      mediaRecorder.start();  
    }
    
    CameraTag.fire(dom_id, "recordingStarted");
  };

  self.stopRecording = function() {
    recordPreview.pause();
    clearInterval(audioLevelInterval);
    if (disconnectOnStop) {
      this_recorder.disconnect();
    }
    if (mediaRecorder.state != "inactive") {
      mediaRecorder.stop();
    }
    wait(CT_i18n[98]);
  };

  self.pauseRecording = function() {
      recordPreview.pause();
      mediaRecorder.pause();
      // clearInterval(audioLevelInterval);
      CameraTag.fire(dom_id, "recordingPaused");
  };

  self.resumeRecording = function() {
      recordPreview.muted = true;
      recordPreview.play();
      // audioLevelInterval = setInterval(sendAudioLevel,100);
      mediaRecorder.resume();
      CameraTag.fire(dom_id, "recordingResumed");
  };

  self.publish = function() {
    console.log("blob size:" + blob.size);
    if (blob.size == 0) {
      throw_error("There was an error recording your file. Please try again.");
      return;
    }
    
    this_recorder.disconnect();
    
    // state = "uploading";
    // uploading = true; // andorid doesn't seem to get this set through the uploadStarted event?
    CameraTag.fire(dom_id, "uploadStarted");
    // start_screen.css("left", "-10000px");
    // start_screen.css("right", "10000px");

    uploader.add({
      file: blob,
      name: 'recordings/' + asset.uuid + '.flv',
      complete: function(){
        // empty the blob
        blob = null;
        readyToPublish = true;
        publishType = "mediarecorder";
        //sendStat("upload_success", {});
        start_screen.css("left", "0px");
        start_screen.css("right", "0px");

        wait(CT_i18n[38]);
        
        var asset_type = audio_only ? "Audio" : "Video";
        var publish_type = audio_only ? "rtc_audio" : "mediarecorder";

        publish_asset({
          original_filename: asset.uuid + '.flv', 
          original_url: "https://cameratag-upload.s3.amazonaws.com/recordings/"+asset.uuid+".flv",
          camera_uuid: app_uuid, 
          asset_uuid: asset.uuid, 
          asset_type: asset_type,
          type: publish_type, 
          videoServer: videoServer, 
          signature: signature, 
          signature_expiration: signature_expiration, 
          metadata: metadata_object, 
          asset_name: asset_name, 
          asset_description: asset_description,
          prompt_response_times: prompt_response_times
        });
      },
      progress: function(progress){
        progress = progress;
        CameraTag.fire(dom_id, "UploadProgress", progress);
        CameraTag.fire(dom_id, "uploadProgress", progress);
        upload_status.html((progress * 100).toFixed(1) + "%");
        setUploadPercentage(progress);
      },
      error: function(error) {
        throw_error("There was an error uploading your file");
        CameraTag.fire(dom_id, "uploadAborted", {
          error: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
        return;
      }
    })

  }

}

  // WebRTC
  var WebRtcRecorder = function() {
  var self = this;

  var cams = [];
  var mics = [];

  var rtcAdaptor, recordPreview, playPreview, pc_config, sdpConstraints;

  var stream_id;
  var random_stream_suffix;
  var stream_extension = "mp4";

  var audioLevelInterval;
  var meter;
  var recording_source;

  var MAX_PUBLISH_RETRIES = 3;
  var publish_retry_count = 0;
  
  var init = function() {
    updateDeviceArrays().then(function() {
      CameraTag.fire(dom_id, "initialized");
    })
  }

  var updateDeviceArrays = function() {
    return new Promise(function(resolve, reject) {
      cams = [];
      mics = [];
      if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices().then(function(devices){
          $(devices).each(function(index, device){
            device_name = (device.label == "" ? device.deviceId : device.label);
            if (device.kind === 'audioinput') {
              mics.push({
                label: device_name,
                deviceId: device.deviceId
              });
            } else if (!audio_only && device.kind === 'videoinput') {
              cams.push({
                label: device_name,
                deviceId: device.deviceId
              });
            }
          })

          if (cams.length == 0 && !audio_only) {
            CameraTag.fire(dom_id, "noCamera");

          } else if (mics.length == 0) {
            CameraTag.fire(dom_id, "noMic");

          } else {
            // if (getCookie("CameraTagSelectedCameraId") && camIdExists(getCookie("CameraTagSelectedCameraId")) && getCookie("CameraTagSelectedCameraId") != "default") {
            //   selected_cam_id = getCookie("CameraTagSelectedCameraId")
            // } else {
            //   selected_cam_id = cams[0].deviceId;  
            // }

            // if (getCookie("CameraTagSelectedMicId") && micIdExists(getCookie("CameraTagSelectedMicId")) && getCookie("CameraTagSelectedMicId") != "default") {
            //   selected_mic_id = getCookie("CameraTagSelectedMicId")
            // } else {
            //   selected_mic_id = mics[0].deviceId;  
            // }
          }
          resolve()
        });
      } else {
        resolve()
        // no device enumeration supported
      }
    });
  }

  var camIdExists = function(id) {
    var exists = false;
    $(cams).each(function(index, cam) {
      if (cam.deviceId == id) {
        exists = true;
      }
    })
    return exists;
  }

  var micIdExists = function(id) {
    var exists = false;
    $(mics).each(function(index, mic) {
      if (mic.deviceId == id) {
        exists = true;
      }
    })
    return exists;
  }


  // Add video placeholder elements
  $("#"+dom_id+"_player_placeholder").html('<video width="100%" height="100%" playsinline="true"></video>');
  playPreview = $("#"+dom_id+"_player_placeholder").find("video")[0];
  // playPreview.addEventListener('error', function(event) { 
  //   alert(CT_i18n[110]);
  //   CameraTag.fire(dom_id, "playbackStopped");
  // }, true);
  $(playPreview).bind("ended", function() {
    if (playPreview.src != "https://static.cameratag.com/blank.mp4") {
      CameraTag.fire(dom_id, "playbackStopped");  
    }
  });

  $(container).one("click", function(){
    console.log("Cliked!");
    playPreview.src = "https://static.cameratag.com/blank.mp4";
    playPreview.play();
  })

  $("#"+dom_id+"_recorder_placeholder").html('<video id="'+dom_id+'_recorder_preview" width="100%" height="100%" playsinline="true" autoplay="true" muted="true"></video>');
  recordPreview = $("#"+dom_id+"_recorder_placeholder").find("video")[0];
  if (flipRecordPreview) {
    recordPreview.style.transform = "scaleX(-1)";
  }



  self.stack = "WebRTC";

  self.setUUID = function(new_uuid) {
    // not used by this recording stack
  };

  self.listCameras = function() {
    return cams;
  }

  self.listMicrophones = function() {
    return mics;
  }

  self.setCamera = function(id) {
    facingMode = null;
    delete constraints["video"]["facingMode"];
    delete constraints["facingMode"];
    constraints["video"]["deviceId"] = {ideal: id};
    selected_cam_id = id;
  }

  self.setMicrophone = function(id) {
    constraints["audio"]["deviceId"] = {ideal: id};
    selected_mic_id = id;
  }

  self.showNothing = function() {
  };

  self.showRecorder = function() {
    if (audio_only) {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").hide();
    } else {
      $("#"+dom_id+"_recorder_placeholder").show();
      $("#"+dom_id+"_player_placeholder").hide();
    }

  };

  self.showPlayer = function() {
    if (audio_only) {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").hide();
    } else {
      $("#"+dom_id+"_recorder_placeholder").hide();
      $("#"+dom_id+"_player_placeholder").show();
    }
  };

  self.stopPlayback = function() {
    playPreview.pause();
    CameraTag.fire(dom_id, "playbackStopped");
  };

  self.getAudioTracks = function() {
    return [rtcAdaptor.audioTrack];
  }

  self.getVideoTracks = function() {
    return [rtcAdaptor.videoTrack];
  }

  // self.shareScreen = function() {
  //   rtcAdaptor.switchDesktopCapture(stream_id);
  // }

  // self.shareVideo = function() {
  //   rtcAdaptor.switchVideoCapture(stream_id);
  // }

  self.getStreamInfo = function() {
    rtcAdaptor.getStreamInfo(stream_id);
  }

  self.startPlayback = async function() {
    wait(CT_i18n[37]);
    var cache_buster = parseInt(Math.random() * 1000000000);
    var original_filename = audio_only ? (stream_id+"_240p."+stream_extension) : stream_id+"."+stream_extension;
    playPreview.src = "https://s3.amazonaws.com/record.cameratag.com/streams/"+original_filename+"?cb="+cache_buster
    try {
      await playPreview.play();
      self.showPlayer();
      CameraTag.fire(dom_id, "playbackStarted");
    } catch (e) {
      console.log(e);
      setTimeout(self.startPlayback, 1000);
    }
  };

  self.pausePlayback = function() {
    playPreview.pause();
    CameraTag.fire(dom_id, "playbackPaused");
  };

  self.seekPlayback = function(new_position) {
    playPreview.currentTime = new_position;
    CameraTag.fire(dom_id, "playbackSeeked"); 
  };


  // var getConstraints = function() {
  //   if (audio_only) {
  //     var constraints = {
  //       audio: true,
  //       video: false
  //     }
  //   } else {
  //     if (aspectRatio < 1) {
  //       var video_constraints = {
  //         frameRate: { ideal: 20 },
  //         width: { ideal:  vResolution },
  //         height: { ideal: hResolution }
  //       }
  //     } else {
  //       var video_constraints = {
  //         frameRate: { ideal: 20 },
  //         width: { ideal: hResolution },
  //         height: { ideal: vResolution }
  //       }
  //     }
  //     var constraints = {
  //       audio: true,
  //       video: video_constraints
  //     }
  //   }

  //   if (!audio_only && facingMode && navigator.mediaDevices.getSupportedConstraints().facingMode) {
  //     constraints["facingMode"] = { ideal: facingMode }
  //     constraints["video"]["facingMode"] = { ideal: facingMode }
  //   }

  //   if (disableAudioProcessing && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
  //     constraints["echoCancellation"] = false;
  //   }

  //   if (disableAudioProcessing && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
  //     constraints["autoGainControl"] = false;
  //   }

  //   return constraints;
  // }

  self.connect = function() {
    CameraTag.fire(dom_id, "waitingForCameraActivity");
    sdpConstraints = {
      OfferToReceiveAudio : false,
      OfferToReceiveVideo : false
    };

    pc_config = {
      'iceServers' : [{
        'urls' : 'turn:turn.cameratag.com:80',
        'username': "turn",
        'credential': "G0MRMBqpeMMyeFqlypUB"
      }]
    };

    random_stream_suffix = parseInt(Math.random() * 1000000000);
    stream_id = asset.uuid + "_" + random_stream_suffix;

    var appName = audio_only ? "RecordAudio" : "RecordVideo"

    rtcAdaptor = new WebRTCAdaptor({
      websocket_url : "wss://stream2.cameratag.com/"+appName+"/websocket",
      mediaConstraints : constraints,
      peerconnection_config : pc_config,
      sdp_constraints : sdpConstraints,
      localVideoId : dom_id+"_recorder_preview",
      callback : function(info, obj) {
        if (info == "initialized") {
          // console.log("initialized");
          updateDeviceArrays().then(function() {
            CameraTag.fire(dom_id, "serverConnected");
            CameraTag.fire(dom_id, "readyToRecord");
          })

          // audioContext.resume();
          // recording_source = audioContext.createMediaStreamSource(rtcAdaptor.localStream);
          // meter = createAudioMeter(audioContext);
          // recording_source.connect(meter);
          // audioLevelInterval = setInterval(sendAudioLevel,100);

          recording_source = audioContext.createMediaStreamSource(rtcAdaptor.localStream);
          meter = createAudioMeter(audioContext);
          recording_source.connect(meter);
          meter.connect(audioContext.destination);
          audioLevelInterval = setInterval(sendAudioLevel,100);
        } 
        else if (info == "publish_started") {
          //stream is being published 
          // console.log("publish started"); 
          publish_retry_count = 0;
          CameraTag.fire(dom_id, "recordingStarted");
          self.getStreamInfo();
        } 
        else if (info == "publish_finished") {
          //stream is finished
          // console.log("publish finished");
          CameraTag.fire(dom_id, "recordingStopped");
          CameraTag.fire(dom_id, "readyToPublish");

          if (skipPreview) {
            this_recorder.publish();
            // recorder.showPlayer();
            // self.loadInterface(accept_screen);
          }
          else {
            self.showPlayer();
            this_recorder.play();
          }
        }
        else if (info == "streamInformation") {
          if (obj.streamInfo[0].videoCodec == "H264" || audio_only) {
            stream_extension = "mp4"
          } else {
            stream_extension = "webm"
          }
        }
      },
      callbackError : function(error) {
        console.log("error callback: " + error);
        if (error == "UnsecureContext") {
          CameraTag.fire(dom_id, "unsecureContext");

        } else if (error == "WebSocketNotSupported") {
          CameraTag.fire(dom_id, "webSocketNotSupported");

        } else if (error == "SecurityError" || error == "NotAllowedError" || error == "PermissionDeniedError") {
          CameraTag.fire(dom_id, "hardwareAccessDenied");

        } else if (error == "publishTimeoutError") {
          // if (publish_retry_count < MAX_PUBLISH_RETRIES) {
          //   publish_retry_count += 1;
          //   setTimeout(function(){
          //     rtcAdaptor.publish(stream_id);
          //   }, 1000);
          // } else {
            // publish_retry_count = 0;
            CameraTag.fire(dom_id, "serverError");
          // }
          
        } else {
          CameraTag.fire(dom_id, "unknownError", error);
        }
      }
    });    
  };

  var sendAudioLevel = function() {
    var level = parseInt(meter.volume * 300); // this seems to the right multiplier but I dont know why
    CameraTag.fire(dom_id, "audioLevel", level);
  }

  self.disconnect = function() {
    // audioContext.suspend();
    // meter.disconnect();
    // recording_source.disconnect(meter);
    rtcAdaptor.closeStream();
    CameraTag.fire(dom_id, "serverDisconnected");  
  };

  self.startRecording = function() {
    // make sure audioLevelInterval is set
    // clearInterval(audioLevelInterval);
    // audioLevelInterval = setInterval(sendAudioLevel,100);
    rtcAdaptor.publish(stream_id);
  };

  self.stopRecording = function() {
    rtcAdaptor.stop(stream_id);
    if (disconnectOnStop) {
      this_recorder.disconnect();
    }
    clearInterval(audioLevelInterval);
  };

  self.upload = function() {
    // not used by this stack
  };

  self.publish = function() {
    this_recorder.disconnect();
    var asset_type = audio_only ? "Audio" : "Video";
    var publish_type = audio_only ? "stream_audio2" : "stream2";
    var original_filename = audio_only ? (stream_id+"_240p."+stream_extension) : stream_id+"."+stream_extension;

    wait(CT_i18n[38]);
    
    publish_asset({
      original_filename: original_filename,
      camera_uuid: camera_uuid, 
      asset_uuid: asset.uuid,
      asset_type: asset_type,
      type: publish_type, 
      videoServer: videoServer, 
      signature: signature, 
      signature_expiration: signature_expiration, 
      metadata: metadata_object, 
      asset_name: asset_name, 
      asset_description: asset_description,
      prompt_response_times: prompt_response_times
    });
  }

  init();

}



  // keep a reference to this instance in the Class 
  if (audio_only) {
    CameraTag.microphones[dom_id] = self;  
  } else {
    CameraTag.cameras[dom_id] = self;  
  }
  

  var setup = function() {
    get_camera(camera_uuid, function(server_response){
      if (server_response.success) {
        app_uuid = server_response.app_uuid;
        videoServer = server_response.videoServer;
        use_twilio = server_response.use_twilio;

        if (audio_only) {
          media_factories = server_response.audio_media_factories;
        } else {
          media_factories = server_response.video_media_factories;
        }
        
        asset = new_asset();
        
        // observe new asset for its published state
        CameraTag.observe(asset.uuid, "published", function(published_asset) {
          if (asset.uuid == published_asset.uuid) {
            state = "published";
            populate_hidden_inputs();
            //sendStat("publish_success");
            CameraTag.fire(dom_id, "published", asset);  
            
            pollForProcessed();
            
            self.loadInterface(completed_screen);
            if (connected) {
              self.disconnect();
            }
          }
        }, true);

        // observe processed and show player
        if (playerOnProcess) {
          CameraTag.observe(asset.uuid, "processed", function(processed_asset) {
            if (asset.uuid == processed_asset.uuid) {
              $(completed_screen).html('<player data-uuid="'+asset.uuid+'" id="'+dom_id+'_player" data-signature="'+signature+'" data-signature-expiration="'+signature_expiration+'"></player>');
              CameraTag.setup();
            }
          }, true);
        }

        // failed publish
        CameraTag.observe(asset.uuid, "publishFailed", function(error) {
          if (asset.uuid == error.asset_uuid) {
            throw_error(CT_i18n[34] + error.message);
          }
        }, true);
      }
      else {
        error_messages.push(server_response.message);
        CameraTag.fire(dom_id, "initializationError", server_response);
      }

      // initialize the interface
      setup_interface();

      if (error_messages.length > 0) {
        throw_error(error_messages[0]);
        return;
      }


      CameraTag.observe(dom_id, "initialized", function(){
        // load up the start screen 
        if (recorder instanceof MobileRecorder) {
          self.loadInterface(mobile_start_screen, true);  
        } else {
          self.loadInterface(start_screen, true);  
        }

        // show settings button if applicable
        if (recorder.listCameras().length > 0) {
          settings_btn.show();
        }
      })
      

      // font-size
      font_size = parseInt($(container).width() / 25);
      if (font_size < 14) {
        font_size = 14;
      }
      if (font_size > 22) {
        font_size = 22;
      }
      $(container).css({fontSize: font_size+"px"});  
    });
  };

  var new_asset = function() {
    var asset = {};
    if (existingUuid) {
      asset.uuid = existingUuid  
    } else {
      asset.uuid = generateUUID("v-");  
    }
    
    // setup asset medias
    asset.medias = {};
    if (media_factories) {
      $.each(media_factories, function(name, factory){
        asset.medias[name] = null;
      })
    }
    
    return asset;
  }

  var setup_interface = function() {
    // setup prarms with preference to passed in as data attributes on the camera tag
    input_name = $(camera_el).attr("name") || dom_id;
    inline_styles = $(camera_el).attr("style");
    // if (media_factories && Object.keys(media_factories).length > 0 && webrtc_enabled && !audio_only) {
    //   var scale_multiplier;
    //   var mf_width = media_factories[Object.keys(media_factories)[0]].width;
    //   var mf_height = media_factories[Object.keys(media_factories)[0]].height;
    //   var mf_aspect = mf_width / mf_height;
    //   if (mf_aspect > 1.3) {
    //     // if its wider scale height to 300
    //     scale_multiplier = 300 / mf_height;
    //     height = 300;
    //     width = parseInt(mf_width * scale_multiplier);
    //   } else {
    //     scale_multiplier = 400 / mf_width;
    //     width = 400;
    //     height = parseInt(mf_height * scale_multiplier);
    //   }

    //   hResolution = mf_width;
    //   vResolution = mf_height;
    // }
    // else if (media_factories && Object.keys(media_factories).length > 0 &&  !audio_only) {
    //   var scale_multiplier;
    //   var mf_width = media_factories[Object.keys(media_factories)[0]].width;
    //   var mf_height = media_factories[Object.keys(media_factories)[0]].height;
    //   var mf_aspect = mf_width / mf_height;
    //   if (mf_aspect > 1.3) {
    //     // if its wider scale height to 300
    //     scale_multiplier = 300 / mf_height;
    //     height = 300;
    //     width = parseInt(mf_width * scale_multiplier);
    //   } else {
    //     scale_multiplier = 400 / mf_width;
    //     width = 400;
    //     height = parseInt(mf_height * scale_multiplier);
    //   }

    //   if (mf_width > 640 || mf_height > 480) {
    //     hResolution = parseInt(mf_width / 2);
    //     vResolution = parseInt(mf_height / 2);
    //   } else {
    //     hResolution = mf_width;
    //     vResolution = mf_height;
    //   }

    if (media_factories && Object.keys(media_factories).length > 0 && !audio_only) {
      var mf_width = media_factories[Object.keys(media_factories)[0]].width;
      var mf_height = media_factories[Object.keys(media_factories)[0]].height;
      width = parseInt(mf_width / 2);
      aspect_ratio = `${mf_width}/${mf_height}`;
      hResolution = mf_width;
      vResolution = mf_height;

    } else if (media_factories && Object.keys(media_factories).length > 0) {
      width = 500;
      aspect_ratio = "5/2";
    } else {
      // this is used to define an area to display an error
      width = 400;
      hResolution = 400;
      vResolution = 300;
    }

    // width = $(camera_el).attr("data-width") || width;
    // height = $(camera_el).attr("data-height") || null;

    // width = parseInt(width);
    // height = parseInt(height);

    // if ($(camera_el).attr("data-pre-roll-length")) {
    //   preRollLength = parseInt($(camera_el).attr("data-pre-roll-length"))
    // }
    // else {
    //   preRollLength = 3;
    // }
    

    // build the control elements 
    buildInterface();
    buildConstraints();
    setRecorderType();
    createUploader();
    setupEventObservers();

    // show error messages if there are any
    if (error_messages.length > 0) {
      throw_error(error_messages.join("\n"));
      return;
    }
  };

  var buildConstraints = function() {
    if (navigator && navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {
      // audio constraints
      if (audioBitRate && navigator.mediaDevices.getSupportedConstraints().audioBitRate) {
        constraints["audio"]["audioBitRate"] = audioBitRate; 
      }
      if (sampleSize && navigator.mediaDevices.getSupportedConstraints().sampleSize) {
        constraints["audio"]["sampleSize"] = sampleSize;
      }
      if (sampleRate && navigator.mediaDevices.getSupportedConstraints().sampleRate) {
        constraints["audio"]["sampleRate"] = sampleRate;
      }
      if (disableAudioProcessing) {
        if (navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
          constraints["audio"]["echoCancellation"] = false;  
        }

        if (navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
          constraints["audio"]["noiseSuppression"] = false;  
        }

        if (navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
          constraints["audio"]["autoGainControl"] = false;  
        }
      } else {
        if (navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
          constraints["audio"]["echoCancellation"] = true;  
        }

        if (navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
          constraints["audio"]["noiseSuppression"] = true;  
        }

        if (navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
          constraints["audio"]["autoGainControl"] = true;  
        }
      }
      if (selected_mic_id) {
        constraints["audio"]["deviceId"] = selected_mic_id;
      }

      // video constraints
      if (audio_only) {
        constraints["video"] = false;
      } else {
        // device constraints
        if (facingMode && navigator.mediaDevices.getSupportedConstraints().facingMode) {
          constraints["facingMode"] = { ideal: facingMode };
          constraints["video"]["facingMode"] = { ideal: facingMode };
        } else if (selected_cam_id) {
          constraints["video"]["deviceId"] = { ideal: selected_cam_id };
        }
        if (screenShare) {
          constraints["video"]["deviceId"] = { ideal: "screen" }; 
        }
        // var aspect_ratio = hResolution / vResolution;
        if (navigator.mediaDevices.getSupportedConstraints().aspect_ratio) {
          constraints["video"]["aspectRatio"] = {ideal: aspect_ratio};  
        }
        if (isMobileDevice && aspect_ratio < 1) {
          // always ask for horizontal aspect ratios on mobile and allow orientation metadata to flip it
          constraints["video"]["width"] = {ideal: vResolution};
          constraints["video"]["height"] = {ideal: hResolution};
        } else {
          constraints["video"]["width"] = {ideal: hResolution};
          constraints["video"]["height"] = {ideal: vResolution};
        }
      }
    }
  }
  
  var setRecorderType = function() {
    var defaultStack = CameraTag.defaultStack("camera");

    // load manual stack if one exists
    if (manual_stack && (manual_stack.toLowerCase() == "mobile" || manual_stack.toLowerCase() == "webrtc" || manual_stack.toLowerCase() == "mediarecorder")) {
      if (manual_stack.toLowerCase() == "mobile") {
        recorder = new MobileRecorder(); 
      }
      else if (manual_stack.toLowerCase() == "webrtc") {
        recorder = new WebRtcRecorder();
      }
      else if (manual_stack.toLowerCase() == "mediarecorder") {
        recorder = new CTMediaRecorder();
      }
      else if (manual_stack.toLowerCase() == "flash") {
        CameraTag.fire(dom_id, "initialized");
        self.record = function() {
          alert(CT_i18n[125]);
        }
      }
    }

    // load default stack
    else {
      if (defaultStack == "WebRTC") {
        recorder = new WebRtcRecorder();

      } else if (defaultStack == "Mobile") {
        recorder = new MobileRecorder(); 

      } else if (defaultStack == "MediaRecorder"){
        recorder = new CTMediaRecorder();

      } else if (defaultStack == "Unsupported") {
        CameraTag.fire(dom_id, "initialized");
        self.record = function() {
          alert(CT_i18n[126]);
        }
      }
      
    }

  }

  self.stack = function(){
    return recorder.stack;
  }

  // self.shareScreen = function(){
  //   recorder.shareScreen();
  // }

  // self.shareVideo = function() {
  //   recorder.switchVideoCapture();
  // }

  self.getState = function() {
    return state;
  };

  var setUploadPercentage = function(percentage_float) {
    CameraTag.fire(dom_id, "UploadProgress", percentage_float);
    CameraTag.fire(dom_id, "uploadProgress", percentage_float);
    // var deg = 180.0 * percentage_float;
    // var fix_deg = 360.0 * percentage_float;
    // $(".radial-progress .circle .mask.full, .radial-progress .circle .fill").css({"transform": "rotate("+deg+"deg)"});
    // $(".radial-progress .circle .fill.fix").css({"transform": "rotate("+fix_deg+"deg)"});
    // upload_status.html((percentage_float * 100).toFixed(1) + "%");
    var width = (percentage_float * 100) + "%";
    $(container).find(".cameratag_progress_fill").css({width: width});
  }

  self.startUpload = function(passed_file) {
    file_to_upload = passed_file || file_to_upload;
    // get file extension
    var ext = file_to_upload.name.split(".")
    ext = ext[ext.length-1];
    ext = ext.toLowerCase();

    // dont permit invalid filetypes
    if (permittedExtensions.indexOf(ext) == -1) {
      if ( !confirm(CT_i18n[42]) ) {
        return;
      }
    }

    // state = "uploading";
    // uploading = true; // andorid doesn't seem to get this set through the uploadStarted event?
    CameraTag.fire(dom_id, "uploadStarted");
    // upload_screen.show();
    // // start_screen.hide();
    // start_screen.css("left", "-10000px");
    // start_screen.css("right", "10000px");

    var isAndroid = navigator.userAgent.toLowerCase().indexOf("android") > -1; //&& ua.indexOf("mobile");
    if (isAndroid) {
      upload_status.html("...");
    }
    else {
      upload_status.html("0%");
    }
    uploader.add({
      name: 'recordings/' + asset.uuid + '.flv',
      file: file_to_upload,
      complete: function(){
        readyToPublish = true;
        // publishType = "upload";
        CameraTag.fire(dom_id, "readyToPublish");
        //sendStat("upload_success", {});

        start_screen.css("left", "0px");
        start_screen.css("right", "0px");

        var asset_type = audio_only ? "Audio" : "Video";

        if (publishOnUpload) {
          wait(CT_i18n[38]);
          setTimeout(function() {
            publish_asset({
              original_filename: file_to_upload.name,
              original_url: "https://cameratag-upload.s3.amazonaws.com/recordings/"+asset.uuid+".flv",
              camera_uuid: app_uuid, 
              asset_uuid: asset.uuid, 
              asset_type: asset_type,
              type: "upload", 
              videoServer: videoServer, 
              signature: signature, 
              signature_expiration: signature_expiration, 
              metadata: metadata_object, 
              asset_name: asset_name, 
              asset_description: asset_description,
              prompt_response_times: prompt_response_times
            });
          }, 1000)
          
        }
        else {
          upload_pending_publish = true;
        }
      },
      progress: function(progress){
        progress = progress;
        CameraTag.fire(dom_id, "UploadProgress", progress);
        CameraTag.fire(dom_id, "uploadProgress", progress);
        upload_status.html((progress * 100).toFixed(1) + "%");
        setUploadPercentage(progress);
      },
      error: function(error) {
        throw_error("There was an error uploading your file");
        CameraTag.fire(dom_id, "uploadAborted", {
          error: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
        return;
      }
    })
  }

  self.showMessage = function(message) {
    var msg_container = $(container).find(".cameratag_user_message")
    msg_container.html(message);
    msg_container.addClass("visible");
  }

  self.hideMessage = function(){
    $(container).find(".cameratag_user_message").removeClass("visible");
  }

  self.flashMessage = function(message, duration) {
    duration = duration || 3000;
    var msg_container = $(container).find(".cameratag_user_message")
    msg_container.html(message);
    msg_container.addClass("visible");
    setTimeout(function(){
      msg_container.removeClass("visible");
    }, duration);
  }

  var createUploader = function() {
    // UPLOADING
    var mimes = audio_only ? audio_mimes : video_mimes;
    if (upload_source_index == -1) {
      var upload_input = $('<input id="'+dom_id+'_upload_file" style="position:absolute;" type="file" accept="'+mimes+'" capture>')
    } else {
      var upload_input = $('<input id="'+dom_id+'_upload_file" style="position:absolute;" type="file" accept="'+mimes+'">')
    }
    $(start_screen).append(upload_input);
    $(upload_input).change(function(evt){
      if (evt.target.files[0]) {
        file_to_upload = evt.target.files[0];
        CameraTag.fire(dom_id, "uploadFileSelected", file_to_upload);

        self.startUpload();      

        $(evt.target).val('');
      }
    });
    // hide it for now
    $(upload_input).css({
      left: -99999,
      top: -99999,
      width: 1,
      height: 1,
      opacity: 0
    });


    // position input over browse element
    if (!(recorder instanceof MobileRecorder) && sources.indexOf("upload") != -1 && start_screen.find(".cameratag_upload").length > 0) {
      var browse_element = start_screen.find(".cameratag_upload")[0];
      var upload_source_index = sources.indexOf("upload");
      $(upload_input).css({
        left: $(browse_element).offset().left - $(browse_element).offsetParent().offset().left,
        top: $(browse_element).offset().top - $(browse_element).offsetParent().offset().top,
        width: $(browse_element).width(),
        height: $(browse_element).height(),
        opacity: 0
      });
      $(browse_element).css({
        zIndex: 1
      });
      $(browse_element).click(function(e){
        if (e.target != upload_input[0]) {
          e.stopPropagation();
          $(upload_input).click();
        }
      });
    }

    uploader = {};

    upload_input.fileupload({
      type: 'POST',
      autoUpload: false,
      paramName: 'file', // S3 does not like nested name fields i.e. name="user[avatar_url]"
      dataType: 'XML',  // S3 returns XML if success_action_status is set to 201
      replaceFileInput: false,
      progressall: function (e, data) {
        var progress = data.loaded / data.total;
        // console.log("uploading: "+progress);
        uploader.progress(progress);
      },
      start: function (e) {
        // console.log("starting upload");
      },
      done: function(e, data) {
        // console.log("done uploading");
        uploader.complete();
      },
      fail: function(e, data) {
        // console.log("UPLOAD FAIL!");
        uploader.error(e);
      }
    });


    uploader.add = function(opts) {
      uploader.progress = opts.progress;
      uploader.complete = opts.complete;
      uploader.error = opts.error;

      $.ajax({
        url: 'https://'+appServer+'/api/v'+CameraTag.version+'/assets/upload_signature2',
        data: {
          key: opts.name
        },
        dataType: "json",
        success: function(upload_sign_response) {
          upload_input.fileupload('send', {
            files: [ opts.file ],
            url: upload_sign_response.url,
            formData: upload_sign_response.formData
          });
        }
      })
    }

  }

  var updateDevices = function(callback) {
    if (!audio_only && selected_cam_id == null) {
      selected_cam_id = recorder.getVideoTracks()[0].getSettings().deviceId;
    }
    if (selected_mic_id == null) {
      selected_mic_id = recorder.getAudioTracks()[0].getSettings().deviceId;  
    }
    
    var selected;
    if (camera_options && !audio_only && recorder.listCameras() && recorder.listCameras().length > 0) {
      camera_options.html("");
      $(recorder.listCameras()).each(function(index, device){
        selected = (device.deviceId == selected_cam_id ? "selected" : "");
        camera_options.append('<option value="'+device.deviceId+'" '+selected+'>'+device.label+'</option>');
      })
    }
    // screen share
    if (camera_options && navigator.mediaDevices.getDisplayMedia) {
      selected = (selected_cam_id == "screen" ? "selected" : "");
      camera_options.append('<option value="screen" '+selected+'>Screen Share</option>');
    }

    if (mic_options && recorder.listMicrophones() && recorder.listMicrophones().length > 0) {
      mic_options.html("");
      $(recorder.listMicrophones()).each(function(index, device){
        selected = (device.deviceId == selected_mic_id ? "selected" : "");
        mic_options.append('<option value="'+device.deviceId+'" '+selected+'>'+device.label+'</option>');
      });
    }
  }

  var startAudioMeter = function() {
    if (audio_only && showVisualization) {
      audio_viz.addClass("visible");
      audio_meter_on = true;
      drawAudioMeter();  
    }
    return;
  }

  var stopAudioMeter = function() {
    audio_viz.removeClass("visible");
    audio_meter_on = false;
  }

  var drawAudioMeter = function() {
    meterAudioLevel = audioLevel / 10;
    // console.log(audioLevel);
    if (audio_only) {
      siriWave.setAmplitude(meterAudioLevel);
    }
    window.requestAnimationFrame( drawAudioMeter );

    // if (audio_meter_on) {
    //   if (audio_only) {
    //     canvasContext.clearRect(0,0,width,height);

    //     // check if we're currently clipping
    //     if (audioLevel > 60) {
    //       canvasContext.strokeStyle = "red";
    //       //canvasContext.fillStyle = "red";
    //     }
    //     else {
    //       canvasContext.strokeStyle = "green";
    //       //canvasContext.fillStyle = "green";
    //     }

    //     // draw curve 1
    //     height_adjusted_level = audioLevel * 0.05 * height;
    //     canvasContext.lineWidth = 3;
    //     canvasContext.beginPath();
    //     canvasContext.moveTo(0, (height * 0.5));
    //     canvasContext.bezierCurveTo((width * 0.25), (height * 0.5 + height_adjusted_level), (width * 0.75), (height * 0.5 - height_adjusted_level), width, (height / 2));
    //     canvasContext.stroke();


    //     // curve 2
    //     height_adjusted_level = audioLevel * 0.05 * height * Math.random();
    //     canvasContext.lineWidth = 1;
    //     canvasContext.beginPath();
    //     canvasContext.moveTo(0, (height * 0.5));
    //     canvasContext.bezierCurveTo((width * 0.25), (height * 0.5 + height_adjusted_level), (width * 0.75), (height * 0.5 - height_adjusted_level), width, (height / 2));
    //     canvasContext.stroke();
          
    //     // draw a bar based on the current volume
    //     // canvasContext.beginPath();
    //     // canvasContext.arc(width / 2, height / 2, audioLevel * 0.014 * height, 0, 2 * Math.PI, false);
    //     // canvasContext.fill();

    //     // canvasContext.fillRect(0, 0, width, meter.volume*height*2);

    //     // set up the next visual callback
      
    //     rafID = window.requestAnimationFrame( drawAudioMeter );
    //   } else {
    //     var percent = audioLevel+"%";
    //     $(".cameratag_vertical_meter").css({height: percent})
    //     $(".cameratag_horizontal_meter").css({width: percent})
    //     rafID = window.requestAnimationFrame( drawAudioMeter );
    //   }
    // }
  }

  var find_custom_screen = function(screen_name) {
    var found_screen;

    found_screen = $(camera_el).find("."+screen_name).addClass("cameratag_screen");
    if (found_screen.length == 0) {
      found_screen = $("#"+dom_id+"-"+screen_name).addClass("cameratag_screen")
    }

    return found_screen;
  }

  var buildInterface = function() {
    // dont allow sms source on mobile devices or audio
    if (!use_twilio || isMobileDevice || audio_only) {
      var sms_source_index = sources.indexOf("sms");
      if (sms_source_index != -1) {
        sources.splice(sms_source_index,1);
      }
    }

    // dont allow upload for mobile audio
    if (isMobileDevice && audio_only) {
      var upload_source_index = sources.indexOf("upload");
      if (upload_source_index != -1) {
        sources.splice(upload_source_index,1);
      }
    }

    
    if (!skipFontAwesome && typeof(FontAwesomeCdnConfig) == "undefined") {
      var font_awesome = $('<script src="https://kit.fontawesome.com/3d84f307b4.js" crossorigin="anonymous"></script>');
      $("head").append(font_awesome);
    }

    // container
    container = $('<div id="'+dom_id+'" class="camera_tag yui3-cssreset"></div>');
    container.css({width: width+"px", aspectRatio: aspect_ratio});
    container.attr("style", inline_styles);

    var recorder_placeholder = $('<div id="'+dom_id+'_recorder_placeholder"></div>');
    recorder_placeholder.css({width: "100%", height: "100%", position: "absolute", top: "0px"});
    container.append(recorder_placeholder);
    
    var player_placeholder = $('<div id="'+dom_id+'_player_placeholder"></div>');
    player_placeholder.css({width: "100%", height: "100%", position: "absolute", top: "0px"});
    container.append(player_placeholder);

    // audio visualization
    if (audio_only) {
      audio_viz = $('<div class="cameratag_audio_viz" style="inset:0px; position:absolute;"></div>');
      container.prepend(audio_viz);
      siriWave = new SiriWave({
        container: audio_viz[0],
        style: "ios9",
        width: 300,
        height: 300,
        cover: true
      });

      // audioCanvas = $('<canvas width="'+width+'" height="'+height+'" style="position:absolute; top:0px; left:0px;"></canvas>');
      // container.prepend(audioCanvas);
      // canvasContext = audioCanvas[0].getContext("2d");  
    }
    

    // communication to and from recorder
    setupExternalInterface();

    // start screen
    start_screen = find_custom_screen("start-screen");

    if (start_screen.length == 0) {
      start_screen = $('<div id="'+dom_id+'_start_screen" class="cameratag_screen cameratag_start"></div>');

      var start_screen_content_container = $('<div class="cameratag_start_screen_content_container"></div>')
      start_screen.append(start_screen_content_container);
      
      if(audio_only) {
        var selection_prompt = $('<a class="cameratag_select_prompt">'+CT_i18n[103]+'</a>');
      } else {
        var selection_prompt = $('<a class="cameratag_select_prompt">'+CT_i18n[4]+'</a>');
      }
      start_screen_content_container.append(selection_prompt);

      var action_container = $('<div></div>')
      start_screen_content_container.append(action_container);

      if (sources.indexOf("record") != -1) {
        if (audio_only) {
          var record_btn = $('<a class="cameratag_primary_link cameratag_record_link cameratag_record"><span class="cameratag_action_icon"><i class="fa fa-microphone" aria-hidden="true"></i></span><br><span class="cameratag_prompt_label">'+CT_i18n[104]+'</span></a>');
          action_container.append(record_btn);  
        } else {
          var record_btn = $('<a class="cameratag_primary_link cameratag_record_link cameratag_record"><span class="cameratag_action_icon"><i class="fa fa-video-camera" aria-hidden="true"></i></span><br><span class="cameratag_prompt_label">'+CT_i18n[5]+'</span></a>');
          action_container.append(record_btn);  
        }
      }
      
      if (sources.indexOf("upload") != -1) {
        var upload_btn = $('<a id="'+dom_id+'_upload_link" class="cameratag_primary_link cameratag_upload_link cameratag_upload"><span class="cameratag_action_icon">&#61678;</span><br><span class="cameratag_prompt_label">'+CT_i18n[6]+'</span></a>');
        action_container.append(upload_btn);
      } 

      if (sources.indexOf("sms") != -1) {
        var sms_btn = $('<a class="cameratag_primary_link cameratag_sms_link cameratag_sms"><span class="cameratag_action_icon">&#61707;</span><br><span class="cameratag_prompt_label">'+CT_i18n[7]+'</span></a>');
        action_container.append(sms_btn);
      }
      
      // settings_btn = $('<i class="cameratag_settings_btn fa fa-cog" src="//cameratag.com/assets/gear.png" style="display:none"></i>');
      // start_screen.append(settings_btn);  
    }
    // add to DOM
    container.append(start_screen);
    // check position
    $(start_screen).css("position", "absolute");


    // mobile start screen
    mobile_start_screen = find_custom_screen("mobile-start-screen")
    if (mobile_start_screen.length == 0) {
      mobile_start_screen = $('<div id="'+dom_id+'_mobile_start_screen" class="cameratag_screen cameratag_mobile_start cameratag_record"></div>');
      
      var selection_prompt = $('<a class="cameratag_mobile_prompt">'+CT_i18n[43]+'</a>');
      mobile_start_screen.append(selection_prompt);

      var sms_btn = $('<a class="cameratag_primary_link"><span class="cameratag_action_icon">&#61707;</span><br><span class="cameratag_prompt_label">'+CT_i18n[44]+'</span></a>');
      mobile_start_screen.append(sms_btn);
    }
    // add to DOM
    container.append(mobile_start_screen);


    // error screen
    error_screen = find_custom_screen("error-screen")
    if (error_screen.length == 0) {
      error_screen = $('<div class="cameratag_screen cameratag_error"></div>');
      error_message = $('<div class="cameratag_error_message"></div>');
      error_screen.append(error_message);
      // var error_settings_btn = $('<img class="cameratag_settings_btn" src="//cameratag.com/assets/gear.png">');
      // error_screen.append(error_settings_btn);
    } else {
      error_message = $(".cameratag_error_message");
    }
    // add to DOM
    container.append(error_screen);


    // paused screen
    paused_screen = find_custom_screen("paused-screen");
    if (paused_screen.length == 0) {
      paused_screen = $('<div class="cameratag_screen cameratag_paused"></div>');
      var paused_msg = $('<div class="cameratag_paused_message">'+CT_i18n[102]+'</div>')
    }
    // add to DOM
    paused_screen.append(paused_msg);
    container.append(paused_screen);


    // upload
    upload_screen = $(container).find(".upload-screen").addClass("cameratag_screen");
    upload_status = upload_screen.find(".cameratag_upload_status");
    if (upload_screen.length == 0) {
      upload_screen = $('<div class="cameratag_screen cameratag_upload"></div>');
      var upload_content = `
        <div class="cameratag_upload_content_container">
          <div class="cameratag_progress_bar">
            <div class="cameratag_progress_fill"></div>
          </div>

          <div>
            <span class="cameratag_upload_message">${CT_i18n[10]}</span><span class="cameratag_upload_status"></span>
          </div>
        </div>
      `
      // var upload_prompt = $('<div class="cameratag_prompt">'+CT_i18n[10]+'</div>');
      // var progress = $('')
      // upload_status = $('');
      upload_screen.append(upload_content);
      // upload_screen.append(upload_status);
      // upload_screen.append(upload_prompt);
    }
    // add to DOM
    container.append(upload_screen);


    // recording screen
    recording_screen = find_custom_screen("recording-screen");
    if (recording_screen.length == 0) {
      recording_screen = $('<div class="cameratag_screen cameratag_recording"></div>');
      var recording_screen_content = `
	  /*
        <div class="cameratag_device_selection_container cameratag_cams">
          <select class="cameratag_camera_options"></select>
        </div>

        <div class="cameratag_device_selection_container cameratag_mics">
          <select class="cameratag_mic_options"></select>
        </div>

        <div class="cameratag_recording_controls stopped">
          <div class="cameratag_user_message">Click the red circle below to start recording</div>
          <div class="cameratag_device_icon cameratag_show_cams"><i class='fa-solid fa-video'></i></div>
                    
          <div class="cameratag_prompt_text"></div>
          
          <div class="cameratag_big_red_container">
            <i class="fa-solid fa-angle-right cameratag_next_prompt"></i>
            <svg
              class="progress-ring-bg"
              height="100%"
              width="100%"
              viewBox="0 0 100 100">
              <circle
                class="progress-ring__circle-bg"
                stroke-width="5"
                fill="transparent"
                r="45"
                cx="50"
                cy="50"
                stroke="rgba(255,255,255,1)"/>
            </svg>

            <svg
              class="progress-ring"
              height="100%"
              width="100%"
              viewBox="0 0 100 100">
              <circle
                class="progress-ring__circle"
                stroke-width="5"
                fill="transparent"
                r="45"
                cx="50"
                cy="50"
                stroke-dasharray="285, 285"
                stroke-dashoffset="280"/>
            </svg>
            <div class="cameratag_big_red"></div>
          </div>
          
          <div class="cameratag_device_icon cameratag_show_mics"><i class='fa-solid fa-microphone'></i></div>
        </div>

        <div class="cameratag_countdown_overlay">
          5
        </div> 
		
		*/   //Tim modified
      `;
      recording_screen.append(recording_screen_content);

      CameraTag.observe(dom_id, "recordingProgress", function(data){
        setRecordingPercentage(data["percent"]);
      })

      // var stop_prompt = $('<div class="cameratag_prompt">'+CT_i18n[11]+'</div>');
      // var recording_meter = $('<div class="cameratag_horizontal_meter cameratag_recording_meter"></div>');
      // record_timer_prompt = $('<span class="cameratag_record_timer_prompt"> ('+ formatted_seconds(maxLength)+')</span>');
      // var recording_indicator = $('<img src="//'+appServer+'/assets/recording.gif"/>');
      // stop_prompt.append(recording_meter).append(record_timer_prompt);
      // recording_screen.append(stop_prompt);
      // recording_screen.append(recording_indicator);
    }
    // add to DOM
    container.append(recording_screen);

    camera_options = recording_screen.find(".cameratag_camera_options");
    mic_options = recording_screen.find(".cameratag_mic_options");

    $(recording_screen).find(".cameratag_big_red").click(function(){
      self.record();
    })

    $(recording_screen).find(".cameratag_next_prompt").click(function(){
      self.next_prompt();
    })

    countdown_overlay = $(recording_screen).find(".cameratag_countdown_overlay");


    $(container).find(".cameratag_show_cams").click(function(){
      self.hideMessage();
      $(".cameratag_cams").toggleClass("visible");
      $(".cameratag_mics").removeClass("visible");
    })

    $(container).find(".cameratag_show_mics").click(function(){
      self.hideMessage();
      $(".cameratag_mics").toggleClass("visible");
      $(".cameratag_cams").removeClass("visible");
    })
  
  
    // play controls
    playback_screen = find_custom_screen("playback-screen");
    if (playback_screen.length == 0) {
      playback_screen = $('<div class="cameratag_screen cameratag_playback"></div>');
      var playback_content = `
        <div class="cameratag_approval_container">
          <div class="cameratag_approval_button cameratag_record">
            <i class="fa-solid fa-thumbs-down"></i>
            ${CT_i18n[14]}
          </div>
          <div class="cameratag_approval_button cameratag_publish">
            <i class="fa-solid fa-thumbs-up"></i>
            ${CT_i18n[13]}
          </div>
        </div>
      `
      playback_screen.append(playback_content);
      // var skip_prompt = $('<div class="cameratag_prompt">'+CT_i18n[12]+'</div>');
      // playback_screen.append(skip_prompt);  
    }
    // add to DOM
    container.append(playback_screen);
    

    // accept controls
    // accept_screen = $("#"+dom_id+"-accept-screen").addClass("cameratag_screen");
    // if (accept_screen.length == 0) {
    //   accept_screen = $('<div class="cameratag_screen cameratag_accept"></div>');
    //   var accept_btn = $('<a class="cameratag_accept_btn cameratag_publish"><span class="button_label"><i class="fa fa-floppy-o" aria-hidden="true"></i> '+CT_i18n[13]+'</span></a>');
    //   var rerecord_btn = $('<a class="cameratag_rerecord_btn cameratag_record"><span class="button_label"><i class="fa fa-times-circle" aria-hidden="true"></i> '+CT_i18n[14]+'</span></a>');
    //   var play_btn = $('<a class="cameratag_play_btn cameratag_play"><span class="button_label"><i class="fa fa-play" aria-hidden="true"></i> '+CT_i18n[15]+'</span></a>');
    //   accept_screen.append(accept_btn);
    //   accept_screen.append(play_btn);
    //   accept_screen.append(rerecord_btn);
    // }
    // // add to DOM
    // container.append(accept_screen);
    

    // wait screen
    wait_screen = find_custom_screen("wait-screen");
    wait_message = wait_screen.find(".cameratag_wait_message");
    if (wait_screen.length == 0) {
      wait_screen = $('<div class="cameratag_screen cameratag_wait"></div>');
      var spinner = $('<div class="cameratag_spinner"><div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div><div class="cameratag_wait_message">'+CT_i18n[16]+'</div></div>');
      wait_screen.append(spinner);
      wait_message = wait_screen.find(".cameratag_wait_message");
    }
    // add to DOM
    container.append(wait_screen);


    // completed screen
    completed_screen = find_custom_screen("completed-screen");
    if (completed_screen.length == 0) {
      completed_screen = $('<div class="cameratag_screen cameratag_completed"></div>');
      thumb_bg = $('<div class="cameratag_thumb_bg"></div>');
      var check_mrk = $('<div class="cameratag_checkmark"><span class="check"><i class="fa fa-check-circle-o" aria-hidden="true"></i></span> '+CT_i18n[17]+'</div>');
      completed_screen.append(thumb_bg);
      completed_screen.append(check_mrk);

    }
    // add to DOM
    container.append(completed_screen);


    // completed screen
    processed_screen = find_custom_screen("processed-screen");
    if (processed_screen.length == 0) {
      processed_screen = $('<div class="cameratag_screen cameratag_processed"></div>');
    }
    // add to DOM
    container.append(processed_screen);


    // sms screen
    sms_screen = find_custom_screen("sms-screen");
    sms_input = sms_screen.find(".cameratag_sms_input");
    if (sms_screen.length == 0) {
      sms_screen = $('<div class="cameratag_screen cameratag_sms_screen"></div>');
      var sms_input_prompt = $('<div class="cameratag_sms_prompt">'+CT_i18n[18]+'<br/></div>');
      sms_input = $('<input id="'+dom_id+'_sms_input" class="cameratag_sms_input" type="text"/>');
      var sms_submit = $('<br/><a href="javascript:" class="cameratag_send_sms">'+CT_i18n[19]+'</a>&nbsp;&nbsp;<a href="javascript:" class="cameratag_goto_start">'+CT_i18n[20]+'</a>');

      sms_input_prompt.append(sms_input);
      sms_input_prompt.append(sms_submit);
      sms_screen.append(sms_input_prompt);
    }

    $(sms_input).intlTelInput({
      onlyCountries: smsCountries,
      defaultCountry: defaultSmsCountry
    });

    // add to DOM
    container.append(sms_screen);


    // check phone screen
    check_phone_screen = find_custom_screen("check-phone-screen");
    var local_prompt = defaultSmsMessage;
    var txt_url = 'https://'+appServer+'/api/v'+CameraTag.version+'/cameras/'+app_uuid+'/videos/'+asset.uuid+'/mobile_record';
    local_prompt = local_prompt.replace("<<uuid>>", asset.uuid);
    local_prompt = local_prompt.replace("<<url>>", txt_url);

    if (check_phone_screen.length == 0) {
      check_phone_screen = $('<div class="cameratag_screen cameratag_check_phone"><div class="cameratag_check_phone_prompt">'+CT_i18n[21]+'</div><div class="cameratag_check_phone_url">'+local_prompt+'</div></div>');
    }
    // add to DOM
    container.append(check_phone_screen);
    

    // hidden inputs
    container.append("<input id='"+input_name+"_uuid' type='hidden' name='"+input_name+"_uuid' value=''>");
    $.each(media_factories, function(index, factory){
      container.append("<input id='"+input_name+"_"+factory.name+"' type='hidden' name='"+input_name+"_"+factory.name+"' value=''>");
    });

    //
    // SETUP ACTION CLASS OBSERVERS
    //

    // device selectors
    if (mic_options ) {
      mic_options.change(function(){
        var mic_id = mic_options.val();
        self.disconnect();
        selected_mic_id = mic_id;
        recorder.setMicrophone(mic_id);
        self.connect();
      }) 
    }

    if (camera_options) {
      camera_options.change(function(){
        var camera_id = camera_options.val();
        self.disconnect();
        selected_cam_id = camera_id;
        recorder.setCamera(camera_id);
        self.connect();
      }) 
    } 

    // CLICKING
    container.find(".cameratag_record").click(function(){self.record()});
    container.find(".cameratag_stop_recording").click(function(){self.stopRecording()});
    container.find(".cameratag_stop_playback").click(function(){self.stopPlayback()});
    container.find(".cameratag_play").click(function(){self.play()});
    container.find(".cameratag_resume").click(function(){self.resumeRecording()});
    container.find(".cameratag_publish").click(function(){self.publish()});
    container.find(".cameratag_goto_start").click(function(){self.loadInterface(start_screen, true);});  
    container.find(".cameratag_send_sms").click(function(){self.send_sms();});
    container.find(".cameratag_sms").click(function(){self.loadInterface(sms_screen);});
    container.find(".cameratag_sms_link").click(function(){self.loadInterface(sms_screen);});
    // container.find(".cameratag_settings_btn").click(function(e){
    //   e.stopPropagation();
    //   self.selectDevices();
    // });
    container.find(".cameratag_save_device_selection").click(function(){
      self.disconnect();
      if (recorder instanceof MobileRecorder) {
        self.loadInterface(mobile_start_screen, true);  
      } else {
        self.loadInterface(start_screen, true);  
      }
    })

    $(camera_el).replaceWith(container);

    if (audio_only) {
      $(".cameratag_show_cams").css({opacity: 0.25});
      $(".cameratag_show_cams").off();
    }
  };

  self.selectDevices = function() {
    // self.connect(function(){
    //   updateDevices();
    //   self.loadInterface(recording_screen);
    // });
  }

  var setRecordingPercentage = function(percent) {
    var circle = document.querySelector('.progress-ring__circle');

    if (circle) {
      var radius = circle.r.baseVal.value;
      var circumference = radius * 2 * Math.PI;

      circle.style.strokeDasharray = `${circumference} ${circumference}`;
      circle.style.strokeDashoffset = `${circumference}`;

      const offset = circumference - percent * circumference;
      circle.style.strokeDashoffset = offset;
    }
  }

  var countdown = function(length, callback) {
    if (paused || throttled) {
      // container.find(".cameratag_screen").hide();
      countdown_timer = setTimeout(function(){
        countdown(length, callback);
      }, 1000);
    }
    else {
      // self.loadInterface(countdown_screen);
      if (countdown_counter >= length) {
        countdown_counter = 0;
        // countdown_screen.hide();
        if (countdown_overlay && length > 0) {
          countdown_overlay.css({opacity: 0.0});
          setTimeout(function(){
            countdown_overlay.css({height: "0px"});  
          }, 750);
        }
        CameraTag.fire(dom_id, "countdownFinished");
        callback();
      }
      else {
        // show countdown
        if (countdown_overlay) {
          countdown_overlay.css({opacity: 1.0});
          countdown_overlay.css({height: "auto"});
          countdown_overlay.html(length - countdown_counter);  
        }
        countdown_counter += 1;
        countdown_timer = setTimeout(function(){
          countdown(length, callback);
        }, 1000);
      }  
    }
  };

  self.loadInterface = function(state_container, alternatives, message) {
    current_screen = state_container;
    container.find(".cameratag_screen").removeClass("visible");

    if (state_container != "none") {
      state_container.addClass("visible");
    }
  };

  var recordTimerTick = function() {
    record_timer_count += 1;
    var max_time_left = maxLength - record_timer_count;
    var min_time_left = minLength - record_timer_count

    // console.log("min left", min_time_left);
    // console.log("max left", max_time_left);

    var percentage = record_timer_count / maxLength;
    setRecordingPercentage(percentage);
    CameraTag.fire(dom_id, "recordingProgress", {time: record_timer_count, percent: percentage});

    $(container).find(".cameratag_message_time_left").html(min_time_left);

    // record_timer_prompt.html( " (" + formatted_seconds(time_left) + ")" );
    if ((max_time_left == 0) && (prompts.length == 0 || (prompts.length > 0 && current_prompt_index == prompts.length - 1))) {
      CameraTag.fire(dom_id, "recordingTimeOut");
      clearInterval(record_timer);
      self.stopRecording();
    } else if (max_time_left == 0) {
      self.next_prompt();
    }
  }

  var specific_record_time = function() {
    if (record_start_time) {
      return ((Date.now() - record_start_time) / 1000);
    } else {
      return 0;
    }
  }

  self.next_prompt = function() {
    if (prompts.length == 0 || current_prompt_index == prompts.length - 1 ) {
      var start_time = (current_prompt_index == 0) ? 0 : prompt_response_times[current_prompt_index - 1].end_time;
      prompt_response_times.push({
        start_time: start_time,
        end_time: specific_record_time(),
        text: prompts[current_prompt_index].text
      })
      self.stopRecording();

    } else if (record_timer_count <= minLength ) {
      var time_left = Math.ceil(minLength - record_timer_count, 0);
      self.flashMessage("please record for at least <span class='cameratag_message_time_left'>"+time_left+"</span> more seconds", time_left*1000)
      console.warn("stopRecording called before minimum length");
    } else {
      var start_time = (current_prompt_index == 0) ? 0 : prompt_response_times[current_prompt_index - 1].end_time;
      prompt_response_times.push({
        start_time: start_time,
        end_time: specific_record_time(),
        text: prompts[current_prompt_index].text
      })

      current_prompt_index += 1;
      maxLength = prompts[current_prompt_index].maxLength;
      minLength = prompts[current_prompt_index].minLength;
      record_timer_count = 0;  
      setRecordingPercentage(0);
      $(container).find(".cameratag_prompt_text").html(prompts[current_prompt_index].text)
    }
  }

  var reset_prompts = function() {
    current_prompt_index = 0;
    if (prompts && prompts.length > 0) {
      $(container).find(".cameratag_prompt_text").html(prompts[current_prompt_index].text)  
    }
  }

  var throw_error = function(message) {
    error_message.html(message);
    self.loadInterface(error_screen, true);
  };

  self.publish = function() {
    if (!readyToPublish) {
      //sendStat("premature_publish");
      throw("Camera not ready to publish. Please wait for the 'readyToPublish' event.");
      return;
    }

    recorder.stopPlayback();
    CameraTag.fire(dom_id, "publishing");
    wait(CT_i18n[38]);
    var asset_type = audio_only ? "Audio" : "Video"
    if (upload_pending_publish) {
      publish_asset({
        original_filename: file_to_upload.name,
        original_url: "https://cameratag-upload.s3.amazonaws.com/recordings/"+asset.uuid+".flv",
        camera_uuid: app_uuid, 
        asset_uuid: asset.uuid, 
        asset_type: asset_type,
        type: "upload", 
        videoServer: videoServer, 
        signature: signature, 
        signature_expiration: signature_expiration, 
        metadata: metadata_object, 
        asset_name: asset_name, 
        asset_description: asset_description,
        prompt_response_times: prompt_response_times
      });
    } else {
      recorder.publish();  
    }
    
  }

  var wait = function(message) {
    message = message || "please wait";
    wait_message.html(message);
    self.loadInterface(wait_screen);
  }

  var populate_hidden_inputs = function() {
    $("#"+input_name+"_uuid").val(asset.uuid);
    $.each(media_factories, function(name, factory){
      var media_url = "//"+appServer+"/assets/"+asset.uuid+"/"+name+"."+factory.extension
      $("#"+input_name+"_"+name).val(media_url);
      asset.medias[name] = media_url;
    });
  };

  self.setMetadata = function(js_object, send_now) {
    send_now = send_now || false;
    if (typeof(js_object) != "object") {
      console.warn("setMetadata only accepts Javascript Objects");
      return;
    }

    // set this for future use
    metadata_object = js_object;

    // send info to server if assets already published
    if (state == "published" || send_now) {
      var json_string = JSON.stringify(js_object);
      var asset_type = audio_only ? "Audio" : "Video"

      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+app_uuid+"/assets/"+asset.uuid+"/metadata.json",
        data:{metadata: json_string, asset_type: asset_type},
        type:"post",
        success: function(response) {
          return true
        },
        error: function(jqXHR, textStatus, errorThrown) {
          throw_error(CT_i18n[35]);
          CameraTag.fire(dom_id, "addDataError", {
            jqXHR: jqXHR,
            textStatus: textStatus,
            errorThrown: errorThrown
          });
          return false;
        }
      })
    } 
  }
  // backwards campatability
  self.addVideoData = self.setMetadata;
  self.setVideoData = self.setMetadata;

  self.reset = function() {
    // start with a clean slate
    clearTimeout(processed_timer);
    clearTimeout(published_timer);
    clearInterval(record_timer);
    clearTimeout(countdown_timer);
    reset_prompts();
    countdown_counter = 0;
    record_timer_count = 0;
    uploading = false;
    error_messages = [];
    readyToPublish = false;
    upload_pending_publish = false;
    // setPublishType();
    if (connected) {
      self.disconnect();  
    }

    // create new asset
    asset = new_asset();

    // observe publishing
    CameraTag.observe(asset.uuid, "published", function(published_asset) {
      if (asset.uuid == published_asset.uuid) {
        state = "published";
        populate_hidden_inputs();
        self.loadInterface(completed_screen);
        if (connected) {
          self.disconnect();
        }
        CameraTag.fire(dom_id, "published", asset);  
        pollForProcessed();
      }
    }, true);

    if (playerOnProcess) {
      CameraTag.observe(asset.uuid, "processed", function(processed_asset) {
        if (asset.uuid == processed_asset.uuid) {
          $(processed_screen).html('<player data-uuid="'+asset.uuid+'" id="'+dom_id+'_player" data-signature="'+signature+'" data-signature-expiration="'+signature_expiration+'"></player>');
          self.loadInterface(processed_screen);
          CameraTag.setup();
        }
      }, true);
    }

    // failed publish
    CameraTag.observe(asset.uuid, "publishFailed", function(error) {
      if (asset.uuid == error.asset_uuid) {
        throw_error(CT_i18n[34] + error.message.error);
      }
    }, true);

    if (!(recorder instanceof MobileRecorder)) {
      recorder.setUUID(asset.uuid);
      recorder.showNothing();  
    }
    container.find("input").val("");
    if (recorder instanceof MobileRecorder) {
      self.loadInterface(mobile_start_screen, true);
    }
    else {
      self.loadInterface(start_screen, true);
    }
    self.showRecorder();
    CameraTag.fire(dom_id, "cameraReset");
  }

  // for legacy support
  self.setLength = function(new_length) {
    self.setMaxLength(new_length)
  }

  self.setMaxLength = function(new_length) {
    maxLength = new_length;
    if (prompts.length > 0) {
      prompts[current_prompt_index].maxLength = new_length;
    }
    // record_timer_prompt.html( "(" + formatted_seconds(new_length) + ")" );
  }

  self.setPrerollLength = function(new_length) {
    preRollLength = new_length;
  }

  self.setSignature = function(new_signature) {
    signature = new_signature;
  }

  self.setSignatureExpiration = function(new_expiration) {
    signature_expiration = new_expiration;
  }

  self.setMinLength = function(new_length) {
    minLength = new_length;
    if (prompts.length > 0) {
      prompts[current_prompt_index].minLength = new_length;
    }
  }


  // publicly accessable methods

  self.send_sms = function() {
    var country_code = $(sms_input).intlTelInput("getSelectedCountryData").dialCode;
    var local_number = $(sms_input).val();
    var complete_number = "+"+country_code+local_number;
    if (local_number == "") {
      alert(CT_i18n[25])
      return;
    }
    wait(CT_i18n[24]);

    // make sure asset data has been added before we ditch
    if (metadata_object) {
      self.setMetadata(metadata_object, true);  
    }
    
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/apps/"+app_uuid+"/videos/"+asset.uuid+"/sms",
      data:{number: complete_number, message: defaultSmsMessage},
      type:"post",
      success: function(response, textStatus, jqXHR) {
        if (response.success) {
          self.loadInterface(check_phone_screen);
          CameraTag.fire(dom_id, "smsSent");  
        }
        else {
          self.loadInterface(sms_screen);
          alert(response.message);
          CameraTag.fire(dom_id, "smsError", {
            jqXHR: jqXHR,
            textStatus: response.message
          });
        } 
      },
      error: function(jqXHR, textStatus, errorThrown) {
        throw_error(CT_i18n[27]);
        CameraTag.fire(dom_id, "smsError", {
          jqXHR: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
        return false;
      }
    })
  }

  
  self.getAsset = function() {
    return asset;
  };

  // backwards compatability
  self.getVideo = self.getAsset;
  self.getAudio = self.getAsset;

  self.restart_upload = function() {
    self.uploader.restart_upload();
  }

  self.destroy = function() {
    clearTimeout(processed_timer);
    clearTimeout(published_timer);
    clearInterval(record_timer);
    clearTimeout(countdown_timer);
    
    countdown_counter = 0;
    record_timer_count = 0;
    uploading = false;
    error_messages = [];
    readyToPublish = false;
    // publishType = webrtc_enabled ? "mediarecorder" : "webcam";

    if (connected) {
      CameraTag.observe(dom_id, "serverDisconnected", self.destroy);
      self.disconnect();

    } else {
      CameraTag.stopObserving(dom_id, "serverDisconnected", self.destroy);
      delete CameraTag.cameras[dom_id];
      container.remove();
      // copy old callbacks to temp then kill them
      if (callbacks[dom_id]["destroyed"]) {
        var destroy_callbacks = callbacks[dom_id]["destroyed"].slice();
      } else {
        var destroy_callbacks = [];
      }
      callbacks[dom_id] = {}
      // run destroy_callbacks callbacks
      if (destroy_callbacks) {
        setTimeout(function(){
          for( i = 0; i < destroy_callbacks.length; i++ ) {
            try {
              destroy_callbacks[i]();
            }
            catch(err) {}
          }  
        }, 750);
      }
    }
  }

  var pollForProcessed = function() {
    if (pollServer) {
      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+app_uuid+"/assets/"+asset.uuid+".json",
        type:"get",
        data: {
          referer: window.location.toString()
        },
        success: function(response, textStatus, jqXHR) {
          if (response.state && response.state == "processed") {
            CameraTag.fire(asset.uuid, "processed", response);
            CameraTag.fire(dom_id, "processed", response);
          } 
          else if (response.state && response.state == "error") {
            CameraTag.fire(asset.uuid, "processingFailed", response);
            CameraTag.fire(dom_id, "processingFailed", response);
          }
          else {
            processed_timer = setTimeout(pollForProcessed, 2000);
          }
        },
        error: function(jqXHR, textStatus, errorThrown) {
          processed_timer = setTimeout(pollForProcessed, 2000);
          CameraTag.fire(dom_id, "processingPollingError", {
            jqXHR: jqXHR,
            textStatus: textStatus,
            errorThrown: errorThrown
          });
        }
      })
    }
  }

  var pollForPublished = function() {
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+app_uuid+"/assets/"+asset.uuid+".json",
      type:"get",
      data: {
        referer: window.location.toString()
      },
      success: function(response) {
        if (response.state == "published" || response.state == "processed") {
          CameraTag.fire(asset.uuid, "published", response);
          clearInterval(published_timer);
        }
        else {
          published_timer = setTimeout(function(){pollForPublished()}, 4000);
        }
      },
      error: function(jqXHR, textStatus, errorThrown) {
        published_timer = setTimeout(function(){pollForPublished()}, 4000);
        CameraTag.fire(dom_id, "publishedPollingError", {
          jqXHR: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
      }
    })
  }

  // these methods require the swf to be in existance and are created after it's available

  var setupExternalInterface = function() {
    // communication to swf
    self.play = function() {
      if (recorder) {
        recorder.startPlayback();
      }
    };

    self.record = function() { // actually calls countdown which will call record_without_countdown in callback
      $(".cameratag_cams").removeClass("visible");
      $(".cameratag_mics").removeClass("visible");

      self.hideMessage();
      
      if (recorder instanceof MobileRecorder) {
        // do nothing here
      }
      else if (recorder && connected) {
        if (prompts.length > 0) {
          maxLength = prompts[current_prompt_index].maxLength;
          minLength = prompts[current_prompt_index].minLength;
        }
        CameraTag.fire(dom_id, "countdownStarted");
        recorder.showRecorder();
        countdown(preRollLength, self.record_without_countdown);
      }
      else {
        recorder.showRecorder();
        self.loadInterface("none");
        self.connect();
      }
    };

    self.showRecorder = function() {
      if (recorder) {
        recorder.showRecorder();
      }
    }

    self.showPlayer = function() {
      if (recorder) {
        recorder.showPlayer(); 
      }
    }

    self.record_without_countdown = function() {
      if (!readyToRecord) {
        //sendStat("premature_record");
        throw("Camera not ready to record. Please observe 'readyToRecord' event before recording");
        return;  
      } else if (recorder) {
        state = "recording";
        recorder.showRecorder();
        recorder.startRecording();
      }
    };

    self.shareScreen = function() {
      recorder.shareScreen();
    };

    self.shareVideo = function() {
      recorder.shareVideo();
    }

    self.getStreamInfo = function() {
      recorder.getStreamInfo(); 
    }

    self.pauseRecording = function() {
      recorder.pauseRecording();
    }

    self.pausePlayback = function() {
      recorder.pausePlayback();
    }

    self.seekPlayback = function(n) {
      recorder.seekPlayback(n);
    }

    self.resumeRecording = function() {
      recorder.resumeRecording()
    }

    self.stopPlayback = function() {
      if (recorder) {
        recorder.stopPlayback();  
      }
    };

    self.stopRecording = function() {
      if (state == "recording") {
        // console.log(prompt_response_times);
        if (record_timer_count >= minLength) {
          clearInterval(record_timer);
          if (recorder && connected) {
            recorder.stopRecording();
            setRecordingPercentage(0);
          }  
        } else {
          var time_left = Math.ceil(minLength - record_timer_count, 0);
          self.flashMessage("please record for at least <span class='cameratag_message_time_left'>"+time_left+"</span> more seconds", time_left*1000-1000)
          console.warn("stopRecording called before minimum length");
        }  
      } else {
        clearTimeout(countdown_timer);
        self.disconnect();
        setRecordingPercentage(0);
        if (recorder instanceof MobileRecorder) {
          self.loadInterface(mobile_start_screen, true);  
        } else {
          self.loadInterface(start_screen, true);  
        }
      }
    };

    self.connect = function(callback) {
      connect_callback = callback || function(){
        if (skipHairCheck) {
          updateDevices();
          self.loadInterface(recording_screen);
          self.record(); //starts countdown    
        } else {
          updateDevices();
          setTimeout(function(){
            if (state != "recording" && state != "counting") {
              self.showMessage("click red button below to start recording");  
            }
          }, 5000)
          self.loadInterface(recording_screen);
        }
      };

      if (recorder) {
        recorder.connect();
      }
    };

    self.disconnect = function() {
      if (recorder) {
        // state = "disconnecting";
        recorder.disconnect();
      }
    };
  }

  var setupEventObservers = function() {
    // communication from swf

    CameraTag.observe(dom_id, "initialized", function() {
      initialized = true;
      state = "initialized";
      if (sources.indexOf("record") != -1 && !(recorder instanceof MobileRecorder)) {
        buildSettingsDialog();  
      }
    }, true);

    CameraTag.observe(dom_id, "throttled", function() {
      throttled_timer = setTimeout(function(){
        throttled = true;
        container.find(".cameratag_screen").hide();
        throttled_screen.show();  
      }, 1500);
    }, true);

    CameraTag.observe(dom_id, "unthrottled", function() {
      clearTimeout(throttled_timer);
      if (throttled) {
        throttled = false;
        throttled_screen.hide();
        self.loadInterface(current_screen);
      }
    }, true);

    CameraTag.observe(dom_id, "connecting", function() {
      wait(CT_i18n[39])
    }, true);

    CameraTag.observe(dom_id, "connecting2", function() {
      wait(CT_i18n[40])
    }, true);

    CameraTag.observe(dom_id, "securityDialogOpen", function() {
      self.loadInterface("none");
    }, true);

    CameraTag.observe(dom_id, "securityDialogClosed", function() {
      self.loadInterface(camera_detection_screen);
    }, true);

    CameraTag.observe(dom_id, "settingsDialogClosed", function() {
      if (recorder instanceof MobileRecorder) {
        self.loadInterface(mobile_start_screen, true);  
      } else {
        self.loadInterface(start_screen, true);  
      }
    }, true);

    CameraTag.observe(dom_id, "detectingCamera", function() {
      self.loadInterface(camera_detection_screen);
    }, true);

    CameraTag.observe(dom_id, "hardwareError", function() {
      throw_error(CT_i18n[99]);
    }, true);

    CameraTag.observe(dom_id, "unsecureContext", function() {
      throw_error(CT_i18n[109]);
    }, true);

    CameraTag.observe(dom_id, "webSocketNotSupported", function() {
      throw_error(CT_i18n[31]);
    }, true);

    CameraTag.observe(dom_id, "hardwareAccessDenied", function() {
      throw_error(CT_i18n[30]);
    }, true);

    CameraTag.observe(dom_id, "unknownError", function(message) {
      throw_error(CT_i18n[111]+" : "+message);
    }, true);

  
    CameraTag.observe(dom_id, "noCamera", function() {
      // self.record = function() {
      //   alert(CT_i18n[28]);
      // }
    }, true);

    CameraTag.observe(dom_id, "noMic", function() {
      self.record = function() {
        alert(CT_i18n[29]);
      }
    }, true);

    CameraTag.observe(dom_id, "readyToRecord", function() {
      readyToRecord = true;
      connect_callback();
    }, true);

    CameraTag.observe(dom_id, "cameraDenied", function() {
      throw_error(CT_i18n[30]);
    }, true);

    CameraTag.observe(dom_id, "serverConnected", function() {
      connected = true;
      startAudioMeter();
    }, true);

    CameraTag.observe(dom_id, "serverDisconnected", function() {
      connected = false;
      // readyToRecord = false;
      // if (state != "disconnecting" && state != "published" && state != "readyToPublish"){
      //   self.stopRecording();
      //   recorder.showNothing();
      //   throw_error(CT_i18n[31]);
      //   setTimeout(function(){
      //     if (recorder instanceof MobileRecorder) {
      //       self.loadInterface(mobile_start_screen, true);  
      //     } else {
      //       self.loadInterface(start_screen, true);  
      //     }
      //   }, 2000);
      //   //sendStat("pre_record_disconnect_error");
      // }
    }, true);

    CameraTag.observe(dom_id, "playbackFailed", function() {
      throw_error(CT_i18n[32]);
      //sendStat("playback_error");
    }, true);

    CameraTag.observe(dom_id, "serverError", function() {
      throw_error(CT_i18n[33]);
      //sendStat("no_server_error");
    }, true);

    CameraTag.observe(dom_id, "waitingForCameraActivity", function() {
      wait(CT_i18n[100]);
    }, true);
    

    CameraTag.observe(dom_id, "countdownStarted", function() {
      state = "counting"
      // self.loadInterface(countdown_screen);
    }, true);

    CameraTag.observe(dom_id, "countdownFinished", function() {
    }, true);

    CameraTag.observe(dom_id, "recordingStarted", function() {
      record_start_time = Date.now();
      record_timer_count = 0;
      record_timer = setInterval(function(){ recordTimerTick() }, 1000);
      // self.loadInterface(recording_screen);
      startAudioMeter();
      container.find(".progress-ring__circle-bg")[0].style.stroke = "rgba(255,255,255,0.1)";
      container.find(".cameratag_recording_controls").removeClass("stopped");
      container.find(".cameratag_recording_controls").addClass("recording");
      if (prompts.length > 0) {
        reset_prompts();
        container.find(".cameratag_recording_controls").addClass("prompt");
      }
      $(recording_screen).find(".cameratag_big_red").unbind();
      $(recording_screen).find(".cameratag_big_red").click(function(){
        self.stopRecording();
      })
    }, true);

    CameraTag.observe(dom_id, "audioLevel", function(level) {
      audioLevel = level;
    }, true);

    CameraTag.observe(dom_id, "recordingPaused", function() {
      clearInterval(record_timer);
      container.find(".cameratag_screen").hide();
      paused_screen.show();
    }, true);

    CameraTag.observe(dom_id, "recordingResumed", function() {
      paused_screen.hide();
      record_timer = setInterval(function(){ recordTimerTick() }, 1000);
      self.loadInterface(recording_screen);
      startAudioMeter();
    }, true);

    CameraTag.observe(dom_id, "recordingStopped", function() {
      // record_timer_prompt.html( " (" + formatted_seconds(maxLength) + ")" );
      if (audio_only) {
        stopAudioMeter();  
      }
      current_prompt_index = 0;

      if (container.find(".progress-ring__circle-bg")[0]) {
        container.find(".progress-ring__circle-bg")[0].style.stroke = "rgba(255,255,255,1)";  
      }
      setTimeout(function(){
        container.find(".cameratag_recording_controls").removeClass("recording");
        container.find(".cameratag_recording_controls").addClass("stopped");
      }, 1500)
      $(recording_screen).find(".cameratag_big_red").unbind();
      $(recording_screen).find(".cameratag_big_red").click(function(){
        self.record();
      })
      clearInterval(record_timer);
    }, true);
    

    CameraTag.observe(dom_id, "bufferingDown", function() {
      wait(CT_i18n[37]);
    }, true);    

    CameraTag.observe(dom_id, "recordingTimeOut", function() {
    }, true);

    CameraTag.observe(dom_id, "playbackStarted", function() {
      self.loadInterface(playback_screen);
      startAudioMeter();
    }, true);

    CameraTag.observe(dom_id, "playbackStopped", function() {
      stopAudioMeter();
      self.loadInterface(accept_screen);
    }, true);

    CameraTag.observe(dom_id, "publishing", function() {
      state = "publishing";
    }, true);

    CameraTag.observe(dom_id, "uploadStarted", function() {
      uploading = true;
      self.loadInterface(upload_screen);
    }, true);

    CameraTag.observe(dom_id, "uploadProgress", function(progress) {
      // upload_status.html((progress * 100).toFixed(1) + "%");
    }, true);

    CameraTag.observe(dom_id, "uploadAborted", function() {
      uploading = false;
    }, true);

    CameraTag.observe(dom_id, "readyToPublish", function() {
      readyToPublish = true;
      state = "readyToPublish";
    }, true);

    CameraTag.observe(dom_id, "smsSent", function() {
      pollForPublished();
    }, true);

    CameraTag.observe(dom_id, "published", function() {
    }, true);

    CameraTag.observe(dom_id, "publishFailed", function(data) {
      throw_error(CT_i18n[34]);
      //sendStat("publish_error", data);
    }, true);

    CameraTag.observe(dom_id, "processed", function() {
      state = "processed";
      for (var key in media_factories) {
        if (media_factories[key].media_type == "thumb") {
          $(container).find(".cameratag_thumb_bg").css({backgroundImage: "url(//"+appServer+"/assets/"+asset.uuid+"/"+media_factories[key].name+"."+media_factories[key].extension+")"});
          break;
        }
      }
    }, true);
  }

  setup();
}
// end of CameraTag Recorder
    //
// Player
//
CameraTagPlayer = function(video_el, opts) {
  opts = opts || {};
  var cachebuster = parseInt( Math.random() * 100000000 );
  var video_el = $(video_el);
  var new_video_tag;
  var jwplayerInjected = false;
  var uuids;
  var self = this;
  
  
  // if (video_el.attr("data-uuid") != "" && video_el.attr("data-uuid")[0] == "[") {
  //   uuids = eval(video_el.attr("data-uuid"));
  // } else if (video_el.attr("data-uuid") != "" && video_el.attr("data-uuid").indexOf(",") != -1) {
  //   uuids = video_el.attr("data-uuid").replace(" ", "").split(",");
  // } else if (video_el.attr("data-uuid") != "") {
  //   uuids = [ video_el.attr("data-uuid") ]
  // } else {  
  //   alert("no video uuids found")
  // }

  var default_options = {};

  var largest_source_width = 0;
  var largest_source_height = 0;
  var height;
  var width;
  var jw_player_instance;
  var user_options = {};
  var playlist;
  var dom_id;
  var signature;
  var signature_expiration
  var enable_download;

  var container;
  var playbar_frame;
  var playbar_cover;
  var jw_target;

  var setup = function(){

    build_default_options();
    // $.extend(default_options, opts);

    // parse any options that were passed in
    if (video_el.attr("data-options")) {
      user_options = JSON.parse( video_el.attr("data-options") );  
    }
    else {
      user_options = {}
    }

    // build playlist 
    build_playlist_array(uuids);
  }

  var build_default_options = function() {
    //
    // GENERATED FROM SCHEMA
    //
      default_options["id"] = opts["id"] || $(video_el).attr("data-id") || $(video_el).attr("") || "myPlayer";


      default_options["assets"] = opts["assets"] || $(video_el).attr("data-assets") || $(video_el).attr("data-uuid") || [];

        // make sure assets is an array
        if (typeof(default_options["assets"]) == "string") {
          try {
            default_options["assets"] = JSON.parse(default_options["assets"]);
          } catch {
            console.log("assets could not be parsed as an Array")
            default_options["assets"] = [ default_options["assets"] ];
          }
        }

      default_options["aspectratio"] = opts["aspectratio"] || $(video_el).attr("data-aspectratio") || $(video_el).attr("") || "automatic";


      default_options["width"] = opts["width"] || $(video_el).attr("data-width") || $(video_el).attr("") || null;


      default_options["height"] = opts["height"] || $(video_el).attr("data-height") || $(video_el).attr("") || null;


      default_options["autostart"] = opts["autostart"] || $(video_el).attr("data-autostart") || $(video_el).attr("") || false;


      default_options["controls"] = opts["controls"] || $(video_el).attr("data-controls") || $(video_el).attr("") || true;


      default_options["displaytitle"] = opts["displaytitle"] || $(video_el).attr("data-displaytitle") || $(video_el).attr("") || true;


      default_options["displaydescription"] = opts["displaydescription"] || $(video_el).attr("data-displaydescription") || $(video_el).attr("") || true;


      default_options["mute"] = opts["mute"] || $(video_el).attr("data-mute") || $(video_el).attr("") || false;


      default_options["repeat"] = opts["repeat"] || $(video_el).attr("data-repeat") || $(video_el).attr("") || false;


      default_options["image"] = opts["image"] || $(video_el).attr("data-image") || $(video_el).attr("") || null;


      default_options["sharing-link"] = opts["sharing-link"] || $(video_el).attr("data-sharing-link") || $(video_el).attr("") || null;


      default_options["sharing-embed"] = opts["sharing-embed"] || $(video_el).attr("data-sharing-embed") || $(video_el).attr("") || null;


      default_options["sharing-heading"] = opts["sharing-heading"] || $(video_el).attr("data-sharing-heading") || $(video_el).attr("") || "Share Asset";


      default_options["stretching"] = opts["stretching"] || $(video_el).attr("data-stretching") || $(video_el).attr("") || "uniform";


      default_options["download"] = opts["download"] || $(video_el).attr("data-download") || $(video_el).attr("") || false;



    // backwards compatablity 
    default_options["skin"] = "glow";
    dom_id = default_options["id"];
    signature = default_options["signature"];
    signature_expiration = default_options["signature_expiration"];
    enable_download = default_options["download"];
    uuids = default_options["assets"];
    if ($(video_el).attr("data-show-captions") == "false") {
      default_captions = false;
    } else {
      default_captions = true;
    }


    // OLD STUFF

    // if ($(video_el).attr("data-aspectratio")) {
    //   default_options["aspectratio"] = $(video_el).attr("data-aspectratio");
    // }

    // if ($(video_el).attr("data-image")) {
    //   default_options["image"] = $(video_el).attr("data-image");
    // }

    // if ($(video_el).attr("data-autostart")) {
    //   default_options["autostart"] = ($(video_el).attr("data-autostart") == "true");
    // }

    // if ($(video_el).attr("data-controls")) {
    //   default_options["controls"] = ($(video_el).attr("data-controls") == "true");
    // }

    // if ($(video_el).attr("data-displaytitle")) {
    //   default_options["displaytitle"] = ($(video_el).attr("data-displaytitle") == "true");
    // }

    // if ($(video_el).attr("data-displaydescription")) {
    //   default_options["displaydescription"] = ($(video_el).attr("data-displaydescription") == "true");
    // }

    // if ($(video_el).attr("data-mute")) {
    //   default_options["mute"] = ($(video_el).attr("data-mute") == "true");
    // }

    // if ($(video_el).attr("data-repeat")) {
    //   default_options["repeat"] = ($(video_el).attr("data-repeat") == "true");
    // }

    // if ($(video_el).attr("data-primary")) {
    //   default_options["primary"] = ($(video_el).attr("data-primary") == "true");
    // }

    // if ($(video_el).attr("data-stretching")) {
    //   default_options["stretching"] = ($(video_el).attr("data-stretching") == "true");
    // }

    // if ($(video_el).attr("data-sharing-link") || $(video_el).attr("data-sharing-heading") || $(video_el).attr("data-sharing-link")) {
    //   default_options["sharing"] = {};
    //   default_options["link"] = $(video_el).attr("data-sharing-link");
    //   default_options["code"] = $(video_el).attr("data-sharing-embed");
    //   default_options["heading"] = $(video_el).attr("data-sharing-heading");
    // }
  }


  var buildInterface = function() {
    container = $('<div id="'+dom_id+'" class="cameratag"></div>');
    jw_target = $('<div id="'+dom_id+'_jw_target"></div>');
    container.append(jw_target);
    $(video_el).replaceWith(container);

    // set appropriate size
    if (default_options["aspectratio"] && default_options["aspectratio"] != "automatic") {
      // let jw do the calculations
    } else {
      var largest_aspect = width / height;

      // if its wider scale height to 300
      if (largest_aspect > 1.3 && height < 300) {
        var scale_multiplier = 300 / height;
        height = 300;
        width = parseInt(width * scale_multiplier);
      } 

      // if it's wider scale height to 300
      if (largest_aspect < 1.3 && width < 400) {
        var scale_multiplier = 400 / width;
        width = 400;
        height = parseInt(height * scale_multiplier);
      }
    }

    init_jwplayer();

    playbar_frame = $('<div id="'+dom_id+'_playbar_frame" class="cameratag_audio_playbar_frame"></div>');

    playbar_waveform_container = $('<div id="'+dom_id+'_playbar_wavform_container" class="cameratag_audio_playbar_wavform_container"></div>');
    playbar_waveform = $('<img id="'+dom_id+'_playbar_waveform" class="cameratag_audio_playbar_waveform"></img>');
    
    playbar_waveform_container.append(playbar_waveform);

    playbar_cover = $('<div id="'+dom_id+'_playbar_cover" class="cameratag_audio_playbar_cover"></div>');
    playbar_frame.append(playbar_waveform_container).append(playbar_cover);
  }


  var create_audio_playlist_item = function(audio, index) {
    var playlist_item = {}

    // poster
    // var waveform_url = audio.waveform_url+"?signature="+signature+"&signature_expiration="+signature_expiration;
    // playlist_item["image"] = ($(video_el).attr("data-image") || waveform_url);

    var negative_waveform_url = audio.negative_waveform_url+"?signature="+signature+"&signature_expiration="+signature_expiration;
    playlist_item["negative_image"] = negative_waveform_url;
    
    // sources
    playlist_item["sources"] = []
    playlist_item["sources"].push({
      file: audio.mp3_url+"?signature="+signature+"&signature_expiration="+signature_expiration,
      label: "MP3"
    })
    
    // captions
    playlist_item["tracks"] = []
    $.each(audio.medias, function(name, media){
      if (media.media_type == "caption" && media.state == "COMPLETED") {
        playlist_item["tracks"].push({
          file: media.urls[Object.keys(media.urls)[0]],
          kind: "captions",
          label: media.name
        })
        playlist_item["default"] = default_captions;
      }
    })

    // chapters
    // playlist_item["tracks"] = [
    //   {
    //     file:'/chapters.vtt',
    //     kind:'chapters'
    //   }
    // ];
      
    // basic data
    playlist_item["uuid"] = audio.uuid;
    playlist_item["type"] = audio.type;
    playlist_item["app_uuid"] = audio.app_uuid;

    // name and description
    playlist_item["title"] = audio.name || audio.uuid;
    playlist_item["description"] = audio.description;

    // ad servers
    if (playlist.length == 0) {
      playlist_item["ad_server_type"] = audio.ad_server_type;
      playlist_item["ad_server_url"] = audio.ad_server_url;  
    }

    // length
    playlist_item["length"] = audio.length;

    // sizes
    if (largest_source_width < 640) {
      largest_source_width = 640;  
    }

    if (largest_source_height < 120) {
      largest_source_height = 300;
    }


    // add the playlist item to the playlist
    playlist[index] = playlist_item;
  }

  var sec2time = function(timeInSeconds) {
    var pad = function(num, size) { return ('000' + num).slice(size * -1); },
    time = parseFloat(timeInSeconds).toFixed(3),
    hours = Math.floor(time / 60 / 60),
    minutes = Math.floor(time / 60) % 60,
    seconds = Math.floor(time - minutes * 60),
    milliseconds = time.slice(-3);
    return pad(hours, 2) + ':' + pad(minutes, 2) + ':' + pad(seconds, 2) + '.' + pad(milliseconds, 3);
  }

  var paramsToVTT = function(params){
    var vtt = "WEBVTT"
    $(params).each(function(index, param){
      vtt += "\n\n"
      vtt += "Chapter "+(index + 1)+"\n";
      vtt += sec2time(param.start_time) + " --> " + sec2time(param.end_time) + "\n";
      vtt += param.text
    })
    return vtt
  }

  var create_video_playlist_item = function(video, index) {
    var playlist_item = {}

    // get medias
    var thumbnail_medias = [];
    for (var key in video.medias) {
      if (video.medias[key].media_type == "thumb" || video.medias[key].media_type == "small_thumb") {
        thumbnail_medias.push(video.medias[key]);
      }
    }
    var mp4_medias = [];
    for (var key in video.medias) {
      if (video.medias[key].media_type == "mp4") {
        mp4_medias.push(video.medias[key]);
      }
    }
                
    // poster
    if (thumbnail_medias.length > 0) {
      var thumbnail_url = thumbnail_medias[0].urls["cameratag"]+"?signature="+signature+"&signature_expiration="+signature_expiration;
      playlist_item["image"] = ($(video_el).attr("data-image") || thumbnail_url);
    }
    
    // sources
    playlist_item["sources"] = []
    $(mp4_medias).each(function(index, media){
      var source = media.urls["cameratag"]+"?signature="+signature+"&signature_expiration="+signature_expiration;
      playlist_item["sources"].push({
        file: source,
        label: (media.width + "x" + media.height)
      })
    })


    // captions
    playlist_item["tracks"] = []
    $.each(video.medias, function(name, media){
      if (media.media_type == "caption" && media.state == "COMPLETED") {
        playlist_item["tracks"].push({
          file: media.urls[Object.keys(media.urls)[0]],
          kind: "captions",
          label: media.name,
          default: true
        })
      }
    })

    //chapters
    playlist_item["tracks"].push({
      file:'data:text/vtt,'+encodeURIComponent(paramsToVTT(video.params)),
      kind:'chapters'
    });

    // video thumbs
    playlist_item["tracks"].push({
      file: "//"+appServer+"/api/v"+CameraTag.version+"/apps/"+video.app_uuid+"/assets/"+video.uuid+"/thumbnails.vtt",
      kind: "thumbnails"
    })
      
    // size
    playlist_item["height"] = mp4_medias[0].height;
    playlist_item["width"] = mp4_medias[0].width;

    // basic data
    playlist_item["uuid"] = video.uuid;
    playlist_item["type"] = video.type;
    playlist_item["app_uuid"] = video.app_uuid;

    // name and description
    playlist_item["title"] = video.name || video.uuid;
    playlist_item["description"] = video.description;

    // ad servers
    playlist_item["ad_server_type"] = video.ad_server_type;
    playlist_item["ad_server_url"] = video.ad_server_url


    // set width and height
    var source_width = mp4_medias[0].width;
    var source_height = mp4_medias[0].height;

    // sizes
    if (largest_source_width < source_width) {
      largest_source_width = source_width;  
    }

    if (largest_source_height < source_height) {
      largest_source_height = source_height;  
    }

    // add the playlist item to the playlist
    playlist[index] = playlist_item;

  }




  var build_playlist_array = function(uuids) {
    playlist = []
    $(uuids).each(function(index, uuid){
      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/assets/"+uuid+".json?signature="+signature+"&signature_expiration="+signature_expiration,
        type:"get",
        data: {
          referer: window.location.toString()
        },
        success: function(asset) {
          
          if (asset.success == false) {
            create_error_playlist_item()
            return;
          }

          // parse the response data if it exists
          if (asset.params) {
            try {
              asset.params = JSON.parse(asset.params)
            } catch {
              asset.params = []
            }
          }

          if (asset.type == "Audio") {
            create_audio_playlist_item(asset, index)
          } 
          if (asset.type == "Video") {
            create_video_playlist_item(asset, index)
          }

          if (asset.state == "published" || asset.state == "error") {
            CameraTag.fire(dom_id, "unprocessedmedia", {uuid: asset.uuid});
          }

          // set heght and width
          width = default_options["width"] || largest_source_width / 2;
          if (default_options["aspectratio"] && default_options["aspectratio"] != "automatic") {
            height = default_options["height"];
          } else {
            height = default_options["height"] || largest_source_height / 2;  
          }

          if (playlist.length == uuids.length) {
            buildInterface();
          }
          
        },
        error: function() {
          create_error_playlist_item()
          return;
        }
      });
    });
  }

  var create_error_playlist_item = function() {
    playlist.push({
      image: "https://www.cameratag.com/error2.png",
      sources: [
        { file: "https://cameratag.com/videos/v-673733c6-5c55-4d41-88d3-66f8e4bc48fe/720p/mp4.mp4" }
      ],
      uuid: "fetch_error"
    })

    width = 531;
    height = 300;

    if (playlist.length == uuids.length) {
      buildInterface()
    }

    CameraTag.fire(dom_id, "loaderror", {});

    return;
  }

  var get_ad_server_url = function() {
    var ad_server_url;
    $(playlist).each(function(index, playlist_el){
      if (playlist_el.ad_server_url) {
        ad_server_url = playlist_el.ad_server_url;
        return ad_server_url;
      }
    })
    return ad_server_url
  }

  var get_ad_server_type = function() {
    var ad_server_type;
    $(playlist).each(function(index, playlist_el){
      if (playlist_el.ad_server_type) {
        ad_server_type = playlist_el.ad_server_type;
        return ad_server_type;
      }
    })
    return ad_server_type
  }

  var init_jwplayer = function() {
    jwplayer.key="ziVL9s0pxpESKa4mUW9KADbRrkb59LC2qGEI9Q==";

    default_options["playlist"] = playlist;
    default_options["width"] = width;
    default_options["height"] = height;

    var ad_server_type = get_ad_server_type();
    var ad_server_url = get_ad_server_url();
    
    if (ad_server_url) {
      default_options["advertising"] = {};
      default_options["advertising"]["client"] = ad_server_type;
      default_options["advertising"]["tag"] = ad_server_url;
    }

    combined_options = $.extend({}, default_options, user_options);

    container.css({width: combined_options["width"], height: combined_options["height"]})

    jw_player_instance = jwplayer(dom_id+"_jw_target").setup( combined_options );

    if (enable_download == "true") {
      jw_player_instance.addButton(
        //This portion is what designates the graphic used for the button
        "https://www.cameratag.com/static/14/download.svg",
        //This portion determines the text that appears as a tooltip
        "Download Video",
        //This portion designates the functionality of the button itself
        function() {
          // With the below code, we're grabbing the file that's currently playing
          window.location.href = jw_player_instance.getPlaylistItem()['file'];
        },
        //And finally, here we set the unique ID of the button itself.
        "download"
      );
    }

    CameraTag.players[dom_id] = jw_player_instance;

    setup_player_events();
  }

  var setup_player_events = function() {
    // test events
    var position_interval;

    function setPositionAndDuration(position, duration) {
      var position = jw_player_instance.getPosition();
      var duration = jw_player_instance.getDuration();

      if (duration > 0) {
        // invert cause we're revealing from right
        var percent = position / duration * 100;
        var percent = 100 - percent;
        var remaining = duration - position;

        playbar_cover[0].style.transitionDuration = "0s";
        playbar_cover.css({width: percent+"%"});

        setTimeout(function(){
          playbar_cover[0].style.transitionDuration = (remaining - 0.2)+"s";
          playbar_cover.css({width: 0+"%"});   
        }, 100);
        
      } else {
        setTimeout(function(){
          setPositionAndDuration(position, duration);
        }, 100);
      }
    }

    jw_player_instance.on("ready", function(){
      container.find(".jw-preview").append(playbar_frame);
    })

    jw_player_instance.on("play", function(){
      setPositionAndDuration();

      var playlist_item = jw_player_instance.getPlaylistItem();
      if (playlist_item.type == "Audio") {
        playbar_frame.css({visibility: "visible"});
        playbar_waveform.attr("src",playlist_item.negative_image);  
      } else {
        playbar_frame.css({visibility: "hidden"});
      }
    })

    jw_player_instance.on("pause", function(){
      var position = jw_player_instance.getPosition();
      var duration = jw_player_instance.getDuration();
      var percent = position / duration * 100;
      var percent = 100 - percent;

      playbar_cover[0].style.transitionDuration = "0s";
      playbar_cover.css({width: percent+"%"});
    })

    jw_player_instance.on("complete", function(){
      playbar_cover[0].style.transitionDuration = "0s";
      playbar_cover.css({width: "100%"});
    })

    jw_player_instance.on("seek", function(properties){
      setTimeout(function(){
        setPositionAndDuration();
      }, 100);
    })

    jw_player_instance.on('playlistItem', function(properties){
    })

    // jw_player_instance.on('ready', function(index, playlist_item){
    //   console.log("ready");
    //   playbar_waveform.css({backgroundImage: "url(//"+BUCKET_NAME+"/63f9c870-72c4-0130-04c5-123139045d73/au-f179094a-629c-476b-a77f-2b38730d9ea4_waveform.png)"})
    // })
    
    jw_player_instance.on("ready", function(){
      CameraTag.fire(dom_id, "ready", {});
    })
    jw_player_instance.on("setupError", function(fallback, message){
      CameraTag.fire(dom_id, "setupError", {fallback: fallback, message: message});
    })
    jw_player_instance.on("playlist", function(playlist){
      CameraTag.fire(dom_id, "playlist", {playlist: playlist});
    })
    jw_player_instance.on("playlistItem", function(index, playlist){
      CameraTag.fire(dom_id, "playlistItem", {index: index, playlist: playlist});
    })
    jw_player_instance.on("playlistComplete", function(){
      CameraTag.fire(dom_id, "playlistComplete", {});
    })
    jw_player_instance.on("bufferChange", function(buffer){
      CameraTag.fire(dom_id, "bufferChange", {buffer: buffer});
    })
    jw_player_instance.on("play", function(){
      CameraTag.fire(dom_id, "play", {});

      // if (allow_play_count) {
      //   $.ajax({
      //     url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+jw_player_instance.getPlaylistItem().app_uuid+"/assets/"+jw_player_instance.getPlaylistItem().uuid+"/play_count",
      //     type:"post",
      //     success: function() {
      //       // no need
      //     }
      //   })

      //   // hack for double callbacks
      //   allow_play_count = false;
      //   setTimeout(function(){
      //     allow_play_count = true;
      //   }, 3000)
      // }
      
    })
    jw_player_instance.on('pause', function(oldstate){
      CameraTag.fire(dom_id, "pause", {oldstate: oldstate});
    })
    jw_player_instance.on('buffer', function(){
      CameraTag.fire(dom_id, "buffer", {});
    })
    jw_player_instance.on('idle', function(){
      CameraTag.fire(dom_id, "idle", {});
    })
    jw_player_instance.on('complete', function(){
      CameraTag.fire(dom_id, "complete", {});
    })
    jw_player_instance.on('error', function(message){
      CameraTag.fire(dom_id, "error", {message: message});
    })
    jw_player_instance.on('seek', function(position, offset){
      CameraTag.fire(dom_id, "seek", {position: position, offset: offset});
    })
    jw_player_instance.on('Time', function(duration, position){
      CameraTag.fire(dom_id, "time", {duration: duration, position: position});
    })
    jw_player_instance.on('mute', function(muted){
      CameraTag.fire(dom_id, "mute", {muted: muted});
    })
    jw_player_instance.on('volume', function(volume){
      CameraTag.fire(dom_id, "volume", {volume: volume});
    })
    jw_player_instance.on('Fullscreen', function(fullscreen){
      CameraTag.fire(dom_id, "fullscreen", {fullscreen: fullscreen});
    })
    jw_player_instance.on("resize", function(width, height){
      CameraTag.fire(dom_id, "resize", {width: width, height: height});
    })
    jw_player_instance.on('qualityLevels', function(levels){
      CameraTag.fire(dom_id, "qualityLevels", {levels: levels});
    })
    jw_player_instance.on("qualityChange", function(currentQuality){
      CameraTag.fire(dom_id, "qualityChange", {currentQuality: currentQuality});
    })
    jw_player_instance.on('captionsList', function(tracks){
      CameraTag.fire(dom_id, "captionsList", {tracks: tracks});
    })
    jw_player_instance.on("captionsChange", function(track){
      CameraTag.fire(dom_id, "captionsChange", {track: track});
    })
    jw_player_instance.on("controls", function(controls){
      CameraTag.fire(dom_id, "controls", {controls: controls});
    })
    jw_player_instance.on("displayClick", function(){
      CameraTag.fire(dom_id, "displayClick", {});
    })
    jw_player_instance.on("adClick", function(tag){
      CameraTag.fire(dom_id, "adClick", {tag: tag});
    })
    jw_player_instance.on("adCompanions", function(tag, companions){
      CameraTag.fire(dom_id, "adCompanions", {tag: tag, companions: companions});
    })
    jw_player_instance.on("adComplete", function(tag){
      CameraTag.fire(dom_id, "adComplete", {tag: tag});
    })
    jw_player_instance.on("adSkipped", function(tag){
      CameraTag.fire(dom_id, "adSkipped", {tag: tag});
    })
    jw_player_instance.on("adError", function(tag, message){
      CameraTag.fire(dom_id, "adError", {tag: tag, message: message});
    })
    jw_player_instance.on("adImpression", function(tag){
      CameraTag.fire(dom_id, "adImpression", {tag: tag});
    })
    jw_player_instance.on('AdTime', function(tag, position, duration){
      CameraTag.fire(dom_id, "adTime", {tag: tag, position: position, duration: duration});
    })
    jw_player_instance.on("BeforePlay", function(){
      CameraTag.fire(dom_id, "beforePlay", {});
    })
    jw_player_instance.on("beforeComplete" ,function(){
      CameraTag.fire(dom_id, "beforeComplete", {});
    })
    jw_player_instance.on("metadata", function(metadata){
      CameraTag.fire(dom_id, "metadata", {metadata: metadata});
    })
  }

  setup();
}
// end of CameraTagPlayer
    CameraTagVideoWall = function(wall_el, opts) {
  opts = opts || {};

  var self = this;
  var assets = [];
  var page_count;
  var current_page = 1;


  //
  // GENERATED FROM SCHEMA
  //
    var id = opts["id"] || $(wall_el).attr("data-id") || $(wall_el).attr("") || "myWall";


    var perPage = opts["perPage"] || $(wall_el).attr("data-perPage") || $(wall_el).attr("") || 30;


    var topPagination = opts["topPagination"] || $(wall_el).attr("data-topPagination") || $(wall_el).attr("") || false;


    var bottomPagination = opts["bottomPagination"] || $(wall_el).attr("data-bottomPagination") || $(wall_el).attr("") || true;


    var thumbnailHeight = opts["thumbnailHeight"] || $(wall_el).attr("data-thumbnailHeight") || $(wall_el).attr("") || 250;


    var openLightbox = opts["openLightbox"] || $(wall_el).attr("data-openLightbox") || $(wall_el).attr("") || true;


    var includeName = opts["includeName"] || $(wall_el).attr("data-includeName") || $(wall_el).attr("") || false;


    var includeDescription = opts["includeDescription"] || $(wall_el).attr("data-includeDescription") || $(wall_el).attr("") || false;


    var signature = opts["signature"] || $(wall_el).attr("data-signature") || $(wall_el).attr("data-signature") || "";


    var signatureExpiration = opts["signatureExpiration"] || $(wall_el).attr("data-signatureExpiration") || $(wall_el).attr("data-signature-expiration") || "";



  //
  // END FORM SCHEMA VARS
  //

  // backwardxs compatability
  var camera_uuid = $(wall_el).attr("data-appId") || $(wall_el).attr("data-uuid") || $(wall_el).attr("data-app-id") || $(wall_el).attr("id");
  var dom_id = $(wall_el).attr("id") || cachebuster;
  var expiration = signatureExpiration;
  var targetHeight = thumbnailHeight;
  var start_time = opts["start_time"] == null ? start_time : opts["start_time"];
  var end_time = opts["end_time"] == null ? end_time : opts["end_time"];

  // user definable parameters
  // var camera_uuid = $(wall_el).attr("data-app-id");
  // var dom_id = $(wall_el).attr("id");
  // var perPage = $(wall_el).attr("data-per-page");
  // var includeName = $(wall_el).attr("data-include-name") == "true" ? true : false;
  // var includeDescription = $(wall_el).attr("data-include-description") == "true" ? true : false;
  // var openLightbox = $(wall_el).attr("data-open-lightbox") == "false" ? false : true;
  // var targetHeight = $(wall_el).attr("data-thumbnail-height") || 250;
  // var topPagination = $(wall_el).attr("data-show-top-pagnation") == "true";
  // var bottomPagination = $(wall_el).attr("data-show-bottom-pagnation") != "false";
  // var signature = $(wall_el).attr("data-signature");
  // var expiration = $(wall_el).attr("data-signature-expiration");
  // var start_time = $(wall_el).attr("data-start-time");
  // var end_time = $(wall_el).attr("data-end-time");

  // camera_uuid = opts["camera_uuid"] == null ? camera_uuid : opts["camera_uuid"];
  // dom_id = opts["dom_id"] == null ? dom_id : opts["dom_id"];
  // perPage = opts["perPage"] == null ? perPage : opts["perPage"];
  // includeName = opts["includeName"] == null ? includeName : opts["includeName"];
  // includeDescription = opts["includeDescription"] == null ? includeDescription : opts["includeDescription"];
  // openLightbox = opts["openLightbox"] == null ? openLightbox : opts["openLightbox"];
  // targetHeight = opts["targetHeight"] == null ? targetHeight : opts["targetHeight"];
  // topPagination = opts["topPagination"] == null ? topPagination : opts["topPagination"];
  // bottomPagination = opts["bottomPagination"] == null ? bottomPagination : opts["bottomPagination"];
  // signature = opts["signature"] == null ? signature : opts["signature"];
  // expiration = opts["expiration"] == null ? expiration : opts["expiration"];
  // start_time = opts["start_time"] == null ? start_time : opts["start_time"];
  // end_time = opts["end_time"] == null ? end_time : opts["end_time"];
  
  // interface elements
  var container = $('<div id="'+dom_id+'" class="camera_tag_video_wall"></div>');
  var lb_overlay = $('<div class="cameratag_lb_overlay"></div>');
  var lb_body = $('<div class="cameratag_lb_body"></div>');
  var lb_wrapper = $('<div class="cameratag_video_wrapper"></div>');


  var setup = function(){
    // replace vw el
    $(wall_el).replaceWith(container);

    CameraTag.observe(dom_id, "noAssets", function(){
      console.warn("We couldn't find any assets for your VideoWall '"+dom_id+"'. Have you setup your CameraTag App's security settings to allow wall access?")
    })

    $("body").append(lb_overlay);
    $(lb_overlay).click(self.closeVideo);
    
    $("body").append(lb_body);
    $(lb_body).append(lb_wrapper);

    self.loadPage();

    CameraTag.video_walls[dom_id] = self;
  }

  self.loadPage = function(page_no) {
    page_no = page_no || current_page
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+camera_uuid+"/assets/wall.json?page="+page_no+"&start_time="+start_time+"&end_time="+end_time,
      type: "get",
      data: {
        n: perPage
      },
      success: function(response) {
        if (typeof(response) == "object" && response.assets && response.assets.length > 0) {
          assets = response.assets;
          // page_count = response.total_pages;
          current_page = page_no;
          drawAssets();
        } else {
          CameraTag.fire(dom_id, "noAssets");
        }
      },
      error: function(jqXHR, textStatus, errorThrown) {
        CameraTag.fire(dom_id, "serverError", {
          jqXHR: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
      }
    })
  }

  var drawAssets = function() {
    $(container).html("");
    
    
    // if (page_count > 1 && topPagination) {
    if (topPagination) {
      drawPagination();
    }

    $(assets).each(function(index, asset){
      var thumbnail_medias = [];
      var filmstrip_medias = [];
      for (var key in asset.medias) {
        if (asset.medias[key].state == "COMPLETED" && (asset.medias[key].media_type == "photo" || asset.medias[key].media_type == "thumb" || asset.medias[key].media_type == "small_thumb")) {
          thumbnail_medias.push(asset.medias[key]);
        }
        if (asset.medias[key].state == "COMPLETED" && (asset.medias[key].media_type == "filmstrip")) {
          filmstrip_medias.push(asset.medias[key]);
        }
      }

      if (thumbnail_medias.length > 0) {
        var width = thumbnail_medias[0].width;
        var height = thumbnail_medias[0].height;
      } else {
        var width = 640;
        var height = 480;
      }
      // create the elements
      var asset_el = $('<div id="'+dom_id+'_'+asset.uuid+'" class="cameratag_video_container"></div>');
     
      var thumbnail_el_str = '<div class="cameratag_smart_thumb" style="background:url('+asset.preview_thumbnail_url+'?signature='+signature+'&signature_expiration='+expiration+') center center / contain no-repeat rgb(255, 255, 255)" data-width="'+width+'" data-height="'+height+'"'
      if (filmstrip_medias.length > 0) {
        thumbnail_el_str += 'data-strip-url="'+filmstrip_medias[0].urls["cameratag"]+'"';
        thumbnail_el_str += 'data-frame-count="30"';
      }
      thumbnail_el_str += '></div>'
      thumbnail_el = $(thumbnail_el_str);
      
      var name_el = $('<div class="cameratag_video_name">'+asset.name+'</div>');
      var description_el = $('<div class="cameratag_video_description">'+asset.description+'</div>');

      // assmble it all
      $(asset_el).append(thumbnail_el);
      if (includeName) {
        $(asset_el).append(name_el);
      }
      if (includeDescription) {
        $(asset_el).append(description_el);
      }

      $(container).append(asset_el);
      if (openLightbox) {
        $(asset_el).click(function(){
          openAsset(asset);
        })  
      }
    })

    if (bottomPagination) { //if (page_count > 1 && bottomPagination) {
      drawPagination();
    }

    var ag = new AssetGrid(container, ".cameratag_smart_thumb", targetHeight);

    initializeSmartThumbs();
  }

  self.nextPage = function() {
    // if (current_page < page_count) {
      self.loadPage(current_page + 1);
    // }
  }

  self.previousPage = function() {
    if (current_page > 1) {
      self.loadPage(current_page - 1);
    }
  }

  var drawPagination = function() {
    var pagination_container = $('<div class="cameratag_videowall_pagination"></div>');

    // draw previous button
    if (current_page > 1) {
      var previous_btn = $('<span data-page="'+(current_page + 1)+'" class="cameratag_videowall_pagination_link">&#9664;</span>');
      $(pagination_container).append(previous_btn);
    }

    // draw numbers
    // var page_no = (current_page < 4 ? 1 : (current_page - 3))
    // var count = 0;
    // while (count < 6 && page_no <= page_count) {
    //   if (page_no == current_page) {
    //     var number_link = $('<span class="cameratag_videowall_pagination_link current">'+page_no+'</span>');  
    //   } else {
    //     var number_link = $('<span data-page="'+page_no+'" class="cameratag_videowall_pagination_link">'+page_no+'</span>');  
    //   }
      
    //   $(pagination_container).append(number_link);
    //   page_no += 1;
    //   count += 1;
    // }

    // // draw end numbers
    // if (page_count - current_page > 9) {
    //   $(pagination_container).append('<span>.&nbsp;.&nbsp;.&nbsp;</span>');
    //   $(pagination_container).append('<span data-page="'+(page_count-2)+'" class="cameratag_videowall_pagination_link">'+(page_count-2)+'</span>');
    //   $(pagination_container).append('<span data-page="'+(page_count-1)+'" class="cameratag_videowall_pagination_link">'+(page_count-1)+'</span>');
    //   $(pagination_container).append('<span data-page="'+page_count+'"class="cameratag_videowall_pagination_link">'+page_count+'</span>');
    // }


    // draw next button
    // if (current_page < page_count) {
      var next_btn = $('<span data-page="'+(current_page + 1)+'" class="cameratag_videowall_pagination_link">&#9654;</span>');
      $(pagination_container).append(next_btn);
    // }

    $(pagination_container).find(".cameratag_videowall_pagination_link[data-page]").click(function(){
      var page = $(this).attr("data-page");
      self.loadPage(page);
    })

    $(container).append(pagination_container);
  }

  var openAsset = function(asset) {
    // open lightbox and create player
    var max_width = parseInt($("#"+dom_id+"_"+asset.uuid+" img").attr("data-width"));
    var max_height = parseInt($("#"+dom_id+"_"+asset.uuid+" img").attr("data-height"));
    $(lb_body)[0].style.maxWidth = max_width+"px";
    $(lb_body)[0].style.maxHeight = max_height+"px";
    if (asset.type == "Video" || asset.type == "Audio") {
      lb_body.html('<player id="ct_video_player" data-signature="'+signature+'" data-signature-expiration="'+expiration+'" data-options=\'{"width":"100%", "height":"100%"}\' data-uuid="'+asset.uuid+'"></player>');  
    } else if (asset.type == "Photo") {
      lb_body.html('<img src="'+asset.preview_thumbnail_url+'?signature='+signature+'&signature_expiration='+expiration+'" id="ct_image" style="max-width:100%; max-height:100%"></img>');
    }
    lb_overlay.show();
    lb_body.show();
    if (asset.type == "Video" || asset.type == "Audio") {
      CameraTag.setup();
    }
  }

  self.closeVideo = function() {
    lb_overlay.hide();
    lb_body.hide();
    lb_body.html("");
  }

  var initializeSmartThumbs = function() {
    $("[data-strip-url]").each(function(index, el){
      var url = $(el).attr("data-strip-url");
      var frame_count = $(el).attr("data-frame-count");
      var width = $(el).width();
      var height = $(el).height();
      var strip_hight = height * frame_count;

      $(el).css({
        backgroundImage: "url("+url+")",
        backgroundSize: width+"px "+strip_hight+"px",
        backgroundPosition: "0px 0px"
      });

      $(el).mousemove(function(e){
        var percent = parseInt(e.offsetX / width * frame_count);
        var top_offset = height * percent * -1;

        $(el).css({
          backgroundPosition: "0px "+top_offset+"px"
        });
      });

      $(el).mouseout(function(e){
        var top_offset = height * (frame_count / 2) * -1;
        $(el).css({
          backgroundPosition: "0px "+top_offset+"px"
        });
      });

    })
  }

  setup();
}
// End of Video Wall
    CameraTagPhotoCamera = function(booth_el, opts) {
  opts = opts || {};

  // EXIF JS
  var addEvent = function(a, b, c) {
    a.addEventListener ? a.addEventListener(b, c, !1) : a.attachEvent && a.attachEvent("on" + b, c)
}
var imageHasData = function(a) {
    return !!a.exifdata
}
var base64ToArrayBuffer = function(a, b) {
    b = b || a.match(/^data\:([^\;]+)\;base64,/im)[1] || "",
    a = a.replace(/^data\:([^\;]+)\;base64,/gim, "");
    for (var c = atob(a), d = c.length, e = new ArrayBuffer(d), f = new Uint8Array(e), g = 0; g < d; g++)
        f[g] = c.charCodeAt(g);
    return e
}
var objectURLToBlob = function(a, b) {
    var c = new XMLHttpRequest;
    c.open("GET", a, !0),
    c.responseType = "blob",
    c.onload = function(a) {
        200 != this.status && 0 !== this.status || b(this.response)
    }
    ,
    c.send()
}
var getImageData = function(a, b) {
    function c(c) {
        var d = findEXIFinJPEG(c)
          , e = findIPTCinJPEG(c);
        a.exifdata = d || {},
        a.iptcdata = e || {},
        b && b.call(a)
    }
    if (a.src)
        if (/^data\:/i.test(a.src)) {
            var d = base64ToArrayBuffer(a.src);
            c(d)
        } else if (/^blob\:/i.test(a.src)) {
            var e = new FileReader;
            e.onload = function(a) {
                c(a.target.result)
            }
            ,
            objectURLToBlob(a.src, function(a) {
                e.readAsArrayBuffer(a)
            })
        } else {
            var f = new XMLHttpRequest;
            f.onload = function() {
                if (200 != this.status && 0 !== this.status)
                    throw "Could not load image";
                c(f.response),
                f = null
            }
            ,
            f.open("GET", a.src, !0),
            f.responseType = "arraybuffer",
            f.send(null)
        }
    else if (window.FileReader && (a instanceof window.Blob || a instanceof window.File)) {
        var e = new FileReader;
        e.onload = function(a) {
            console.log("Got file of length " + a.target.result.byteLength),
            c(a.target.result)
        }
        ,
        e.readAsArrayBuffer(a)
    }
}
var findEXIFinJPEG = function(a) {
    var b = new DataView(a);
    if (console.log("Got file of length " + a.byteLength),
    255 != b.getUint8(0) || 216 != b.getUint8(1))
        return console.log("Not a valid JPEG"),
        !1;
    for (var e, c = 2, d = a.byteLength; c < d; ) {
        if (255 != b.getUint8(c))
            return console.log("Not a valid marker at offset " + c + ", found: " + b.getUint8(c)),
            !1;
        if (e = b.getUint8(c + 1),
        console.log(e),
        225 == e)
            return console.log("Found 0xFFE1 marker"),
            readEXIFData(b, c + 4, b.getUint16(c + 2) - 2);
        c += 2 + b.getUint16(c + 2)
    }
}
var findIPTCinJPEG = function(a) {
    var b = new DataView(a);
    if (console.log("Got file of length " + a.byteLength),
    255 != b.getUint8(0) || 216 != b.getUint8(1))
        return console.log("Not a valid JPEG"),
        !1;
    for (var c = 2, d = a.byteLength, e = function(a, b) {
        return 56 === a.getUint8(b) && 66 === a.getUint8(b + 1) && 73 === a.getUint8(b + 2) && 77 === a.getUint8(b + 3) && 4 === a.getUint8(b + 4) && 4 === a.getUint8(b + 5)
    }; c < d; ) {
        if (e(b, c)) {
            var f = b.getUint8(c + 7);
            f % 2 !== 0 && (f += 1),
            0 === f && (f = 4);
            var g = c + 8 + f
              , h = b.getUint16(c + 6 + f);
            return readIPTCData(a, g, h)
        }
        c++
    }
}
var readIPTCData = function(a, b, c) {
    for (var f, g, h, i, j, d = new DataView(a), e = {}, k = b; k < b + c; )
        28 === d.getUint8(k) && 2 === d.getUint8(k + 1) && (i = d.getUint8(k + 2),
        i in IptcFieldMap && (h = d.getInt16(k + 3),
        j = h + 5,
        g = IptcFieldMap[i],
        f = getStringFromDB(d, k + 5, h),
        e.hasOwnProperty(g) ? e[g]instanceof Array ? e[g].push(f) : e[g] = [e[g], f] : e[g] = f)),
        k++;
    return e
}
var readTags = function(a, b, c, d, e) {
    var h, i, j, f = a.getUint16(c, !e), g = {};
    for (j = 0; j < f; j++)
        h = c + 12 * j + 2,
        i = d[a.getUint16(h, !e)],
        !i && console.log("Unknown tag: " + a.getUint16(h, !e)),
        g[i] = readTagValue(a, h, b, c, e);
    return g
}
var readTagValue = function(a, b, c, d, e) {
    var i, j, k, l, m, n, f = a.getUint16(b + 2, !e), g = a.getUint32(b + 4, !e), h = a.getUint32(b + 8, !e) + c;
    switch (f) {
    case 1:
    case 7:
        if (1 == g)
            return a.getUint8(b + 8, !e);
        for (i = g > 4 ? h : b + 8,
        j = [],
        l = 0; l < g; l++)
            j[l] = a.getUint8(i + l);
        return j;
    case 2:
        return i = g > 4 ? h : b + 8,
        getStringFromDB(a, i, g - 1);
    case 3:
        if (1 == g)
            return a.getUint16(b + 8, !e);
        for (i = g > 2 ? h : b + 8,
        j = [],
        l = 0; l < g; l++)
            j[l] = a.getUint16(i + 2 * l, !e);
        return j;
    case 4:
        if (1 == g)
            return a.getUint32(b + 8, !e);
        for (j = [],
        l = 0; l < g; l++)
            j[l] = a.getUint32(h + 4 * l, !e);
        return j;
    case 5:
        if (1 == g)
            return m = a.getUint32(h, !e),
            n = a.getUint32(h + 4, !e),
            k = new Number(m / n),
            k.numerator = m,
            k.denominator = n,
            k;
        for (j = [],
        l = 0; l < g; l++)
            m = a.getUint32(h + 8 * l, !e),
            n = a.getUint32(h + 4 + 8 * l, !e),
            j[l] = new Number(m / n),
            j[l].numerator = m,
            j[l].denominator = n;
        return j;
    case 9:
        if (1 == g)
            return a.getInt32(b + 8, !e);
        for (j = [],
        l = 0; l < g; l++)
            j[l] = a.getInt32(h + 4 * l, !e);
        return j;
    case 10:
        if (1 == g)
            return a.getInt32(h, !e) / a.getInt32(h + 4, !e);
        for (j = [],
        l = 0; l < g; l++)
            j[l] = a.getInt32(h + 8 * l, !e) / a.getInt32(h + 4 + 8 * l, !e);
        return j
    }
}
var getStringFromDB = function(a, b, c) {
    var d = "";
    for (n = b; n < b + c; n++)
        d += String.fromCharCode(a.getUint8(n));
    return d
}
var readEXIFData = function(a, b) {
    if ("Exif" != getStringFromDB(a, b, 4))
        return console.log("Not valid EXIF data! " + getStringFromDB(a, b, 4)),
        !1;
    var c, d, e, f, g, h = b + 6;
    if (18761 == a.getUint16(h))
        c = !1;
    else {
        if (19789 != a.getUint16(h))
            return console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"),
            !1;
        c = !0
    }
    if (42 != a.getUint16(h + 2, !c))
        return console.log("Not valid TIFF data! (no 0x002A)"),
        !1;
    var i = a.getUint32(h + 4, !c);
    if (i < 8)
        return console.log("Not valid TIFF data! (First offset less than 8)", a.getUint32(h + 4, !c)),
        !1;
    if (d = readTags(a, h, h + i, TiffTags, c),
    d.ExifIFDPointer) {
        f = readTags(a, h, h + d.ExifIFDPointer, ExifTags, c);
        for (e in f) {
            switch (e) {
            case "LightSource":
            case "Flash":
            case "MeteringMode":
            case "ExposureProgram":
            case "SensingMethod":
            case "SceneCaptureType":
            case "SceneType":
            case "CustomRendered":
            case "WhiteBalance":
            case "GainControl":
            case "Contrast":
            case "Saturation":
            case "Sharpness":
            case "SubjectDistanceRange":
            case "FileSource":
                f[e] = StringValues[e][f[e]];
                break;
            case "ExifVersion":
            case "FlashpixVersion":
                f[e] = String.fromCharCode(f[e][0], f[e][1], f[e][2], f[e][3]);
                break;
            case "ComponentsConfiguration":
                f[e] = StringValues.Components[f[e][0]] + StringValues.Components[f[e][1]] + StringValues.Components[f[e][2]] + StringValues.Components[f[e][3]]
            }
            d[e] = f[e]
        }
    }
    if (d.GPSInfoIFDPointer) {
        g = readTags(a, h, h + d.GPSInfoIFDPointer, GPSTags, c);
        for (e in g) {
            switch (e) {
            case "GPSVersionID":
                g[e] = g[e][0] + "." + g[e][1] + "." + g[e][2] + "." + g[e][3]
            }
            d[e] = g[e]
        }
    }
    return d
}
var EXIF = function(a) {
    return a instanceof EXIF ? a : this instanceof EXIF ? void (this.EXIFwrapped = a) : new EXIF(a)
}
  , ExifTags = EXIF.Tags = {
    36864: "ExifVersion",
    40960: "FlashpixVersion",
    40961: "ColorSpace",
    40962: "PixelXDimension",
    40963: "PixelYDimension",
    37121: "ComponentsConfiguration",
    37122: "CompressedBitsPerPixel",
    37500: "MakerNote",
    37510: "UserComment",
    40964: "RelatedSoundFile",
    36867: "DateTimeOriginal",
    36868: "DateTimeDigitized",
    37520: "SubsecTime",
    37521: "SubsecTimeOriginal",
    37522: "SubsecTimeDigitized",
    33434: "ExposureTime",
    33437: "FNumber",
    34850: "ExposureProgram",
    34852: "SpectralSensitivity",
    34855: "ISOSpeedRatings",
    34856: "OECF",
    37377: "ShutterSpeedValue",
    37378: "ApertureValue",
    37379: "BrightnessValue",
    37380: "ExposureBias",
    37381: "MaxApertureValue",
    37382: "SubjectDistance",
    37383: "MeteringMode",
    37384: "LightSource",
    37385: "Flash",
    37396: "SubjectArea",
    37386: "FocalLength",
    41483: "FlashEnergy",
    41484: "SpatialFrequencyResponse",
    41486: "FocalPlaneXResolution",
    41487: "FocalPlaneYResolution",
    41488: "FocalPlaneResolutionUnit",
    41492: "SubjectLocation",
    41493: "ExposureIndex",
    41495: "SensingMethod",
    41728: "FileSource",
    41729: "SceneType",
    41730: "CFAPattern",
    41985: "CustomRendered",
    41986: "ExposureMode",
    41987: "WhiteBalance",
    41988: "DigitalZoomRation",
    41989: "FocalLengthIn35mmFilm",
    41990: "SceneCaptureType",
    41991: "GainControl",
    41992: "Contrast",
    41993: "Saturation",
    41994: "Sharpness",
    41995: "DeviceSettingDescription",
    41996: "SubjectDistanceRange",
    40965: "InteroperabilityIFDPointer",
    42016: "ImageUniqueID"
}
  , TiffTags = EXIF.TiffTags = {
    256: "ImageWidth",
    257: "ImageHeight",
    34665: "ExifIFDPointer",
    34853: "GPSInfoIFDPointer",
    40965: "InteroperabilityIFDPointer",
    258: "BitsPerSample",
    259: "Compression",
    262: "PhotometricInterpretation",
    274: "Orientation",
    277: "SamplesPerPixel",
    284: "PlanarConfiguration",
    530: "YCbCrSubSampling",
    531: "YCbCrPositioning",
    282: "XResolution",
    283: "YResolution",
    296: "ResolutionUnit",
    273: "StripOffsets",
    278: "RowsPerStrip",
    279: "StripByteCounts",
    513: "JPEGInterchangeFormat",
    514: "JPEGInterchangeFormatLength",
    301: "TransferFunction",
    318: "WhitePoint",
    319: "PrimaryChromaticities",
    529: "YCbCrCoefficients",
    532: "ReferenceBlackWhite",
    306: "DateTime",
    270: "ImageDescription",
    271: "Make",
    272: "Model",
    305: "Software",
    315: "Artist",
    33432: "Copyright"
}
  , GPSTags = EXIF.GPSTags = {
    0: "GPSVersionID",
    1: "GPSLatitudeRef",
    2: "GPSLatitude",
    3: "GPSLongitudeRef",
    4: "GPSLongitude",
    5: "GPSAltitudeRef",
    6: "GPSAltitude",
    7: "GPSTimeStamp",
    8: "GPSSatellites",
    9: "GPSStatus",
    10: "GPSMeasureMode",
    11: "GPSDOP",
    12: "GPSSpeedRef",
    13: "GPSSpeed",
    14: "GPSTrackRef",
    15: "GPSTrack",
    16: "GPSImgDirectionRef",
    17: "GPSImgDirection",
    18: "GPSMapDatum",
    19: "GPSDestLatitudeRef",
    20: "GPSDestLatitude",
    21: "GPSDestLongitudeRef",
    22: "GPSDestLongitude",
    23: "GPSDestBearingRef",
    24: "GPSDestBearing",
    25: "GPSDestDistanceRef",
    26: "GPSDestDistance",
    27: "GPSProcessingMethod",
    28: "GPSAreaInformation",
    29: "GPSDateStamp",
    30: "GPSDifferential"
}
  , StringValues = EXIF.StringValues = {
    ExposureProgram: {
        0: "Not defined",
        1: "Manual",
        2: "Normal program",
        3: "Aperture priority",
        4: "Shutter priority",
        5: "Creative program",
        6: "Action program",
        7: "Portrait mode",
        8: "Landscape mode"
    },
    MeteringMode: {
        0: "Unknown",
        1: "Average",
        2: "CenterWeightedAverage",
        3: "Spot",
        4: "MultiSpot",
        5: "Pattern",
        6: "Partial",
        255: "Other"
    },
    LightSource: {
        0: "Unknown",
        1: "Daylight",
        2: "Fluorescent",
        3: "Tungsten (incandescent light)",
        4: "Flash",
        9: "Fine weather",
        10: "Cloudy weather",
        11: "Shade",
        12: "Daylight fluorescent (D 5700 - 7100K)",
        13: "Day white fluorescent (N 4600 - 5400K)",
        14: "Cool white fluorescent (W 3900 - 4500K)",
        15: "White fluorescent (WW 3200 - 3700K)",
        17: "Standard light A",
        18: "Standard light B",
        19: "Standard light C",
        20: "D55",
        21: "D65",
        22: "D75",
        23: "D50",
        24: "ISO studio tungsten",
        255: "Other"
    },
    Flash: {
        0: "Flash did not fire",
        1: "Flash fired",
        5: "Strobe return light not detected",
        7: "Strobe return light detected",
        9: "Flash fired, compulsory flash mode",
        13: "Flash fired, compulsory flash mode, return light not detected",
        15: "Flash fired, compulsory flash mode, return light detected",
        16: "Flash did not fire, compulsory flash mode",
        24: "Flash did not fire, auto mode",
        25: "Flash fired, auto mode",
        29: "Flash fired, auto mode, return light not detected",
        31: "Flash fired, auto mode, return light detected",
        32: "No flash function",
        65: "Flash fired, red-eye reduction mode",
        69: "Flash fired, red-eye reduction mode, return light not detected",
        71: "Flash fired, red-eye reduction mode, return light detected",
        73: "Flash fired, compulsory flash mode, red-eye reduction mode",
        77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
        79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
        89: "Flash fired, auto mode, red-eye reduction mode",
        93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
        95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
    },
    SensingMethod: {
        1: "Not defined",
        2: "One-chip color area sensor",
        3: "Two-chip color area sensor",
        4: "Three-chip color area sensor",
        5: "Color sequential area sensor",
        7: "Trilinear sensor",
        8: "Color sequential linear sensor"
    },
    SceneCaptureType: {
        0: "Standard",
        1: "Landscape",
        2: "Portrait",
        3: "Night scene"
    },
    SceneType: {
        1: "Directly photographed"
    },
    CustomRendered: {
        0: "Normal process",
        1: "Custom process"
    },
    WhiteBalance: {
        0: "Auto white balance",
        1: "Manual white balance"
    },
    GainControl: {
        0: "None",
        1: "Low gain up",
        2: "High gain up",
        3: "Low gain down",
        4: "High gain down"
    },
    Contrast: {
        0: "Normal",
        1: "Soft",
        2: "Hard"
    },
    Saturation: {
        0: "Normal",
        1: "Low saturation",
        2: "High saturation"
    },
    Sharpness: {
        0: "Normal",
        1: "Soft",
        2: "Hard"
    },
    SubjectDistanceRange: {
        0: "Unknown",
        1: "Macro",
        2: "Close view",
        3: "Distant view"
    },
    FileSource: {
        3: "DSC"
    },
    Components: {
        0: "",
        1: "Y",
        2: "Cb",
        3: "Cr",
        4: "R",
        5: "G",
        6: "B"
    }
}
  , IptcFieldMap = {
    120: "caption",
    110: "credit",
    25: "keywords",
    55: "dateCreated",
    80: "byline",
    85: "bylineTitle",
    122: "captionWriter",
    105: "headline",
    116: "copyright",
    15: "category"
};
EXIF.getData = function(a, b) {
    return !((a instanceof Image || a instanceof HTMLImageElement) && !a.complete) && (imageHasData(a) ? b && b.call(a) : getImageData(a, b),
    !0)
}
,
EXIF.getTag = function(a, b) {
    if (imageHasData(a))
        return a.exifdata[b]
}
,
EXIF.getAllTags = function(a) {
    if (!imageHasData(a))
        return {};
    var b, c = a.exifdata, d = {};
    for (b in c)
        c.hasOwnProperty(b) && (d[b] = c[b]);
    return d
}
,
EXIF.pretty = function(a) {
    if (!imageHasData(a))
        return "";
    var b, c = a.exifdata, d = "";
    for (b in c)
        c.hasOwnProperty(b) && (d += "object" == typeof c[b] ? c[b]instanceof Number ? b + " : " + c[b] + " [" + c[b].numerator + "/" + c[b].denominator + "]\r\n" : b + " : [" + c[b].length + " values]\r\n" : b + " : " + c[b] + "\r\n");
    return d
}
,
EXIF.readFromBinaryFile = function(a) {
    return findEXIFinJPEG(a)
}
;

  // interface
  var invalid_jpg;
  var container;
  var start_screen;
  var mobile_start_screen;
  var capture_screen;
  var review_screen;
  var upload_screen;
  var settings_screen;
  var error_screen;
  var wiat_screen;
  var published_screen;
  var device_selection_screen;
  var use_opengl;
  var camera_options;
  var file_to_upload;
  var isUpload;
  var camera_select_container

  var current_screen;
  var last_screen;

  var preview_canvas_placeholder;
  var review_canvas_placeholder;
  var review_img;
  var nubs_el;
  var trigger;
  var image_frame;
  var published_img;
  var offset_dragger;
  var offset_dragger_container;
  var dragger_container_top;
  var dragger_container_left;
  var dragger_container_width;
  var dragger_container_height;
  var image_container;
  var filter_container;
  var filter_properties;
  var filter_selector;
  var flash;
  var shutter_sound;
  var wait_message;
  var error_message;
  var apply_button;
  var cancel_button;
  var accept_button;
  var retake_button;
  var upload_status;
  var render_count = 0;
  var exif_orientaion = 1;
  var processed_timer;

  var x_offset = 0;
  var y_offset = 0;
  var max_x_offset;
  var max_y_offset;
  var preview_multiplier;

  // configuraion
  var hResolution;
  var vResolution;
  var permitted_extensions = ["jpg", "gif", "bmp", "png", "jpeg"];
  var constraints = {
    audio: {},
    video: {}
  };

  // internal usage
  var photo;
  var self = this;
  var state;
  var booth;
  var review_canvas;
  var frame_data;
  var filtered_frame_data;
  var frame = 0;
  var uploader;
  var connected;
  var metadata_object;
  var errors = [];
  var cachebuster = parseInt( Math.random() * 100000000 );
  var connect_callback;
  var selected_cam_id;
  var gum_supported = typeof(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) == "function";
  var webrtc_enabled = typeof(MediaRecorder) == "function"

  var WebRTCBooth = function(placeholder_el) {
  var self = this;
  var video_el;
  var canvas;
  var context;
  var stream;
  var stream_width 
  var stream_height
  var output_frame;
  force_full_frame = true;
  self.cams = [];


  var init = function() {
    canvas = $('<canvas></canvas>');
    video_el = $('<video playsinline="true" autoplay="true" style="object-fit:cover;"></video>');
    context = canvas[0].getContext('2d');
    $(placeholder_el).append(video_el);
    $(canvas).insertAfter(video_el);

    video_el[0].width = width;
    video_el[0].height = height;
    if (flip_preview) {
      video_el[0].style.transform = "scaleX(-1)";
    }

    canvas.attr("width", hResolution);
    canvas.attr("height", vResolution);
    canvas.hide();

    // start rendering when the video el is ready
    video_el[0].addEventListener('canplay', function(ev){
      draw();
    }, false);

    // initialize
    if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
      navigator.mediaDevices.enumerateDevices().then(function(devices){
        $(devices).each(function(index, device){
          device_name = (device.label == "" ? device.deviceId : device.label);
          if (device.kind === 'videoinput') {
            self.cams.push({
              label: device_name,
              deviceId: device.deviceId
            });
          }
        })
        if (self.cams.length == 0) {
          CameraTag.fire(dom_id, "noCamera");
        } else {
          // selected_cam_id = getCookie("CameraTagSelectedCameraId") || self.cams[0].deviceId;
        }
        CameraTag.fire(dom_id, "initialized");
      });
    } else {
      CameraTag.fire(dom_id, "initialized");
    }
  }

  self.stack = "MediaRecorder";

  self.setCamera = function(camera_id) {
    selected_cam_id = camera_id;
    createCookie("CameraTagSelectedCameraId", camera_id);
  }

  self.listCameras = function() {
    return self.cams;
  }

  self.connect = function() {
    buildConstraints();
    wait(CT_i18n[100])

    navigator.mediaDevices.getUserMedia(constraints).then(function(new_stream) {
      connected = true;
      stream = new_stream;

      if (typeof(video_el[0].srcObject) == "undefined") {
        video_el[0].src = URL.createObjectURL(new_stream);
      } else {
        video_el[0].srcObject = new_stream;
      }

      video_el[0].addEventListener("playing", function () {
          setTimeout(function () {
            stream_width = video_el[0].videoWidth
            stream_height = video_el[0].videoHeight
          }, 500);
      });
      
      // video_el[0].play();
      // get device labels now that we have permission
      self.cams = [];
      if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices().then(function(devices){
          $(devices).each(function(index, device){
            device_name = (device.label == "" ? device.deviceId : device.label);
            if (device.kind === 'videoinput') {
              self.cams.push({
                label: device_name,
                deviceId: device.deviceId
              });
            }
          })
          if (self.cams.length == 0) {
            CameraTag.fire(dom_id, "noCamera");
          } else {
            // selected_cam_id = getCookie("CameraTagSelectedCameraId") || self.cams[0].deviceId;
          }
          CameraTag.fire(dom_id, "connected");
        });
      } else {
        CameraTag.fire(dom_id, "connected");
      }

    }).catch(function(message){
      CameraTag.fire(dom_id, "cameraError");
      error(message);
    });
  }

  self.disconnect = function() {
    if (connected) {
      video_el[0].srcObject = null;
      video_el[0].src = null;
      try {
        stream.stop();
      } catch(err) {
        if (stream && stream.getTracks) {
          $(stream.getTracks()).each(function(index, track){
            stream.removeTrack(track); // this helps prevent Android 11 freezing?
            track.stop()
          });
        }
      }
      connected = false;
      CameraTag.fire(dom_id, "disconnected");
    }
  }

  self.hide = function() {
    video_el.hide();
  }

  self.show = function() {
    video_el.show();
  }

  self.getFrame = function() {
    return output_frame;
  }

  var draw = function() {
    // dont draw if paused
    if(video_el[0].paused || video_el[0].ended) return false;

    // determine default zoom,
    var width_ratio =  hResolution / stream_width;
    var height_ratio = vResolution / stream_height;

    // force full frame
    if (force_full_frame) {
      default_zoom_multiplier = (width_ratio > height_ratio) ? width_ratio : height_ratio;
    // pad
    } else {
      default_zoom_multiplier = (width_ratio < height_ratio) ? width_ratio : height_ratio;
    }

    // center image
    x_offset = (hResolution - (default_zoom_multiplier * stream_width)) / 2;
    y_offset = (vResolution - (default_zoom_multiplier * stream_height)) / 2;
    
    // scaled width
    scaled_width = stream_width * default_zoom_multiplier;
    scaled_height = stream_height * default_zoom_multiplier;

    // draw to canvas
    context.drawImage(video_el[0],x_offset,y_offset,scaled_width,scaled_height);
    setTimeout(draw,40);

    // save result to buffer
    output_frame = canvas[0].toDataURL('image/jpg');
  }

  init();
}
  var ImageProcessor = function(placeholder_el) {
  var self = this;
  var parent_effect_canvas = this;

  var crop_canvas;
  var crop_context;

  var effect_canvas;
  var effect_texture;

  var input_img;
  var input_width;
  var input_height;


  var default_zoom_multiplier;
  var user_zoom_multiplier;
  var final_zoom_multiplier;
  var scaled_width;
  var scaled_height;
  var font_size;

  var preview_img;
  preview_multiplier = hResolution / width;
  var output_frame;

  self.selected_filter = null;

  try {
    use_opengl = true;
    effect_canvas = fx.canvas();
  } catch (e) {
    // error(e);
    use_opengl = false;
    effect_canvas = $('<canvas></canvas>');
  }

  var init = function() {
    // build our canvases and output image
    input_img = $('<img></img>');
    crop_canvas = $('<canvas></canvas>');
    
    preview_img = $('<img></img>');

    // set heights
    crop_canvas.attr("width", hResolution);
    crop_canvas.attr("height", vResolution);
    // ** effects canvas height / width will be set by glfx
    preview_img.attr("width", width);


    // add the key elements to the DOM
    $(placeholder_el).replaceWith(preview_img);
    $(effect_canvas).insertAfter(preview_img);
    $(crop_canvas).insertAfter(effect_canvas);
    $(input_img).insertAfter(crop_canvas);

    // hide the guts
    input_img.hide();
    crop_canvas.hide();
    $(effect_canvas).hide();
    
    // get contexts and txtures
    crop_context = crop_canvas[0].getContext('2d');
    
    // default filter
    self.select_filter(0);

    if (isMobileDevice) {
      CameraTag.fire(dom_id, "initialized");
    }
  }

  self.select_filter = function(filter_index) {
    if (filter_index == 0) {
      review_edit_controls.hide();
      review_ready_controls.show();
    } else {
      review_edit_controls.show();
      review_ready_controls.hide();
    }
    if (filter_index == 1) {
      offset_dragger_container.show();
      offset_dragger.show();
      zoom_slider.slider("value", 1);
      zoom_slider_container.show();  
    } else {
      offset_dragger_container.hide();
      //offset_dragger.hide();
      resetZoom();
      zoom_slider_container.hide();
    }

    if (use_opengl) {
      self.selected_filter = self.filters[filter_index];
      self.selected_filter.use();
      filter_selector.val(filter_index);
    }

    self.draw();
  };

  self.setUserZoom = function(new_user_zoom_multiple) {
    user_zoom_multiplier = new_user_zoom_multiple;
    final_zoom_multiplier = default_zoom_multiplier * user_zoom_multiplier;
    scaled_width = input_width * final_zoom_multiplier;
    scaled_height = input_height * final_zoom_multiplier;

    var display_multiplier = 1 / preview_multiplier;

    // if force crop
    if (force_full_frame) {
      max_x_offset = scaled_width - hResolution;
      max_y_offset = scaled_height - vResolution; 

      dragger_container_left = max_x_offset * display_multiplier;
      dragger_container_top = max_y_offset * display_multiplier;
      drag_container_width = (scaled_width + max_x_offset) * display_multiplier;
      drag_container_height = (scaled_height + max_y_offset) * display_multiplier;
      var dragger_width = scaled_width * display_multiplier;
      var dragger_height = scaled_height * display_multiplier;
      offset_dragger_container.css({left:dragger_container_left * -1, top:dragger_container_top * -1, width: drag_container_width, height:drag_container_height});
      $(offset_dragger).css({width: dragger_width, height: dragger_height, top: dragger_container_top, left: dragger_container_left});
      $(offset_dragger).draggable("option", "containment", "parent"); 

    // else pad
    } else {
      max_x_offset = scaled_width * 0.5;
      max_y_offset = scaled_height * 0.5;

      dragger_container_left = max_x_offset * display_multiplier * -1;
      dragger_container_top = max_y_offset * display_multiplier * -1;
      drag_container_width = (hResolution + (max_x_offset * 2)) * display_multiplier;
      drag_container_height = (hResolution + (max_y_offset * 2)) * display_multiplier;
      var dragger_width = scaled_width * display_multiplier;
      var dragger_height = scaled_height * display_multiplier;
      var dragger_x = (x_offset * display_multiplier) + (dragger_container_left * -1);
      var dragger_y = (y_offset * display_multiplier) + (dragger_container_top * -1);

      
      offset_dragger_container.css({left:dragger_container_left, top:dragger_container_top, width: drag_container_width, height:drag_container_height});
      $(offset_dragger).css({width: dragger_width, height: dragger_height, top: dragger_y, left: dragger_x});
      $(offset_dragger).draggable("option", "containment", "parent"); 
    }
    
  };

  self.setOffset = function(x,y) {
    x_offset = x;
    // if (x_offset > 0) {
    //   x_offset = 0;
    // } else if (x_offset < max_x_offset * -1) {
    //   x_offset = max_x_offset * -1;
    // }

    y_offset = y;
    // if (y_offset > 0) {
    //   y_offset = 0;
    // } else if (y_offset < max_y_offset * -1) {
    //   y_offset = max_y_offset * -1;
    // }
  }

  self.applyFilter = function() {
    self.draw(output_frame);
    x_offset = 0;
    y_offset = 0;
    zoom_slider.slider("value", 1);
    self.select_filter(0);
    offset_dragger_container.hide();
    //offset_dragger.hide();
  }

  var setOrientation = function() {
    var orientation;
    if (render_count > 0) {
      orientation = 1
    } else {
      orientation = exif_orientaion;
    }

    if (orientation) {
      var flipper_canvas = getFlipperCanvas(input_img[0], orientation, 0, 0, input_img[0].width, input_img[0].height);
      flipper_data_url = flipper_canvas.toDataURL('image/jpeg');  
      input_img[0].onload = setupNewImageData;
      input_img[0].src = flipper_data_url;  
    }
    
  }

  var setupNewImageData = function() {
    // get image dimensions
    input_width = input_img[0].width;
    input_height = input_img[0].height;

    // determine default zoom,
    var width_ratio =  hResolution / input_width;
    var height_ratio = vResolution / input_height;

    // force full frame
    if (force_full_frame) {
      default_zoom_multiplier = (width_ratio > height_ratio) ? width_ratio : height_ratio;
    // pad
    } else {
      default_zoom_multiplier = (width_ratio < height_ratio) ? width_ratio : height_ratio;
    }

    // center image
    x_offset = (hResolution - (default_zoom_multiplier * input_width)) / 2;
    y_offset = (vResolution - (default_zoom_multiplier * input_height)) / 2;
    

    self.setUserZoom(1);

    self.draw();

    render_count += 1;
  }

  var getFlipperCanvas = function(img, orientation, x, y, width, height) {
    if (!/^[1-8]$/.test(orientation)) throw new Error('orientation should be [1-8]');

    if (x == null) x = 0;
    if (y == null) y = 0;
    if (width == null) width = img.width;
    if (height == null) height = img.height;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;

    // console.log("ORIENTATION: "+orientation);

    ctx.save();
    if (adapter.browserDetails.browser == "safari") {
      switch (+orientation) {
        // 1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
        case 1:
            break;

        // 2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
        case 2:
           // ctx.translate(width, 0);
           // ctx.scale(-1, 1);
           break;

        // 3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
        case 3:
            // ctx.translate(width, height);
            // ctx.rotate(180 / 180 * Math.PI);
            break;

        // 4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
        case 4:
            // ctx.translate(0, height);
            // ctx.scale(1, -1);
            break;

        // 5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
        case 5:
            // canvas.width = height;
            // canvas.height = width;
            // ctx.rotate(90 / 180 * Math.PI);
            // ctx.scale(1, -1);
            break;

        // 6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
        case 6:
            // canvas.width = height;
            // canvas.height = width;
            // ctx.rotate(90 / 180 * Math.PI);
            // ctx.translate(0, -height);
            // break;
            ctx.translate(width, height);
            ctx.scale(-1, -1);
            break;

        // 7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
        case 7:
            // canvas.width = height;
            // canvas.height = width;
            // ctx.rotate(270 / 180 * Math.PI);
            // ctx.translate(-width, height);
            // ctx.scale(1, -1);
            break;

        // 8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
        case 8:
            // canvas.width = height;
            // canvas.height = width;
            // ctx.translate(0, width);
            // ctx.rotate(270 / 180 * Math.PI);
            break;
      }
    }

    // handle safari stupidness
    if (adapter.browserDetails.browser == "safari" && isMobileDevice) {
    //   ctx.translate(0, height);
    //   ctx.scale(1, -1);

    //   if (render_count === 0 && orientation == 6) {
    //     ctx.translate(width, height);
    //     ctx.rotate(180 / 180 * Math.PI);
    //   }

    // } else if (adapter.browserDetails.browser == "safari" && !isMobileDevice) { 
    //   ctx.translate(0, height);
    //   ctx.scale(1, -1);

    //   if (orientation == 6) {
    //     ctx.translate(width, height);
    //     ctx.rotate(180 / 180 * Math.PI);
    //   }

    } else {
      // no extra rotation needed
    }

    ctx.drawImage(img, x, y, width, height);
    ctx.restore();

    return canvas;
  }

  self.draw = function(image_data) {
    // redner the input to an imput img
    if (image_data) {
      input_img[0].onload = setOrientation;
      input_img[0].src = image_data;

      return;
    }

    // render the input image to the crop canvas
    crop_context.beginPath();
    crop_context.rect(0, 0, hResolution, vResolution);
    crop_context.fillStyle = 'black';
    crop_context.fill();

    crop_context.drawImage(input_img[0],x_offset,y_offset,scaled_width,scaled_height);
    
    // render the crop canvas to the effects canvas
    if (use_opengl) {
      effect_texture = effect_canvas.texture(crop_canvas[0]);  
      self.selected_filter.draw(hResolution,vResolution);

      var current_frame = effect_canvas.toDataURL('image/png');
    } else {
      var current_frame = crop_canvas[0].toDataURL('image/png');
    }
    
    preview_img[0].src = current_frame;
    output_frame = current_frame; 
  }

  self.getFrame = function() {
    return output_frame;
  }

  //
  // FILTERS
  //

  var Filter = function(name, init, render) {
  var self = this;
  self.name = name;
  var init = init;
  
  var sliders = [];
  var nubs = [];

  self.draw = function(width, height) {
    render(self, width, height);
  }

  self.addNub = function(name, x, y) {
    nubs.push({ name: name, x: x, y: y });
  };

  self.addSlider = function(name, label, min, max, value, step) {
    sliders.push({ name: name, label: label, min: min, max: max, value: value, step: step });
  };

  self.use = function() {
    // Clear all setting rows but the first two (which contain the filter selector and code sample)
    filter_properties.html("");

    // Add a row for each slider
    for (var i = 0; i < sliders.length; i++) {
        var slider = sliders[i];
        $('<div class="cameratag_photobooth_filter_property"><div class="cameratag_photobooth_filter_property_title">' + slider.label.replace(/ /g, '&nbsp;') + ':</div><div cameratag_photobooth_filter_property_slider" id="slider' + i + '"></div></div>').appendTo(filter_properties);
        var onchange = (function(this_, slider) { return function(event, ui) {
            this_[slider.name] = ui.value;
            parent_effect_canvas.draw();
        }; })(this, slider);
        $('#slider' + i).slider({
            slide: onchange,
            change: onchange,
            min: slider.min,
            max: slider.max,
            value: slider.value,
            step: slider.step
        });
        self[slider.name] = slider.value;
    }

    // Add a div for each nub
    $(".cameratag_photobooth_nub").remove();
    for (var i = 0; i < nubs.length; i++) {
        var nub = nubs[i];
        var x = nub.x * preview_img[0].width;
        var y = nub.y * preview_img[0].height;
        $('<div class="cameratag_photobooth_nub" id="nub' + i + '"></div>').appendTo(nubs_el);
        var ondrag = (function(this_, nub) { return function(event, ui) {
            var offset = $(event.target.parentNode).offset();
            var adjusted_x = (ui.offset.left - offset.left) * preview_multiplier;
            var adjusted_y = (ui.offset.top - offset.top) * preview_multiplier;
            this_[nub.name] = { x: adjusted_x, y: adjusted_y };
            parent_effect_canvas.draw();
        }; })(this, nub);
        $('#nub' + i).draggable({
            drag: ondrag,
            containment: 'parent',
            scroll: false
        }).css({ left: x, top: y });
        self[nub.name] = { x: (x * preview_multiplier), y: (y * preview_multiplier) };
    }
  }

  // initiaize the filter interface
  init(self);
}

  var perspectiveNubs = [175, 156, 496, 55, 161, 279, 504, 330];

  // Filters Objects Array
  if (use_opengl) {
    self.filters = [
      new Filter(CT_i18n[50], function(filter) {
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).update();
      }),

      new Filter(CT_i18n[51], function(filter) {
      }, function(filter, width, height) {
        effect_canvas.draw(effect_texture, hResolution, vResolution).update();
      }),

      new Filter(CT_i18n[52], function(filter) {
        filter.addSlider('frame', CT_i18n[92], 0, 200, 0, 1);
      }, function(filter, width, height) {
        effect_canvas.draw(effect_texture, hResolution, vResolution).smoke(filter.frame).update();
      }),

      new Filter(CT_i18n[53], function(filter) {
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).murica().update();
      }),

      new Filter(CT_i18n[54], function(filter) {
          filter.addSlider('brightness', CT_i18n[87], -1, 1, 0, 0.01);
          filter.addSlider('contrast', CT_i18n[97], -1, 1, 0, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).brightnessContrast(filter.brightness,filter.contrast).update();
      }),

      new Filter(CT_i18n[55], function(filter) {
          filter.addSlider('luminanceThreshold', CT_i18n[96], 0, 1, .2, 0.1);
          filter.addSlider('colorAmplification', CT_i18n[95], 0, 10, 4.0, 0.5);
          filter.addSlider('frame', CT_i18n[92], 0, 200, 0, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).nightvision(filter.frame, filter.luminanceThreshold, filter.colorAmplification).update();
      }),

      new Filter(CT_i18n[56], function(filter) {
          filter.addSlider('gamma', CT_i18n[94], 0, 2, 0.6, 0.01);
          filter.addSlider('numColors', CT_i18n[93], 0, 24, 8.0, 1.0);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).posterize(filter.gamma,filter.numColors).update();
      }),

      new Filter(CT_i18n[57], function(filter) {
          filter.addSlider('red', 'Red', -1, 1, 0.5, 0.1);
          filter.addSlider('green', 'Green', -1, 1, 0.3, 0.1);
          filter.addSlider('blue', 'Blue', -1, 1, 0.2, 0.1);
          filter.addSlider('sat', 'Saturation', -1, 1, 0.2, 0.1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).zinc(filter.red,filter.green,filter.blue,filter.sat).update();
      }),

      new Filter(CT_i18n[58], function(filter) {
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).berry().update();
      }),

      new Filter(CT_i18n[59], function(filter) {
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).spycam().update();
      }),

      new Filter(CT_i18n[60], function(filter) {
          filter.addSlider('size', CT_i18n[83], 0.1, 1.0, .5, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).magazine(filter.size).update();
      }),

      new Filter(CT_i18n[61], function(filter) {
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).crosshatch().update();
      }),

      new Filter(CT_i18n[62], function(filter) {
        filter.addSlider('frame', CT_i18n[92], 0, 200, 0, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).flare(filter.frame).update();
      }),

      new Filter(CT_i18n[63], function(filter) {
          filter.addSlider('hue', CT_i18n[90], -1, 1, 0, 0.01);
          filter.addSlider('saturation', CT_i18n[91], -1, 1, 0, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).hueSaturation(filter.hue, filter.saturation).update();
      }),

      new Filter(CT_i18n[64], function(filter) {
          filter.addSlider('amount', CT_i18n[86], -1, 1, 0.5, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).vibrance(filter.amount).update();
      }),

      new Filter(CT_i18n[65], function(filter) {
          filter.addSlider('exponent', CT_i18n[86], 0, 50, 20, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).denoise(filter.exponent).update();
      }),

      new Filter(CT_i18n[66], function(filter) {
          filter.addSlider('radius', CT_i18n[85], 0, 200, 20, 1);
          filter.addSlider('strength', CT_i18n[86], 0, 5, 2, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).unsharpMask(filter.radius, filter.strength).update();
      }),

      new Filter(CT_i18n[67], function(filter) {
          filter.addSlider('amount', CT_i18n[86], 0, 1, 0.5, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).noise(filter.amount).update();
      }),

      new Filter(CT_i18n[68], function(filter) {
          filter.addSlider('amount', CT_i18n[86], 0, 1, 1, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).sepia(filter.amount).update();
      }),

      new Filter(CT_i18n[69], function(filter) {
          filter.addSlider('size', CT_i18n[83], 0, 1, 0.5, 0.01);
          filter.addSlider('amount', CT_i18n[86], 0, 1, 0.5, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).vignette(filter.size, filter.amount).update();
      }),

      new Filter(CT_i18n[70], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('strength', CT_i18n[86], 0, 1, 0.3, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).zoomBlur(filter.center.x, filter.center.y, filter.strength).update();
      }),

      new Filter(CT_i18n[71], function(filter) {
          filter.addSlider('radius', CT_i18n[85], 0, 200, 50, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).triangleBlur(filter.radius).update();
      }),

      new Filter(CT_i18n[72], function(filter) {
          filter.addNub('start', 0.15, 0.75);
          filter.addNub('end', 0.75, 0.6);
          filter.addSlider('blurRadius', CT_i18n[88], 0, 50, 15, 1);
          filter.addSlider('gradientRadius', CT_i18n[89], 0, 400, 200, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).tiltShift(filter.start.x, filter.start.y, filter.end.x, filter.end.y, filter.blurRadius, filter.gradientRadius).update();
      }),

      new Filter(CT_i18n[73], function(filter) {
          filter.addSlider('radius', CT_i18n[85], 0, 50, 10, 1);
          filter.addSlider('brightness', CT_i18n[87], -1, 1, 0.75, 0.01);
          filter.addSlider('angle', CT_i18n[82], -Math.PI, Math.PI, 0, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).lensBlur(filter.radius, filter.brightness, filter.angle).update();
      }),

      new Filter(CT_i18n[74], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('angle', CT_i18n[82], -25, 25, 3, 0.1);
          filter.addSlider('radius', CT_i18n[85], 0, 600, 200, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).swirl(filter.center.x, filter.center.y, filter.radius, filter.angle).update();
      }),

      new Filter(CT_i18n[75], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('strength', CT_i18n[86], -1, 1, 0.5, 0.01);
          filter.addSlider('radius', CT_i18n[85], 0, 600, 200, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).bulgePinch(filter.center.x, filter.center.y, filter.radius, filter.strength).update();
      }),

      new Filter(CT_i18n[76], function(filter) {
          filter.addSlider('strength', CT_i18n[86], 0, 1, 0.25, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).ink(filter.strength).update();
      }),

      new Filter(CT_i18n[77], function(filter) {
          filter.addSlider('radius', CT_i18n[85], 0, 200, 10, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).edgeWork(filter.radius).update();
      }),

      new Filter(CT_i18n[78], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('scale', CT_i18n[84], 10, 100, 20, 1);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).hexagonalPixelate(filter.center.x, filter.center.y, filter.scale).update();
      }),

      new Filter(CT_i18n[79], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('angle', CT_i18n[82], 0, Math.PI / 2, 1.1, 0.01);
          filter.addSlider('size', CT_i18n[83], 3, 20, 3, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).dotScreen(filter.center.x, filter.center.y, filter.angle, filter.size).update();
      }),

      new Filter(CT_i18n[80], function(filter) {
          filter.addNub('center', 0.5, 0.5);
          filter.addSlider('angle', CT_i18n[82], 0, Math.PI / 2, 0.25, 0.01);
          filter.addSlider('size', CT_i18n[83], 3, 20, 4, 0.01);
      }, function(filter, width, height) {
          effect_canvas.draw(effect_texture, hResolution, vResolution).colorHalftone(filter.center.x, filter.center.y, filter.angle, filter.size).update();
      })
    ]
  } else {
    self.filters = [
      new Filter(CT_i18n[50], function(filter) {
      }, function(filter, width, height) {
          //effect_canvas.draw(effect_texture, hResolution, vResolution).update();
      }),

      new Filter(CT_i18n[51], function(filter) {
      }, function(filter, width, height) {
        //effect_canvas.draw(effect_texture, hResolution, vResolution).update();
      })
    ]
  }
  

  init();

}


  //
  // GENERATED FROM SCHEMA
  //
    var id = opts["id"] || $(booth_el).attr("data-id") || $(booth_el).attr("id") || "myBooth";



    var name = opts["name"] || $(booth_el).attr("data-name") || $(booth_el).attr("") || "";



    var description = opts["description"] || $(booth_el).attr("data-description") || $(booth_el).attr("") || "";



    var metadata = opts["metadata"] || $(booth_el).attr("data-metadata") || $(booth_el).attr("") || "";



    var flip_preview = opts["flip_preview"] || $(booth_el).attr("data-flip_preview") || $(booth_el).attr("") || true;


      // make sure flip_preview is a boolean
      if (typeof(flip_preview) == "string") {
        flip_preview = (flip_preview == "false" ? false : true);
      }

    var sources = opts["sources"] || $(booth_el).attr("data-sources") || $(booth_el).attr("data-sources") || ["record", "upload"];

      // make sure sources is an array
      if (typeof(sources) == "string") {
        try {
          sources = JSON.parse(sources);
        } catch {
          console.log("sources could not be parsed as an Array")
          sources = [];
        }
      }


    var skip_zoom = opts["skip_zoom"] || $(booth_el).attr("data-skip_zoom") || $(booth_el).attr("") || false;


      // make sure skip_zoom is a boolean
      if (typeof(skip_zoom) == "string") {
        skip_zoom = (skip_zoom == "false" ? false : true);
      }

    var force_full_frame = opts["force_full_frame"] || $(booth_el).attr("data-force_full_frame") || $(booth_el).attr("") || false;


      // make sure force_full_frame is a boolean
      if (typeof(force_full_frame) == "string") {
        force_full_frame = (force_full_frame == "false" ? false : true);
      }

    var preRollLength = opts["preRollLength"] || $(booth_el).attr("data-preRollLength") || $(booth_el).attr("") || 3;



    var facingMode = opts["facingMode"] || $(booth_el).attr("data-facingMode") || $(booth_el).attr("data-facing-mode") || null;



    var defaultStack = opts["defaultStack"] || $(booth_el).attr("data-defaultStack") || $(booth_el).attr("data-stack") || "auto";



    var signature = opts["signature"] || $(booth_el).attr("data-signature") || $(booth_el).attr("data-signature") || "";



    var signatureExpiration = opts["signatureExpiration"] || $(booth_el).attr("data-signatureExpiration") || $(booth_el).attr("data-signature-expiration") || "";



    var directUpload = opts["directUpload"] || $(booth_el).attr("data-directUpload") || $(booth_el).attr("") || false;


      // make sure directUpload is a boolean
      if (typeof(directUpload) == "string") {
        directUpload = (directUpload == "false" ? false : true);
      }

    var width = opts["width"] || $(booth_el).attr("data-width") || $(booth_el).attr("") || null;



    var height = opts["height"] || $(booth_el).attr("data-height") || $(booth_el).attr("") || null;



    var input_name = opts["input_name"] || $(booth_el).attr("data-input_name") || $(booth_el).attr("data-input-name") || "";




  // metadata is handeled specially
  if (metadata == "string") {
    try {
      metadata = JSON.parse(metadata);
    } catch {
      console.log("metadata could not be parsed as an Object")
      metadata = {};
    }
  }
  metadata_object = metadata;

  //
  // END FORM SCHEMA VARS
  //

  // backwardxs compatability
  var camera_uuid = $(booth_el).attr("data-appId") || $(booth_el).attr("data-uuid") || $(booth_el).attr("data-app-id") || $(booth_el).attr("id");
  var asset_name = name
  var asset_description = description
  var dom_id = id || cachebuster;
  var manual_stack = defaultStack;
  var signature = signature;
  var signature_expiration = signatureExpiration;
  var countdown = preRollLength;



  var init = function() {

    // get parameters
    // flip_preview = !$(booth_el).attr("data-mirror-preview") != "false";
    // dom_id = $(booth_el).attr("id");
    // camera_uuid = $(booth_el).attr("data-app-id");
    // signature = $(booth_el).attr("data-signature");
    // signature_expiration = $(booth_el).attr("data-signature-expiration");
    // input_name = $(booth_el).attr("name") || dom_id;
    // metadata = $(booth_el).attr("data-metadata");
    // force_full_frame = $(booth_el).attr("data-force-full-frame") == "true";
    // skip_zoom = $(booth_el).attr("data-skip-zoom") == "true";
    // manual_stack = $(booth_el).attr("data-stack");
    // facingMode = $(booth_el).attr("data-facing-mode");
    // asset_name = $(booth_el).attr("data-name");
    // asset_description = $(booth_el).attr("data-description");
    // directUpload = $(booth_el).attr("data-direct-upload") == "true";    
    // if ($(booth_el).attr("data-pre-roll-length")) {
    //   preRollLength = parseInt($(booth_el).attr("data-pre-roll-length"))
    // }
    // else {
    //   preRollLength = 3;
    // }
    // width = $(booth_el).attr("data-width") || width;
    // height = $(booth_el).attr("data-height") || height;

    // camera_uuid = opts["appUuid"] == null ? camera_uuid : opts["appUuid"];
    // flip_preview = opts["flip_preview"] == null ? flip_preview : opts["flip_preview"]
    // dom_id = opts["dom_id"] == null ? dom_id : opts["dom_id"]
    // signature = opts["signature"] == null ? signature : opts["signature"]
    // signature_expiration = opts["signature_expiration"] == null ? signature_expiration : opts["signature_expiration"]
    // input_name = opts["input_name"] == null ? input_name : opts["input_name"]
    // metadata = opts["metadata"] == null ? metadata : opts["metadata"]
    // force_full_frame = opts["force_full_frame"] == null ? force_full_frame : opts["force_full_frame"]
    // skip_zoom = opts["skip_zoom"] == null ? skip_zoom : opts["skip_zoom"]
    // manual_stack = opts["manual_stack"] == null ? manual_stack : opts["manual_stack"]
    // facingMode = opts["facingMode"] == null ? facingMode : opts["facingMode"]
    // asset_name = opts["asset_name"] == null ? asset_name : opts["asset_name"]
    // asset_description = opts["asset_description"] == null ? asset_description : opts["asset_description"]
    // directUpload = opts["directUpload"] == null ? directUpload : opts["directUpload"]
    // preRollLength = opts["preRollLength"] == null ? preRollLength : opts["preRollLength"]
    // hResolution = opts["hResolution"] == null ? hResolution : opts["hResolution"]
    // vResolution = opts["vResolution"] == null ? vResolution : opts["vResolution"]
    // width = opts["width"] == null ? width : opts["width"]
    // height = opts["height"] == null ? height : opts["height"]

    // countdown = preRollLength;

    // try {
    //   metadata_object = JSON.parse(metadata);
    // }
    // catch (e) {
    //   if (metadata != undefined) {
    //     console.warn("Could not parse user-data JSON from <photobooth> attribute."); 
    //   }
    // }

    get_camera(camera_uuid, function(server_response){
      if (server_response.success) {
        media_factories = server_response.photo_media_factories

        var scale_multiplier;
        var mf_width = media_factories[Object.keys(media_factories)[0]].width;
        var mf_height = media_factories[Object.keys(media_factories)[0]].height;
        var calc_width;
        var calc_height;
        mf_aspect = mf_width / mf_height;

        if (mf_aspect > 1.3) {
          // if its wider scale height to 300
          scale_multiplier = 300 / mf_height;
          calc_height = 300;
          calc_width = parseInt(mf_width * scale_multiplier);
        } else {
          scale_multiplier = 400 / mf_width;
          calc_width = 400;
          calc_height = parseInt(mf_height * scale_multiplier);
        }

        hResolution = hResolution || media_factories[Object.keys(media_factories)[0]].width;
        vResolution = vResolution || media_factories[Object.keys(media_factories)[0]].height;

        width = width || calc_width;
        height = height || calc_height;

        photo = new_photo();

        // build the interface
        buildInterface();

        // observe publishing
        CameraTag.observe(photo.uuid, "published", function(published_image) {
          if (photo.uuid == published_image.uuid) {
            state = "published";
            populate_hidden_inputs();
            if (connected) {
              self.disconnect();  
            }
            if (booth) {
              booth.hide();
            }
            self.loadInterface(published_screen);
            if (isUpload && directUpload) {
              var reader = new FileReader();
              reader.addEventListener("load", function() {
                // convert image file to base64 string
                published_img[0].src = reader.result;
              }, false);

              reader.readAsDataURL(file_to_upload);
              
            } else {
              published_img[0].src = review_canvas.getFrame();  
            }
            CameraTag.fire(dom_id, "published", published_image);
            pollForProcessed();
          }
        }, true);

        // failed publish
        CameraTag.observe(photo.uuid, "publishFailed", function(error) {
          throw_error(CT_i18n[34] + ": "+ error.message);
        }, true);

        CameraTag.observe(dom_id, "cameraError", function() {
          throw_error("Error Accessing Your Camera");
        }, true);

        CameraTag.observe(dom_id, "connecting", function() {
          self.loadInterface("none");
        }, true);

        CameraTag.observe(dom_id, "connected", function() {
          connect_callback();
          // self.loadInterface(capture_screen);
        }, true);

        CameraTag.observe(dom_id, "settingsDialogClosed", function() {
          self.loadInterface(start_screen);
        }, true);

        CameraTag.observe(dom_id, "initialized", function() {
          state = "initialized";
          if (!booth) {
            self.loadInterface(mobile_start_screen);
          } else {
            self.loadInterface(start_screen);  
          }
        }, true);    
        

        // register ourself with CameraTag
        CameraTag.photobooths[dom_id] = self;
      }
      else {
        errors.push(server_response.message);
        return
      }
    });
  };

  var buildConstraints = function() {
    if (navigator && navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {
      // audio constraints
      constraints["audio"] = false;

      // device constraints
      if (facingMode && navigator.mediaDevices.getSupportedConstraints().facingMode) {
        constraints["facingMode"] = { ideal: facingMode };
        constraints["video"]["facingMode"] = { ideal: facingMode };
      } else if (selected_cam_id) {
        constraints["video"]["deviceId"] = { ideal: selected_cam_id };
      }
      var aspect_ratio = hResolution / vResolution;
      if (navigator.mediaDevices.getSupportedConstraints().aspect_ratio) {
        constraints["video"]["aspectRatio"] = {ideal: aspect_ratio};
      }
      if (isMobileDevice && aspect_ratio < 1) {
        // always ask for horizontal aspect ratios on mobile and allow orientation metadata to flip it
        constraints["video"]["width"] = {ideal: vResolution};
        constraints["video"]["height"] = {ideal: hResolution};
      } else {
        constraints["video"]["width"] = {ideal: hResolution};
        constraints["video"]["height"] = {ideal: vResolution};
      }
    }
  }

  var updateDevices = function() {
    if (booth.listCameras().length > 0) {
      camera_options.html("");
      $(booth.listCameras()).each(function(index, device){
        var selected = (device.deviceId == selected_cam_id ? "selected" : "");
        var option = $('<option value="'+device.deviceId+'" '+selected+'>'+device.label+'</option>')
        camera_options.append(option);
      })
    }
  }

  var find_custom_screen = function(screen_name) {
    var found_screen;

    found_screen = $(container).find("."+screen_name).addClass("cameratag_photobooth_screen");
    if (found_screen.length == 0) {
      found_screen = $("#"+dom_id+"-"+screen_name).addClass("cameratag_photobooth_screen")
    }

    return found_screen;
  }

  var buildInterface = function() {
    var font_awesome = $('<script src="https://kit.fontawesome.com/3d84f307b4.js" crossorigin="anonymous"></script>');
    $("head").append(font_awesome);

    // container
    container = $('<div class="cameratag_photobooth_container"></div>');
    preview_canvas_placeholder = $('<div class="cameratag_photobooth_canvas_placeholder" style="width:100%; height:100%; overflow:hidden;"></div>');
    container.append(preview_canvas_placeholder);

    // start_screen
    start_screen = find_custom_screen("start-screen");
    if (start_screen.length == 0) {
      var photobooth_start_screen_content_container = $('<div class="photobooth_start_screen_content_container"></div>')
      start_screen = $('<div class="cameratag_photobooth_start_screen cameratag_photobooth_screen"></div>');
      var selection_prompt = $('<a class="cameratag_select_prompt">'+CT_i18n[45]+'</a>');
      
      var action_container = $('<div></div>');
      if (sources.indexOf("record") != -1) {
        var capture_button = $('<a class="cameratag_primary_link cameratag_record_link cameratag_photobooth_capture"><span class="cameratag_action_icon"><i class="fa fa-camera-retro" aria-hidden="true"></i></span><br><span class="cameratag_prompt_label">'+CT_i18n[46]+'</span></a>');
        action_container.append(capture_button)
      }
      if (sources.indexOf("upload") != -1) {
        var upload_button = $('<a id="'+dom_id+'_upload_link" class="cameratag_primary_link cameratag_upload_link cameratag_upload"><span class="cameratag_action_icon">&#61678;</span><br><span class="cameratag_prompt_label">'+CT_i18n[47]+'</span></a>');
        action_container.append(upload_button)
      }
      // var sms_button = "";//$('<a class="cameratag_primary_link cameratag_sms_link"><span class="cameratag_action_icon">&#61707;</span><br><span class="cameratag_prompt_label">'+CT_i18n[7]+'</span></a>');

      // var settings_btn = $('<i class="cameratag_settings_btn fa fa-cog" src="//cameratag.com/assets/gear.png"></i>');
      // start_screen.append(settings_btn);  

      // populate screen
      photobooth_start_screen_content_container.append(selection_prompt).append(action_container);
      start_screen.append(photobooth_start_screen_content_container);
    }

    // mobile start screen
    mobile_start_screen = find_custom_screen("mobile-start-screen");
    if (mobile_start_screen.length == 0) {
      mobile_start_screen = $('<div class="cameratag_photobooth_mobile_start_screen cameratag_photobooth_screen"></div>');
      var selection_prompt = $('<a class="cameratag_select_prompt">'+CT_i18n[49]+'</a>');
      var mobile_button = $('<a class="cameratag_primary_link cameratag_sms_link"><span class="cameratag_action_icon">&#61707;</span><br><span class="cameratag_prompt_label"></span></a>');

      // populate screen
      mobile_start_screen.append(selection_prompt).append(mobile_button);
    }

    // settings screen
    if (gum_supported) {
      settings_screen = $("#"+dom_id+"-settings-screen");
      if (settings_screen.length == 0) {
        settings_screen = $('<div id="'+dom_id+'_settings_screen" class="cameratag_photobooth_screen cameratag_phoobooth_setings_screen"></div>');
      }
    }

    // upload screen
    // upload_screen = $("#"+dom_id+"-upload-screen").addClass("cameratag_photobooth_screen");
    // upload_status = upload_screen.find(".cameratag_photobooth_upload_status");
    // if (upload_screen.length == 0) {
    //   upload_screen = $('<div class="cameratag_photobooth_upload_screen cameratag_photobooth_screen"></div>');
    //   var upload_prompt = $('<div class="cameratag_prompt">'+CT_i18n[10]+'</div>');
    //   upload_status = $('<div class="cameratag_photobooth_upload_status"></div>');
    //   upload_screen.append(upload_status);
    //   upload_screen.append(upload_prompt);
    // }

    // upload_screen
    upload_screen = find_custom_screen("upload-screen");
    upload_status = upload_screen.find(".cameratag_photobooth_upload_status");
    if (upload_screen.length == 0) {
      upload_screen = $('<div class="cameratag_photobooth_upload_screen cameratag_photobooth_screen"></div>');
      var upload_content = `
        <div class="cameratag_upload_content_container">
          <div class="cameratag_progress_bar">
            <div class="cameratag_progress_fill"></div>
          </div>

          <div>
            <span class="cameratag_upload_message">${CT_i18n[10]}</span><span class="cameratag_upload_status"></span>
          </div>
        </div>
      `
      // var upload_prompt = $('<div class="cameratag_prompt">'+CT_i18n[10]+'</div>');
      // var progress = $('')
      // upload_status = $('');
      upload_screen.append(upload_content);
      // upload_screen.append(upload_status);
      // upload_screen.append(upload_prompt);
    }
    // add to DOM
    container.append(upload_screen);

    // capture_screen
    capture_screen = find_custom_screen("capture-screen");
    if (capture_screen.length == 0) {
      capture_screen = $('<div class="cameratag_photobooth_capture_screen cameratag_photobooth_screen"></div>');
      camera_select_container = $('<div class="cameratag_device_selection_container cameratag_cams"><select class="cameratag_camera_options"></select></div>');
      var settings_btn = $('<i class="cameratag_settings_btn fa fa-cog"></i>');
      capture_screen.append(settings_btn);  
      var countdown_overlay = $('<div class="cameratag_countdown_overlay"></div>')
      var trigger_container = $('<div class="cameratag_photobooth_trigger_container"></div>')
      trigger = $('<div class="cameratag_photobooth_trigger"></div>');
      trigger_container.append(trigger);
      
      // populate screen
      capture_screen.append(camera_select_container);
      capture_screen.append(countdown_overlay);
      capture_screen.append(trigger_container);
    }

    camera_options = capture_screen.find(".cameratag_camera_options");


    // review_screen
    review_screen = find_custom_screen("review-screen");
    if (review_screen.length == 0) {
      review_screen = $('<div class="cameratag_photobooth_review_screen cameratag_photobooth_screen"></div>');
    }
    image_frame = $('<div class="cameratag_photobooth_image_frame"></div>');
    review_canvas_placeholder = $('<div class="cameratag_photobooth_review_canvas_placeholer"></div>');
    offset_dragger_container = $('<div class="cameratag_photobooth_offset_dragger_container"></div>');
    offset_dragger = $('<div class="cameratag_photobooth_offset_dragger"></div>');
    offset_dragger_container.append(offset_dragger);

    // hidden by default
    offset_dragger_container.hide();
    //offset_dragger.hide();

    nubs_el = $('<div class="cameratag_photobooth_nubs_el"></div>');
    image_frame.append(review_canvas_placeholder).append(nubs_el).append(offset_dragger_container);

    review_edit_controls = $('<div class="cameratag_review_edit_controls"></div>');
    filter_container = $('<div class="cameratag_photobooth_filter_container"></div>')
    filter_properties = $('<table class="cameratag_photobooth_filter_properties"></div>');
    zoom_slider_container = $('<div class="cameratag_photobooth_filter_property"></div>')
    zoom_slider_title = $('<div class="cameratag_photobooth_filter_property_title">'+CT_i18n[131]+'</div>')
    zoom_slider = $('<div class="cameratag_photobooth_filter_proprty_slider"></div>');
    zoom_slider_container.append(zoom_slider_title).append(zoom_slider);
    apply_button = $('<a class="cameratag_photobooth_apply cameratag_button">'+CT_i18n[127]+'</a>');
    cancel_button = $('<a class="cameratag_photobooth_cancel cameratag_button red">'+CT_i18n[130]+'</a>');
    var filter_toggle = $('<div class="cameratag_filter_control_toggle"><i class="fa-solid fa-angle-down"></i></div>')
    filter_container.append(filter_properties).append(zoom_slider_container);
    review_edit_controls.append(filter_toggle).append(filter_container).append(apply_button).append(cancel_button).append(accept_button).append(retake_button).append('<div style="clear:both"></div>');
    review_ready_controls = $('<div class="cameratag_review_ready_controls"></div>');
    filter_selector = $('<select class="cameratag_photobooth_filter_selector"></select>');
    accept_button = $('<a class="cameratag_photobooth_accept cameratag_button">'+CT_i18n[128]+'</a>');
    retake_button = $('<a class="cameratag_photobooth_retake cameratag_button red">'+CT_i18n[129]+'</a>');
    review_ready_controls.append(retake_button).append(filter_selector).append(accept_button).append('<div style="clear:both"></div>'); 
    
    review_screen.append(image_frame).append(review_edit_controls).append(review_ready_controls);

    $(filter_toggle).click(function(){
      $(review_edit_controls).toggleClass("hidden");
    })
    // end review screen

    // published_screen
    published_screen = find_custom_screen("published-screen");
    if (published_screen.length == 0) {
      published_screen = $('<div class="cameratag_photobooth_published_screen cameratag_photobooth_screen"></div>');
      published_screen.append('<img class="cameratag_photobooth_published_img"></img>');
    }
    published_img = $(published_screen).find(".cameratag_photobooth_published_img");

    // error_screen
    error_screen = find_custom_screen("error-screen");
    if (error_screen.length == 0) {
      error_screen = $('<div class="cameratag_photobooth_error_screen cameratag_photobooth_screen"></div>');
      error_message = $('<div class="cameratag_photobooth_error_message"></div>')

      error_screen.append(error_message);
    } else {
      error_message = $(".cameratag_photobooth_error_message")
    }

    // device selection screen
    // device_selection_screen = find_custom_screen("device-selection-screen");
    // if (device_selection_screen.length == 0) {
    //   device_selection_screen = $('<div class="cameratag_photobooth_screen cameratag_select"></div>');
    //   var device_selection_prompt = $('<div class="cameratag_prompt"></div>');
    //   var device_selection_save_btn = $('<a class="cameratag_save_device_selection">Save Settings</a>');
    //   camera_options = $('<select class="cameratag_camera_options"></select>');
    //   device_selection_prompt.append(device_selection_save_btn).append('<i class="fa fa-video-camera" aria-hidden="true"></i>').append(camera_options);
    //   device_selection_screen.append(device_selection_prompt);
    // } else {
    //   camera_options = device_selection_screen.find(".cameratag_camera_options");
    // }

    // wait_screen
    wait_screen = find_custom_screen("wait-screen");
    if (wait_screen.length == 0) {
      wait_screen = $('<div class="cameratag_photobooth_wait_screen cameratag_photobooth_screen"></div>');
      var spinner = $('<div class="cameratag_spinner"><div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div><div class="cameratag_photobooth_wait_message">'+CT_i18n[16]+'</div></div>');
      wait_screen.append(spinner);
    }
    wait_message = wait_screen.find(".cameratag_photobooth_wait_message");

    // hidden inputs
    container.append("<input id='"+input_name+"_uuid' type='hidden' name='"+input_name+"_uuid' value='"+photo.uuid+"'>");
    $.each(media_factories, function(index, factory){
      container.append("<input id='"+input_name+"_"+factory.name+"' type='hidden' name='"+input_name+"_"+factory.name+"' value=''>");
    });

    // device selectors
    camera_options.change(function(){
      var camera_id = camera_options.val();
      self.disconnect();
      selected_cam_id = camera_id;
      booth.setCamera(camera_id);
      self.connect();
    })

    // build the container
    container.css({width: width+"px", height: height+"px"})
    container.append(start_screen);
    container.append(mobile_start_screen);
    container.append(capture_screen);
    container.append(upload_screen);
    container.append(review_screen);
    container.append(error_screen);
    container.append(wait_screen);
    container.append(published_screen);
    container.append(settings_screen);
    container.append(device_selection_screen);

    // set font size
    font_size = parseInt($(container).width() / 22);
    if (font_size < 12) {
      font_size = 12;
    }
    $(container).css({fontSize: font_size+"px"});  

    // observe the things
    // container.find(".cameratag_settings_btn").click(function(e){
    //   e.stopPropagation();
    //   self.selectDevices();
    // });
    // container.find(".cameratag_save_device_selection").click(function(){
    //   self.disconnect();
    //   self.loadInterface(start_screen);
    // });

    // build the effects screen instance
    review_canvas = new ImageProcessor(review_canvas_placeholder);


    // populate the filters
    var html = '';
    for (var i = 0; i < review_canvas.filters.length; i++) {
        html += '<option value='+i+'>' + review_canvas.filters[i].name + '</option>';
    }
    $(container).find(".cameratag_photobooth_filter_selector").html(html);

    // event observers
    $(container).find(".cameratag_photobooth_capture").click(function(){
      self.connect();
    });
    $(container).find(".cameratag_photobooth_trigger").click(self.takePicture);
    $(container).find(".cameratag_photobooth_accept").click(self.publish);
    $(container).find(".cameratag_photobooth_apply").click(self.applyFilter);
    $(container).find(".cameratag_photobooth_cancel").click(self.cancelFilter);
    $(container).find(".cameratag_photobooth_retake").click(function(){
      self.connect();
    });
    container.find(".cameratag_settings_btn").click(function(e){
      camera_select_container.toggleClass("visible");
    });

    // filter selector
    $(container).find(".cameratag_photobooth_filter_selector").change(function(){
      review_canvas.select_filter( $(this).val() );
      review_canvas.draw(frame_data);
    });

    // drage handle for cropping
    offset_dragger.draggable({
      scroll: false,
      drag: function(e, ui){
        //console.log("UIx:"+ui.position.left+" UIy:"+ui.position.top+" xOffset:"+max_x_offset+" yOffset:"+max_y_offset+" milti:"+preview_multiplier);
        var left_offset = ui.position.left - (max_x_offset / preview_multiplier);
        var top_offset = ui.position.top - (max_y_offset / preview_multiplier);
        review_canvas.setOffset(left_offset * preview_multiplier, top_offset * preview_multiplier)
        review_canvas.draw();
      }
    })

    zoom_slider.slider({
      slide: function(e, ui) {
        review_canvas.setUserZoom(ui.value);
        review_canvas.draw();
      },
      change: function(e, ui) {
        review_canvas.setUserZoom(ui.value);
        review_canvas.draw();
      },
      min: 1,
      max: 3,
      value: 1,
      step: .01
    });


    // accessaory interface elements
    shutter_sound = new Audio('//'+appServer+'/static/'+CameraTag.version+'/shutter.ogg');

    // add the container to the
    $(booth_el).replaceWith(container);

    var defaultStack = CameraTag.defaultStack("photobooth");

    // manual stack selection
    if (manual_stack && (manual_stack.toLowerCase() == "flash" || manual_stack.toLowerCase() == "mediarecorder")) {
      if (manual_stack.toLowerCase() == "flash") {
        throw_error("Flash recording stack no longer supported");
      }
      else if (manual_stack.toLowerCase() == "mediarecorder") {
        booth = new WebRTCBooth(preview_canvas_placeholder);
      }
    }

    // default stack selection
    else {
      if (defaultStack == "MediaRecorder") {
        booth = new WebRTCBooth(preview_canvas_placeholder); // this is not a typo - the booth is just poorly named
      } 
      else if (defaultStack == "Unsupported") {
        throw_error("Unsupported browser");
      }
    }

    // build uploader
    if (!booth) {
      create_uploader(mobile_start_screen);    
    }
    else {
      var browse_el = start_screen.find(".cameratag_upload")[0];
      create_uploader( browse_el );
    }

  }

  self.stack = function() {
    return booth.stack;
  }

  self.getPhoto = function() {
    return photo
  }

  var new_photo = function() {
    var new_photo = {};
    new_photo.uuid = generateUUID("i-");  
    
    // setup video medias
    new_photo.medias = {};
    if (media_factories) {
      $.each(media_factories, function(name, factory){
        new_photo.medias[name] = null;
      })
    }
    
    return new_photo;
  }


  var pollForProcessed = function() {
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/apps/"+camera_uuid+"/assets/"+photo.uuid+".json",
      type:"get",
      data: {
        referer: window.location.toString()
      },
      success: function(response, textStatus, jqXHR) {
        if (response.state && response.state == "processed") {
          CameraTag.fire(photo.uuid, "processed", response);
          CameraTag.fire(dom_id, "processed", response);
        } 
        else if (response.state && response.state == "error") {
          CameraTag.fire(photo.uuid, "processingFailed", response);
          CameraTag.fire(dom_id, "processingFailed", response);
        }
        else {
          processed_timer = setTimeout(pollForProcessed, 2000);
        }
      },
      error: function(jqXHR, textStatus, errorThrown) {
        processed_timer = setTimeout(pollForProcessed, 2000);
        CameraTag.fire(dom_id, "processingPollingError", {
          jqXHR: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
      }
    })
  }


  self.reset = function() {
    photo = new_photo();
    if (!booth) {
      self.loadInterface(mobile_start_screen);
    } else {
      self.loadInterface(start_screen);  
    }

    file_to_upload = null;
    isUpload = null;

    if (booth) {
      booth.show();
    }

    // clear hidden inputs
    $("#"+input_name+"_uuid").val(photo.uuid);
    $.each(media_factories, function(name, factory){
      $("#"+input_name+"_"+name).val("");
      photo.medias[name] = "";
    });

    // observe publishing
    CameraTag.observe(photo.uuid, "published", function(published_image) {
      if (photo.uuid == published_image.uuid) {
        state = "published";
        populate_hidden_inputs();
        if (connected) {
          self.disconnect();  
        }
        if (booth) {
          booth.hide();
        }
        self.loadInterface(published_screen);
        published_img[0].src = review_canvas.getFrame();
        CameraTag.fire(dom_id, "published", published_image);
        pollForProcessed();
      }
    }, true);

    // failed publish
    CameraTag.observe(photo.uuid, "publishFailed", function(error_msg) {
      throw_error(CT_i18n[34] + ": "+ error_msg.message.error);
    }, true);
  }

  var populate_hidden_inputs = function() {
    $("#"+input_name+"_uuid").val(photo.uuid);
    $.each(media_factories, function(name, factory){
      var media_url = "//"+appServer+"/assets/"+photo.uuid+"/"+name+"."+factory.extension
      $("#"+input_name+"_"+name).val(media_url);
      photo.medias[name] = media_url;
    });
  };

  self.setMetadata = function(js_object) {
    if (typeof(js_object) != "object") {
      console.warn("setMetadata only accepts Javascript Objects");
      return;
    }

    // set for future use
    metadata_object = js_object;

    // if we've already published send the data to the server
    if (state == "published") {
      var json_string = JSON.stringify(js_object);
      
      $.ajax({
        url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+camera_uuid+"/assets/"+photo.uuid+"/metadata.json",
        data:{form_data: json_string},
        type:"post",
        success: function(response) {
          return true
        },
        error: function(jqXHR, textStatus, errorThrown) {
          throw_error(CT_i18n[35]);
          CameraTag.fire(dom_id, "metadataError", {
            jqXHR: jqXHR,
            textStatus: textStatus,
            errorThrown: errorThrown
          });
          return false;
        }
      })
    }
  }

  var throw_error = function(message) {
    error_message.html(message);
    self.loadInterface(error_screen, true);
  };

  self.applyFilter = function() {
    review_canvas.applyFilter();
  }

  var resetZoom = function() {
    if (review_canvas) {
      review_canvas.setUserZoom(1);
      // This seemed to be moving the image after effects were applied
      //review_canvas.setOffset(0,0);
    }
  }

  self.cancelFilter = function() {
    resetZoom();
    review_canvas.select_filter(0);
  }

  var wait = function(message) {
    wait_message.html(message);
    self.loadInterface(wait_screen);
  }

  var error = throw_error;

  self.connect = function(callback) {
    if (gum_supported && !window.isSecureContext && adapter.browserDetails.browser != "safari") {
      alert(CT_i18n[109]);
      return;
    }
    connect_callback = callback || function(){
      self.loadInterface(capture_screen);
      updateDevices();
    };

    if (booth) {
      booth.connect();
    }
  };

  self.disconnect = function() {
    booth.disconnect();
    connected = false;
  }

  self.takePicture = function() {
    camera_select_container.removeClass("visible");
    if (countdown > 0) {
      $(container).find(".cameratag_photobooth_trigger_container").addClass("hidden");
      $(container).find(".cameratag_countdown_overlay").addClass("visible");
      $(container).find(".cameratag_countdown_overlay").html(countdown);
      countdown = countdown - 1;
      setTimeout(self.takePicture, 1000); 
    } else {
      $(container).find(".cameratag_countdown_overlay").removeClass("visible");
      setTimeout(function(){
        $(container).find(".cameratag_photobooth_trigger_container").removeClass("hidden");
      }, 1000);
      countdown = preRollLength;
      reviewSnapshot( booth.getFrame() );  
    }
    
  }

  self.back = function() {
    destination = last_screen;
    last_screen = start_screen;

    container.find(".cameratag_photobooth_screen").removeClass("visible");

    if (destination != "none") {
      destination.addClass("visible")
    }
  }

  // self.selectDevices = function() {
  //   self.connect(function(){
  //     updateDevices();
  //     self.loadInterface(device_selection_screen);
  //   });
  // }

  self.loadInterface = function(new_screen) {
    last_screen = current_screen;
    current_screen = new_screen;
    container.find(".cameratag_photobooth_screen").removeClass("visible");

    if (new_screen != "none") {
      new_screen.addClass("visible")
    }
  };

  self.select_filter = function(filter_index) {
    review_canvas.select_filter(filter_index);
    CameraTag.fire(dom_id, "filterSelected", filter_index);
  };

  self.publish = function(){
    CameraTag.fire(dom_id, "publishing");
    self.loadInterface(upload_screen);
    if (connected) {
      self.disconnect();  
    }
    if (isUpload && directUpload) {
      var file_handle = file_to_upload;
    } else {
      var file_handle = dataURItoBlob( review_canvas.getFrame() );  
    }
    
    uploader.add({
      name: 'recordings/' + photo.uuid + '.jpg',
      file: file_handle,
      complete: function(){
        publish_asset({
          original_filename: photo.uuid+".jpg",
          original_url: "https://cameratag-upload.s3.amazonaws.com/recordings/"+photo.uuid+".jpg",
          camera_uuid: camera_uuid,
          asset_uuid: photo.uuid, 
          asset_type: "Photo",
          type: "webcam", 
          signature: signature, 
          signature_expiration: signature_expiration,
          metadata: metadata_object,
          asset_name: asset_name, 
          asset_description: asset_description
        });
      },
      progress: function(progress) {
        // upload_status.html((progress * 100).toFixed(1) + "%");
        var percent = (progress * 100) + "px";
        $(container).find(".cameratag_progress_fill").css({width: percent});
        CameraTag.fire(dom_id, "uploadProgress", progress);
      },
      error: function(error) {
        throw_error("There was an error uploading your file");
        CameraTag.fire(dom_id, "uploadAborted", {
          error: jqXHR,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
        return;
      }
    })
  }

  var create_uploader = function(browse_element) {
    var upload_input = $('<input id="'+dom_id+'_upload_file" style="position:absolute;" type="file" accept="image/*">')
    $(start_screen).append(upload_input);
      
    // hide it for now
    $(upload_input).css({
      left: -99999,
      top: -99999,
      width: 1,
      height: 1,
      opacity: 0
    });
    
    if (browse_element) {
      $(upload_input).css({
        left: $(browse_element).offset().left - $(browse_element).offsetParent().offset().left,
        top: $(browse_element).offset().top - $(browse_element).offsetParent().offset().top,
        width: $(browse_element).width(),
        height: $(browse_element).height(),
        opacity: 0
      })
    
      $(browse_element).css({
        zIndex: 1
      })
      $(browse_element).click(function(e){
        if (e.target != upload_input[0]) {
          e.stopPropagation();
          $(upload_input).click();
        }
      })  
    }
    
    

    $(upload_input).change(function(evt){
      self.selectFile(evt.target.files[0])
    });

    uploader = {};

    upload_input.fileupload({
      type: 'POST',
      autoUpload: false,
      paramName: 'file', // S3 does not like nested name fields i.e. name="user[avatar_url]"
      dataType: 'XML',  // S3 returns XML if success_action_status is set to 201
      replaceFileInput: false,
      progressall: function (e, data) {
        var progress = data.loaded / data.total;
        uploader.progress(progress);
      },
      start: function (e) {
        // console.log("starting upload");
      },
      done: function(e, data) {
        // console.log("done uploading");
        uploader.complete();
      },
      fail: function(e, data) {
        // console.log("UPLOAD FAIL!");
        uploader.error(e);
      }
    });


    uploader.add = function(opts) {
      uploader.progress = opts.progress;
      uploader.complete = opts.complete;
      uploader.error = opts.error;
      
      $.ajax({
        url: 'https://'+appServer+'/api/v'+CameraTag.version+'/assets/upload_signature2',
        data: {
          key: opts.name
        },
        dataType: "json",
        success: function(upload_sign_response) {
          upload_input.fileupload('send', {
            files: [ opts.file ],
            url: upload_sign_response.url,
            formData: upload_sign_response.formData
          });
        }
      })
    }
  }

  self.destroy = function() {
    if (connected) {
      self.disconnect();
    } 
    delete CameraTag.photobooths[dom_id];
    container.remove();

    // copy old callbacks to temp then kill them
    if (callbacks[dom_id]["destroyed"]) {
      var destroy_callbacks = callbacks[dom_id]["destroyed"].slice();
    } else {
      var destroy_callbacks = [];
    }
    callbacks[dom_id] = {}
    // run destroy_callbacks callbacks
    if (destroy_callbacks) {
      setTimeout(function(){
        for( i = 0; i < destroy_callbacks.length; i++ ) {
          try {
            destroy_callbacks[i]();
          }
          catch(err) {}
        }  
      }, 750);
    }
  }

  self.selectFile = function(file_handle) {
    isUpload = true;
    // straight upload
    if (directUpload) {
      file_to_upload = file_handle;
      self.publish(true);
      return;
    }

    // get file extension
    var ext = file_handle.name.split(".")
    ext = ext[ext.length-1];
    ext = ext.toLowerCase();

    EXIF.getData(file_handle, function() {
      // if (Object.keys(files[0].exifdata).length == 0) {
      //   alert("We were unable to process the file you selected. Please try another.");
      //   return;
      // } 

      exif_orientaion = file_handle.exifdata.Orientation || 1;

      if (window.File && window.FileReader && window.FileList && window.Blob) {
        // Only process image files.
        if ( !file_handle.type.match('image.*') ) {
          if ( !confirm(CT_i18n[42]) ) {
            return;
          }
        }

        var reader = new FileReader();
        reader.addEventListener("load", function () {
          reviewSnapshot(reader.result);
        }, false);
        reader.readAsDataURL(file_handle);
        if (!skip_zoom) {
          self.select_filter(1);
        }
      }
      else {
        alert('The File APIs are not fully supported in this browser.');
      }
    });
  }

  var reviewSnapshot = function(image_data) {
    state = "reviewing";
    if (connected) {
      self.disconnect();
    }
    // shutter_sound.play();

    // validate the image
    var img = new Image();
    img.addEventListener("error",function(){
      alert(CT_i18n[108]);
      CameraTag.fire(dom_id, "invalidImage");
      self.loadInterface(start_screen);
      return;
    });
    img.src = image_data; 

    review_canvas.draw(image_data);
    setTimeout(function(){
      self.loadInterface(review_screen);
      CameraTag.fire(dom_id, "photoTaken");  
    }, 100)
  }

  var dataURItoBlob = function(dataURI) {
      // convert base64/URLEncoded data component to raw binary data held in a string
      var byteString;
      if (dataURI.split(',')[0].indexOf('base64') >= 0)
          byteString = atob(dataURI.split(',')[1]);
      else
          byteString = unescape(dataURI.split(',')[1]);

      // separate out the mime component
      var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

      // write the bytes of the string to a typed array
      var ia = new Uint8Array(byteString.length);
      for (var i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
      }

      return new Blob([ia], {type:mimeString});
  }

  init();
};
    CameraTagPhoto = function(photo_el, opts) {
  opts = opts || {};

  var self = this;
  var asset_id = $(photo_el).attr("data-uuid");
  var dom_id = $(photo_el).attr("id");
  var signature = $(photo_el).attr("data-signature");
  var expiration = $(photo_el).attr("data-signature-expiration");

  asset_id = opts["asset_id"] == null ? asset_id : opts["asset_id"]
  dom_id = opts["dom_id"] == null ? dom_id : opts["dom_id"]
  signature = opts["signature"] == null ? signature : opts["signature"]
  expiration = opts["expiration"] == null ? expiration : opts["expiration"]

  var asset;
  var width;
  var height;
  var thumb_url;
  
  var init = function() {
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/assets/"+asset_id+".json?signature="+signature+"&signature_expiration="+expiration,
      type: "get",
      success: function(response){
        asset = response;

        var thumbnail_medias = [];
        for (var key in asset.medias) {
          if (asset.medias[key].state == "COMPLETED" && (asset.medias[key].media_type == "photo" || asset.medias[key].media_type == "thumb" || asset.medias[key].media_type == "small_thumb")) {
            thumbnail_medias.push(asset.medias[key]);
          }
        }

        if (thumbnail_medias.length > 0) {
          var default_width = thumbnail_medias[0].width;
          var default_height = thumbnail_medias[0].height;
          if (default_width > 640) {
            default_width = default_width / 2;
            default_height = default_height / 2;
          }
        } else {
          default_width = 640;
          default_height = 360;
        }

        thumb_url = thumbnail_medias[0].urls["cameratag"];
        width = $(photo_el).attr("data-width") || default_width;
        height = $(photo_el).attr("data-height") || default_height;

        renderImage();
      }
    });

    CameraTag.photos[dom_id] = self;
  }

  var renderImage = function() {
    var new_img = $('<img id="'+dom_id+'" src="'+thumb_url+'?signature='+signature+'&signature_expiration='+expiration+'"></img>')
    new_img.css({width: width, height: height});
    new_img.attr("style", $(photo_el).attr("style"));
    $(photo_el).replaceWith(new_img);
  }

  init();
}
    var CameraTagRoom = function(room_el, opts) {
  opts = opts || {};
  
  var self = this;

  var current_room;
  
  var outer_container;
  var start_screen;
  var device_selection_screen;
  var lobby_screen;
  var lobby_timer;
  var chat_screen;
  var error_screen;
  var error_message;
  var progress_bar;
  var screenSharing = false;
  var current_cam_id;
  var current_mic_id;

  var streams_container;
  var controls_container;

  // these come from the server
  var room_id;
  var local_stream_id;
  var token;
  var current_streams = []

  var webRTCAdaptor;

  var connected = false;

  var tick_interval;
  var room_info_interval;
  var duration;
  var disconnect_warning_duration = 30;

  var local_video_el = false;
  var mute_check_interval;


  //
  // GENERATED FROM SCHEMA
  //
    var id = opts["id"] || $(room_el).attr("data-id") || $(room_el).attr("") || "myRoomTag1";


    var room_name = opts["room_name"] || $(room_el).attr("data-room_name") || $(room_el).attr("") || "room_name";


    var user_name = opts["user_name"] || $(room_el).attr("data-user_name") || $(room_el).attr("") || null;


    var start_time = opts["start_time"] || $(room_el).attr("data-start_time") || $(room_el).attr("") || null;


    var end_time = opts["end_time"] || $(room_el).attr("data-end_time") || $(room_el).attr("") || null;


    var disconnect_warning_duration = opts["disconnect_warning_duration"] || $(room_el).attr("data-disconnect_warning_duration") || $(room_el).attr("") || 30;


    var signature = opts["signature"] || $(room_el).attr("data-signature") || $(room_el).attr("") || null;


    var signatureExpiration = opts["signatureExpiration"] || $(room_el).attr("data-signatureExpiration") || $(room_el).attr("") || null;


    var auto_connect = opts["auto_connect"] || $(room_el).attr("data-auto_connect") || $(room_el).attr("") || true;


    var auto_publish = opts["auto_publish"] || $(room_el).attr("data-auto_publish") || $(room_el).attr("") || true;


    var view_only = opts["view_only"] || $(room_el).attr("data-view_only") || $(room_el).attr("") || false;


    var max_length = opts["max_length"] || $(room_el).attr("data-max_length") || $(room_el).attr("") || 3600;


    var skipFontAwesome = opts["skipFontAwesome"] || $(room_el).attr("data-skipFontAwesome") || $(room_el).attr("data-skip-font-awesome") || false;




  //
  // END FORM SCHEMA VARS
  //

  // backwards compatability
  var dom_id = $(room_el).attr("id");
  var app_uuid = $(room_el).attr("data-appId") || $(room_el).attr("data-uuid") || $(room_el).attr("data-app-id") || $(room_el).attr("id");
  var expiration = signatureExpiration;

  var init = function() {

    
    // parse variables from dom
    // dom_id = $(room_el).attr("id") || parseInt(Math.random() * 1000000000000);
    // app_uuid = $(room_el).attr("data-app-id");
    // room_name = $(room_el).attr("data-room");
    // expiration = $(room_el).attr("data-signature-expiration");
    // user_name = $(room_el).attr("data-user");
    // signature = $(room_el).attr("data-signature");
    // auto_connect = $(room_el).attr("data-auto-connect") != "false";
    // auto_publish = $(room_el).attr("data-auto-publish") != "false";
    // view_only = $(room_el).attr("data-view-only") == "true";
    // max_length = parseInt( $(room_el).attr("data-max-length") );
    // start_time = $(room_el).attr("data-start-time");
    // end_time = $(room_el).attr("data-end-time");
    // disconnect_warning_duration = $(room_el).attr("data-disconnect-warning") || disconnect_warning_duration
    // skipFontAwesome = $(room_el).attr("data-skip-font-awesome") == "true";

    // dom_id = opts["dom_id"] == null ? dom_id : opts["dom_id"]
    // app_uuid = opts["app_uuid"] == null ? app_uuid : opts["app_uuid"]
    // room_name = opts["room_name"] == null ? room_name : opts["room_name"]
    // expiration = opts["expiration"] == null ? expiration : opts["expiration"]
    // user_name = opts["user_name"] == null ? user_name : opts["user_name"]
    // signature = opts["signature"] == null ? signature : opts["signature"]
    // auto_connect = opts["auto_connect"] == null ? auto_connect : opts["auto_connect"]
    // auto_publish = opts["auto_publish"] == null ? auto_publish : opts["auto_publish"]
    // view_only = opts["view_only"] == null ? view_only : opts["view_only"]
    // max_length = opts["max_length"] == null ? max_length : opts["max_length"]
    // start_time = opts["start_time"] == null ? start_time : opts["start_time"]
    // end_time = opts["end_time"] == null ? end_time : opts["end_time"]
    // disconnect_warning_duration = opts["disconnect_warning_duration"] == null ? disconnect_warning_duration : opts["disconnect_warning_duration"]
    // skipFontAwesome = opts["skipFontAwesome"] == null ? skipFontAwesome : opts["skipFontAwesome"]
    

    // if (max_length && max_length > 3600) {
    //   max_length = 3600;
    // } else if (max_length && max_length < 3600) {
    //   // we're good
    // } else {
    //   max_length = 1200;
    // }

    if (!dom_id) {
      throw_error("noInstanceId", CT_i18n[112]);
    } 
    else if(!app_uuid) {
      throw_error("noAppId", CT_i18n[113]);
    } else {
      buildInterface();  
    }

    CameraTag.rooms[dom_id] = self;

    CameraTag.fire(dom_id, "initialized");
  }

  self.connect = function() {
    room_name = $(outer_container).find(".cameratag_room_name").val() || room_name;

    if (view_only) {
      var rnd = parseInt(Math.random() * 1000000000000)
      user_name = "lurker" + rnd;
    } else {
      user_name = $(outer_container).find(".cameratag_user_name").val() || user_name;
    }
  
    if (!room_name) {
      alert(CT_i18n[140]);
      return;
    }

    if (!user_name) {
      alert(CT_i18n[141]);
      return;
    }

    // get room_id and local_stream_id from server
    $.ajax({
      url: "https://"+appServer+"/api/v"+CameraTag.version+"/cameras/"+app_uuid+"/rooms/init.json", 
      method: "POST",
      data: {
        name: room_name,
        expiration: expiration,
        signature: signature,
        user_name: user_name,
        start_time: start_time,
        end_time: end_time,
        max_length: max_length
      },
      success: function(response) {
        if (response.asset_id) {
          current_room = response.room;
          current_room.start_time = new Date(current_room.start_time);
          current_room.end_time = new Date(current_room.end_time);
          
          if (current_room.start_time > new Date()) {
            // put them in the lobby
            self.showScreen("lobby-screen");
            clearInterval(tick_interval);
            tick_interval = setInterval(tick, 1000);
          } else {
            self.showScreen("chat-screen");

            room_id = response.room.id;
            local_stream_id = response.asset_id + "_" + user_name;

            if (!view_only) {
              // prep local container for video
              createRemoteVideo(local_stream_id);  
            }
            
            // create webrtc interface
            createAdapter();  
          }
          
        } else if (response.success == false) {
          throw_error(response.error, response.message);
        } else {
          throw_error("unkmownError", "An unknown error has occured.");
        }
      }
    })
  }


  self.disconnect = function() {
    clearInterval(tick_interval);
    $(disconnect_warning).hide();
    webRTCAdaptor.leaveFromRoom(room_id);
    webRTCAdaptor.stop(local_stream_id);
    webRTCAdaptor.closeStream(local_stream_id);
    webRTCAdaptor.closePeerConnection();
    $(streams_container).html("");
    // current_streams = []; // not needed?
    //self.showStartScreen();
    $(progress_bar).css({width: "0%"});
    self.showScreen("start-screen");
    outer_container.find(".cameratag_stream_mute_mic").removeClass("enabled");
    outer_container.find(".cameratag_stream_mute_mic").removeClass("fa-microphone-slash");
    outer_container.find(".cameratag_stream_mute_mic").addClass("fa-microphone");

    outer_container.find(".cameratag_stream_mute_mic").removeClass("enabled");
    outer_container.find(".cameratag_stream_mute_mic").removeClass("fa-video-slash");
    outer_container.find(".cameratag_stream_mute_mic").addClass("fa-video");
  }

  self.showScreen = function(screen_name) {
    $(outer_container).find(".cameratag_room_screen").hide();
    $(outer_container).find(".cameratag-"+screen_name).show();
  }

  self.toggleScreenShare = function() {
    if (screenSharing) {
      self.stopScreenShare();
    } else {
      self.startScreenShare();
    }
  }

  self.startScreenShare = function() {
    webRTCAdaptor.switchDesktopCapture(local_stream_id, current_cam_id);
    screenSharing = true;
    $(outer_container).find(".cameratag_stream_share_screen").css({color:"#0f0"});
  }

  self.stopScreenShare = function() {
    webRTCAdaptor.switchVideoCameraCapture(local_stream_id, current_cam_id);
    screenSharing = false;
    $(outer_container).find(".cameratag_stream_share_screen").css({color:"#fff"});
  }

  self.getStreams = function() {
    return current_streams;
  }

  var createAdapter = function() {
    // crete the webRTC adatper
    if (view_only) {
      var mediaConstraints = undefined;
      var localVideoId = undefined;
    } else {
      var mediaConstraints = {
        video : {
          width: {ideal: 640},
          height: {ideal: 480}
        },
        audio : true
      };
      var localVideoId = local_stream_id;
    }

    webRTCAdaptor = new WebRTCAdaptor({
      websocket_url : "wss://stream.cameratag.com/Stream/websocket",
      mediaConstraints : mediaConstraints,
      peerconnection_config : null,
      sdpConstraints : {
        OfferToReceiveAudio : true,
        OfferToReceiveVideo : true
      },
      localVideoId : localVideoId,
      isPlayMode : view_only,
      debug : true,
      dataChannelEnabled : true,
      callback : (info, obj) => {
        console.log("EVENT: "+info);

        if (info == "initialized") {
          onInitialized(info, obj);
        } 
        else if (info == "joinedTheRoom") {
          onJoinRoom(info, obj);
        }
        else if (info == "newStreamAvailable") {
          console.log("new stream available!!");
          playStream(obj);
        } 
        else if (info == "publish_started") {
          onPublishStarted(info, obj);
        } 
        else if (info == "publish_finished") {
          onPublishFinished(info, obj);
        } 
        else if (info == "screen_share_stopped") {
          console.log("screen share stopped");
        }
        else if (info == "browser_screen_share_supported") {
          // screen_share_checkbox.disabled = false;
          // camera_checkbox.disabled = false;
          // screen_share_with_camera_checkbox.disabled = false;
          console.log("browser screen share supported");
          // browser_screen_share_doesnt_support.style.display = "none";
        } 
        else if (info == "leavedFromRoom") {
          onLeaveRoom(info, obj);
        } 
        else if (info == "closed") {
          onConnectionClosed(info, obj);
        } 
        else if (info == "play_finished") {
          onPlayFinished(info, obj);
        } 
        else if (info == "streamInformation") {
          onStreamInformation(obj);
        } 
        else if (info == "roomInformation") {
          console.log("ROOM INFO!");
          //Checks if any new stream has added, if yes, plays.
          for(let str of obj.streams){
            if(!current_streams.includes(str)){
              webRTCAdaptor.play(str, token, room_id);
            }
          }
          // Checks if any stream has been removed, if yes, removes the view and stops webrtc connection.
          for(let str of current_streams){
            if(!obj.streams.includes(str)){
              removeRemoteVideo(str);
            }
          }
          //Lastly updates the current streamlist with the fetched one.
          current_streams=obj.streams;

          //Check video tracks active/inactive status
          checkVideoTrackStatus(current_streams);
        }
        else if (info == "data_channel_opened") {
          console.log("Data Channel open for stream id", obj );
          isDataChannelOpen = true;
        } 
        else if (info == "data_channel_closed") {
          console.log("Data Channel closed for stream id", obj );
          isDataChannelOpen = false;
        } 
        else if(info == "data_received") {
          handleNotificationEvent(obj);
        }
      },
      callbackError : function(error, message) {
        //some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError

        if(error.indexOf("publishTimeoutError") != -1 && roomTimerId != null){
          clearInterval(roomTimerId);
        }

        console.log("error callback: " + JSON.stringify(error));
        var errorMessage = JSON.stringify(error);
        if (typeof message != "undefined") {
          errorMessage = message;
        }
        var errorMessage = JSON.stringify(error);
        if (error.indexOf("NotFoundError") != -1) {
          errorMessage = CT_i18n[142];
        } else if (error.indexOf("NotReadableError") != -1
            || error.indexOf("TrackStartError") != -1) {
          errorMessage = CT_i18n[132];
        } else if (error.indexOf("OverconstrainedError") != -1
            || error.indexOf("ConstraintNotSatisfiedError") != -1) {
          errorMessage = CT_i18n[133]
        } else if (error.indexOf("NotAllowedError") != -1
            || error.indexOf("PermissionDeniedError") != -1) {
          errorMessage = CT_i18n[134];
        } else if (error.indexOf("TypeError") != -1) {
          errorMessage = CT_i18n[135];
        } else if (error.indexOf("UnsecureContext") != -1) {
          errorMessage = CT_i18n[136];
        } else if (error.indexOf("WebSocketNotSupported") != -1) {
          errorMessage = CT_i18n[137];
        } else if (error.indexOf("no_stream_exist") != -1) {
          //TODO: removeRemoteVideo(error.streamId);
        } else if(error.indexOf("data_channel_error") != -1) {
          errorMessage = CT_i18n[138];
        } else if (error.indexOf("ScreenSharePermissionDenied") != -1) {
          errorMessage = CT_i18n[139];
        } 

        throw_error("webRTCError", errorMessage);
      }
    });

  }


  var onInitialized = function(info, obj) {
    // console.log("initialized");
    webRTCAdaptor.joinRoom(room_id, local_stream_id, "mcu");

    // reset the fields
    $("#"+dom_id+" .cameratag_video_sources").html("");
    $("#"+dom_id+" .cameratag_audio_sources").html("");

    // populate devices
    navigator.mediaDevices.enumerateDevices().then(function(devices){
      current_cam_id = webRTCAdaptor.videoTrack.getSettings().deviceId;
      current_mic_id = webRTCAdaptor.audioTrack.getSettings().deviceId;
      
      $(devices).each(function(index, device){
        var device_name = (device.label == "" ? device.deviceId : device.label);
        
        if (device.kind === 'videoinput') {
          var selected = device.deviceId == current_cam_id ? "selected" : "";
          $("#"+dom_id+" .cameratag_video_sources").append('<option value="'+device.deviceId+'" '+selected+'>'+device_name+'</option>')


        } else if (device.kind === 'audioinput') {
          var selected = device.deviceId == current_mic_id ? "selected" : "";
          $("#"+dom_id+" .cameratag_audio_sources").append('<option value="'+device.deviceId+'"  '+selected+'>'+device_name+'</option>')
        }
      })
    })
  }

  var onStreamInformation = function(obj) {
    webRTCAdaptor.play(obj.streamId, token, room_id);
  }

  // var checkTracks = function() {
  //   if (!local_video_el) {
  //     local_video_el = $("#localVideo")[0];
  //     // console.log("new local video found");
  //   }
  //   if (local_video_el.srcObject.getVideoTracks()[0].muted) {
  //     // console.log("muted: disconnecting");
  //     self.disconnect();
  //   } else {
  //     // console.log("not muted");
  //   }
  // }


  function checkVideoTrackStatus(streamsList){
    streamsList.forEach(function(item) {
      var video = document.getElementById("remoteVideo"+item);
      if(video != null && !video.srcObject.active){
        removeRemoteVideo(item);
        playVideo(item);
      }
    });
  }

  var onJoinRoom = function(info, obj) {
    connected = true;

    // mute_check_interval = setInterval(checkTracks, 1000);

    var room = obj.ATTR_ROOM_NAME;
    console.log("joined the room: " + room_id + " with stream id "+ obj.streamId);
    console.log(obj);

    // publish!
    if (!view_only && auto_publish) {
      self.startPublishing();
    }

    // get existing streams?
    if (obj.streams != null) {
      obj.streams.forEach(function(item) {
        console.log("Stream joined with ID: "+item);
        webRTCAdaptor.play(item, token, room);
      });
      current_streams = obj.streams;
    }

    // kick off the timer?
    clearInterval(tick_interval);
    tick_interval = setInterval(tick, 1000);

    // poll the room
    room_info_interval = setInterval(function(){
      webRTCAdaptor.getRoomInfo(room_id, local_stream_id);
    }, 5000);

    CameraTag.fire(dom_id, "connected");
  }

  var tick = function() {
    var total_seconds = parseInt( (current_room.end_time - current_room.start_time) / 1000 );
    var seconds_to_open = parseInt( (current_room.start_time - new Date()) / 1000 );
    var seconds_to_close = parseInt( (current_room.end_time - new Date()) / 1000 );

    // disconnect warning
    if (seconds_to_close <= disconnect_warning_duration) {
      disconnect_warning.html("disconnecting in "+formatted_seconds(seconds_to_close));
      disconnect_warning.show();
    }

    // lobby
    if (seconds_to_open > 0) {
      lobby_timer.html(formatted_seconds(seconds_to_open));  
    } else if (seconds_to_open == 0) {
      self.connect();
    }
    

    // progress bar
    var percent = (total_seconds - seconds_to_close) / total_seconds * 100;
    $(progress_bar).css({width: percent+"%"});

    // disconnect
    if (new Date() >= current_room.end_time) {
      self.disconnect();
    }
  }

  // var onNewStream = function(info, obj) {
  //  console.debug("stream joined with id " + obj.streamId);
  //   webRTCAdaptor.play(obj.streamId, token, room_id);
  //   // playStream(obj);
  // } 

  var parseStreamName = function(stream_id) {
    return stream_id.split("_")[1];
  }

  var playStream = function(obj) {
    var new_stream_id = obj.streamId;
    console.log("new stream availabe: "+new_stream_id);

    // get or create video el for remote stream
    var video_el = $("#"+new_stream_id)[0];
    if (video_el == null) {
      createRemoteVideo(new_stream_id);
      video_el = $("#"+new_stream_id)[0];
    }
    video_el.srcObject = obj.stream;

    // // just in case?
    // $(document).once("click", function() {
    //   video_el.play();
    // })

    CameraTag.fire(dom_id, "new_stream", new_stream_id);
    // webRTCAdaptor.play(new_stream_id, token, room_id);
  }

  var onStreamAvailable = function(info, obj) {
    // console.debug("new stream available" + obj.streamId);
    // console.log("new stream available with id: " + obj.streamId + "on the room:" + room_id);
    webRTCAdaptor.play(obj.streamId, token, room_id);
    // webRTCAdaptor.play(obj.streamId, token, room_id);


    // // get or create video el for remote stream
    // var video_el = document.getElementById(obj.streamId);
    // if (video_el == null) {
    //   createRemoteVideo(obj.streamId);
    //   video_el = document.getElementById(obj.streamId);
    // }

    // video_el.srcObject = obj.track;
  }


  var onStreamLeft = function(info, obj) {
    // console.debug(" stream leaved with id " + obj.streamId);
    removeRemoteVideo(obj.streamId);
    CameraTag.fire(dom_id, "stream_left", obj.streamId);
  }


  var onPublishStarted = function(info, obj) {
    // stream is being published
    // console.debug("publish started to room: " + room_id);
    CameraTag.fire(dom_id, "publishing");
  }


  var onPublishFinished = function(info, obj) {
    //stream is being finished
    // console.debug("publish finished");
    CameraTag.fire(dom_id, "publishing_stopped");
  }


  var onLeaveRoom = function(info, obj) {
    var room = obj.ATTR_ROOM_NAME;
    console.debug("You left the room:" + room);
    
    // stop the timers
    // clearInterval(mute_check_interval);
    clearInterval(tick_interval);
    clearInterval(room_info_interval);

    local_video_el = false;

    // empty the streams list
    if (current_streams != null) {
      current_streams.forEach(function(item) {
        removeRemoteVideo(item);
      });
    }
    current_streams = new Array();

    // remove local video
    removeRemoteVideo(local_stream_id);

    current_streams = [];

    // fire the event
    CameraTag.fire(dom_id, "disconnected");
  }


  var onConnectionClosed = function(info, obj) {
    console.log("Connection closed");
    if (typeof obj != "undefined") {
      // console.log("Connecton closed: " + JSON.stringify(obj));
    }
  }

  var onPlayFinished = function(info, obj) {
    // console.log("play_finished");
    removeRemoteVideo(obj.streamId);
  }

  var buildInterface = function() {
    // font awesome
    if (!skipFontAwesome && typeof(FontAwesomeCdnConfig) == "undefined") {
      var font_awesome = $('<script src="https://kit.fontawesome.com/3d84f307b4.js" crossorigin="anonymous"></script>');
      $("head").append(font_awesome);
    }

    // setup dom container
    var inline_styles = $("#"+dom_id).attr("style");
    $("#"+dom_id).replaceWith('<div id="'+dom_id+'" class="cameratag_room"></div>');
    $("#"+dom_id).attr("style", inline_styles);
    outer_container = $("#"+dom_id);

    // lobby screen
    if ($("#"+dom_id+"-lobby-screen").length > 0) {
      lobby_screen = $("#"+dom_id+"-lobby-screen")[0];
      lobby_screen.addClass("cameratag_room_screen");
      lobby_timer = $("#"+dom_id+"-lobby-screen").find(".cameratag_lobby_timer");
    } else {
      lobby_screen = $('<div class="cameratag-lobby-screen cameratag-lobby-screen-style cameratag_room_screen"><div class="cameratag-lobby-prompt-style">This room is not yet available. Please wait.</div></div>');
      lobby_timer = $('<span class="cameratag_lobby_timer cameratag-lobby-timer-style"></span>');
      lobby_screen.append(lobby_timer);
    }
    $(outer_container).append(lobby_screen);
    

    // create chat screen
    if ($("#"+dom_id+"-chat-screen").length > 0) {
      chat_screen = $("#"+dom_id+"-chat-screen")[0];
      streams_container = $(chat_screen).find(".cameratag_streams_container");
      controls_container = $(chat_screen).find(".cameratag_controls_container");
      disconnect_warning = $(chat_screen).find(".cameratag_disconnect_warning");
    } else {
      chat_screen = $('<div class="cameratag_chat_screen"></div>');

      // streams container
      streams_container = $('<div class="cameratag_streams_container"></div>');
      $(chat_screen).append(streams_container);

      // disconnect warning
      disconnect_warning = $('<div class="cameratag_disconnect_warning cameratag_disconnect_warning_style"></div>');
      $(chat_screen).append(disconnect_warning);

      // controls container
      controls_container = $('<div class="cameratag_controls_container"></div>');
      $(controls_container).append('<i class="fas fa-cog cameratag_control_icon cameratag_show_device_selection"></i>')
      $(controls_container).append('<i class="fas fa-microphone cameratag_control_icon cameratag_stream_mute_mic"></i>')
      $(controls_container).append('<i class="fas fa-video cameratag_control_icon cameratag_stream_mute_video"></i>')
      $(controls_container).append('<i class="fas fa-desktop cameratag_control_icon cameratag_stream_share_screen"></i>')
      $(controls_container).append('<i class="fas fa-phone-slash cameratag_control_icon cameratag_disconnect" style="color:#f00"></i>')
      $(chat_screen).append(controls_container);
    }
    $(outer_container).append(chat_screen);

    $(chat_screen).addClass("cameratag_room_screen");
    $(chat_screen).addClass("cameratag-chat-screen");

    $(chat_screen).find(".cameratag_show_device_selection").click(showConfig);
    $(chat_screen).find(".cameratag_stream_mute_mic").click(toggleMic);
    $(chat_screen).find(".cameratag_stream_mute_video").click(toggleCamera);
    $(chat_screen).find(".cameratag_stream_share_screen").click(self.toggleScreenShare);
    $(chat_screen).find(".cameratag_disconnect").click(self.disconnect);


    // create error screen
    if ($("#"+dom_id+"-error-screen").length > 0) {
      error_screen = $("#"+dom_id+"-error-screen")[0];
      error_screen.addClass("cameratag_room_screen");
      error_message = $("#"+dom_id+"-error-screen").find(".cameratag_error_message");
    } else {
      error_screen = $('<div class="cameratag-error-screen-style"></div>');
      error_message = $('<span class="cameratag_error_message cameratag-error-message-style"></span>');
      error_screen.append(error_message);
    }
    $(outer_container).append(error_screen);

    $(error_screen).addClass("cameratag_room_screen");
    $(error_screen).addClass("cameratag-error-screen");
    


    // create device selection screen
    if ($("#"+dom_id+"-device-selection-screen").length > 0) {
      device_selection_screen = $("#"+dom_id+"-device-selection-screen")[0];
      device_selection_screen.addClass("cameratag_room_screen");
    } else {
      device_selection_screen = $('<div class="cameratag_room_config_menu"></div>')
      device_selection_screen.append('<div class="cameratag_room_config_menu_prompt"></div>');
      device_selection_screen.append('<i class="fas fa-video"></i><select class="cameratag_video_sources">'+CT_i18n[120]+'</select><br/>');
      device_selection_screen.append('<i class="fas fa-microphone"></i><select class="cameratag_audio_sources"></select>');
      device_selection_screen.append('<button class="cameratag_close_device_settings cameratag_w_100 cameratag_button">close settings</button>');
    }
    $(outer_container).append(device_selection_screen);

    $(device_selection_screen).addClass("cameratag_room_screen");
    $(device_selection_screen).addClass("cameratag-device-selection-screen");

    $(device_selection_screen).find(".cameratag_close_device_settings").click(hideConfig);
    $(device_selection_screen).find(".cameratag_video_sources").change(setMediaSources)
    $(device_selection_screen).find(".cameratag_audio_sources").change(setMediaSources)

    // device select els will be populated after connect


    // create progress bar
    progress_bar = $('<div id="'+dom_id+'-progress-bar" class="cameratag_room_progress_bar"></div>')
    $(outer_container).append(progress_bar);


    // create start screen
    if ($("#"+dom_id+"-start-screen").length > 0) {
      start_screen = $("#"+dom_id+"-start-screen");  
      start_screen.addClass("cameratag_room_screen");
    } else {
      start_screen = $('<div id="'+dom_id+'-start-screen" class="cameratag_prompt_container"></div>')
      // room and user prompts
      start_screen.append('<div class="cameratag_login_prompt">'+CT_i18n[121]+'</div>');
      start_screen.append('<input class="cameratag_room_name cameratag_room_name_input" placeholder="'+CT_i18n[123]+'"/>')
      start_screen.append('<input class="cameratag_user_name cameratag_room_user_name_input" placeholder="'+CT_i18n[124]+'"/>')
      start_screen.append('<button class="cameratag_connect cameratag_room_join_button cameratag_button">'+CT_i18n[122]+'</button>')
    } 
    $(outer_container).append(start_screen);

    $(start_screen).addClass("cameratag_room_screen");
    $(start_screen).addClass("cameratag-start-screen");

    // hide the relevant inputs
    if (!user_name || !room_name) {
      $(outer_container).find(".cameratag_login_prompt").show();
    }

    if (user_name) {
      $(outer_container).find(".cameratag_user_name").hide();
    } else {
      $(outer_container).find(".cameratag_user_name").show();
    }

    if (room_name) {
      $(outer_container).find(".cameratag_room_name").hide();
    } else {
      $(outer_container).find(".cameratag_room_name").show();
    }

    // js observers
    $(outer_container).find(".cameratag_connect").click(self.connect);
    $(".cameratag_user_name").keyup(function (e) {
      $(this).val( $(this).val().replace(/ /g, "_") );
      $(this).val( $(this).val().replace(/[^a-zA-Z0-9_]/, "") );
    });
    $(".cameratag_room_name").keyup(function (e) {
      $(this).val( $(this).val().replace(/ /g, "_") );
      $(this).val( $(this).val().replace(/[^a-zA-Z0-9_]/, "") );
    });

    // hide the things and show the thing
    self.showScreen("start-screen");

    // font-size
    font_size = parseInt($(outer_container).width() / 25);
    if (font_size < 14) {
      font_size = 14;
    }
    if (font_size > 22) {
      font_size = 22;
    }
    $(outer_container).css({fontSize: font_size+"px"});  

    // can we autoconnect?
    if ((auto_connect && user_name) || (auto_connect && view_only)) {
      self.connect();
    }
  }

  var resizeVideos = function() {
    var stream_count = Object.keys(current_streams).length + 1;
    // special case for 2 users
    if (stream_count == 2) {
      $(".cameratag_stream_container").width("50%");
      $(".cameratag_stream_container").height("100%");
    } else {
      var nearest_square = Math.ceil(Math.sqrt(stream_count));
      var new_width  = parseInt(1 / nearest_square * 100);
      $(".cameratag_stream_container").width(new_width + "%");
      $(".cameratag_stream_container").height(new_width + "%");  
    }
  }

  var throw_error = function(error_name, error_body) {
    CameraTag.fire(dom_id, error_name, error_body);
    $(error_message).html(error_body);
    self.showScreen("error-screen");
    setTimeout(function(){
      self.showScreen("start-screen");
    }, 3000)
  }

  self.startPublishing = function() {
    webRTCAdaptor.publish(local_stream_id, token);
  }

  self.stopPublishing = function() {

  }

  self.muteMic = function() {
    webRTCAdaptor.muteLocalMic();
  }

  self.unmuteMic = function() {
    webRTCAdaptor.unmuteLocalMic();
  }

  self.muteCamera = function() {
    webRTCAdaptor.turnOffLocalCamera();
  }

  self.unmuteCamera = function() {
    webRTCAdaptor.turnOnLocalCamera();
  }

  self.muteStreamId = function(mute_stream_id) {
    $("#"+mute_stream_id)[0].muted = true
  }

  self.unmuteStreamId = function(mute_stream_id) {
    $("#"+mute_stream_id)[0].muted = false; 
  }

  var toggleMic = function(e) {
    if ( $(this).hasClass("enabled") ) {
      self.unmuteMic();
      $(this).removeClass("enabled");
      $(this).removeClass("fa-microphone-slash");
      $(this).addClass("fa-microphone");
    } else {
      self.muteMic();
      $(this).addClass("enabled");
      $(this).addClass("fa-microphone-slash");
      $(this).removeClass("fa-microphone");
    }
  }

  var toggleCamera = function(e) {
    if ( $(this).hasClass("enabled") ) {
      self.unmuteCamera();
      $(this).removeClass("enabled");
      $(this).removeClass("fa-video-slash");
      $(this).addClass("fa-video");
    } else {
      self.muteCamera();
      $(this).addClass("enabled");
      $(this).addClass("fa-video-slash");
      $(this).removeClass("fa-video");
    }
  }

  var setMediaSources = function() {
    current_cam_id = $("#"+dom_id+" .cameratag_video_sources").val();
    current_mic_id = $("#"+dom_id+" .cameratag_audio_sources").val();

    webRTCAdaptor.switchVideoCameraCapture(local_stream_id, current_cam_id);
    webRTCAdaptor.switchAudioInputSource(local_stream_id, current_mic_id);
  }

  var showConfig = function(e) {
    $(device_selection_screen).show();
  }

  var hideConfig = function(e) {
    $(device_selection_screen).hide();
  }


  var createRemoteVideo = function(new_stream_id) {
    var new_video_el = $('<div id="remoteVideo_'+new_stream_id+'" class="cameratag_stream_container"></div>');
    
    // for our own video
    if (new_stream_id == local_stream_id) {
      var muted = "muted"

    // other user streams
    } else {
      var muted = "";
      $(new_video_el).append('<i class="fas fa-volume-mute cameratag_stream_mute"></i>');
    }

    // for everyone
    $(new_video_el).append('<div class="cameratag_stream_label">'+parseStreamName(new_stream_id)+'</div>');
    $(new_video_el).append('<video class="cameratag_stream_video" id="'+new_stream_id+'" playsinline autoplay '+muted+'></video>');
    $(streams_container).append(new_video_el)
    $("#"+dom_id+" #remoteVideo_"+new_stream_id+" .cameratag_stream_mute").click(function(){
      var video_el = $(this).siblings(".cameratag_stream_video")[0];
      if (video_el.muted) {
        video_el.muted = false;
        $(this).removeClass("enabled");
      } else {
        video_el.muted = true;
        $(this).addClass("enabled");
      }
    })

    resizeVideos();
  }
  
  var removeRemoteVideo = function (existing_stream_id) {
    if (current_streams.indexOf(existing_stream_id) > -1) {
      current_streams.splice(current_streams.indexOf(existing_stream_id),1);
    }

    var container_el = $("#remoteVideo_"+existing_stream_id);
    var video_el = $("#"+existing_stream_id);
    if (container_el != null && video_el[0]) {
      video_el[0].srcObject = null;
      container_el.remove();
    }

    resizeVideos();
  }

  init();
}

    


    //
    // Begin Dependancies
    //

    // GLFX
      var fx=function(){function e(e,t,r){return Math.max(e,Math.min(t,r))}function t(e){return{_:e,loadContentsOf:function(e){oe=this._.gl,this._.loadContentsOf(e)},destroy:function(){oe=this._.gl,this._.destroy()}}}function r(e){return t(ae.fromElement(e))}function o(e,t){var r=oe.UNSIGNED_BYTE;if(oe.getExtension("OES_texture_float")&&oe.getExtension("OES_texture_float_linear")){var o=new ae(100,100,oe.RGBA,oe.FLOAT);try{o.drawTo(function(){r=oe.FLOAT})}catch(i){}o.destroy()}this._.texture&&this._.texture.destroy(),this._.spareTexture&&this._.spareTexture.destroy(),this.width=e,this.height=t,this._.texture=new ae(e,t,oe.RGBA,r),this._.spareTexture=new ae(e,t,oe.RGBA,r),this._.extraTexture=this._.extraTexture||new ae(0,0,oe.RGBA,r),this._.flippedShader=this._.flippedShader||new ie(null,"        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));        }    "),this._.isInitialized=!0}function i(e,t,r){return this._.isInitialized&&e._.width==this.width&&e._.height==this.height||o.call(this,t?t:e._.width,r?r:e._.height),e._.use(),this._.texture.drawTo(function(){ie.getDefaultShader().drawRect()}),this}function a(){return this._.texture.use(),this._.flippedShader.drawRect(),this}function n(e,t,r,o){(r||this._.texture).use(),this._.spareTexture.drawTo(function(){e.uniforms(t).drawRect()}),this._.spareTexture.swapWith(o||this._.texture)}function c(e){return e.parentNode.insertBefore(this,e),e.parentNode.removeChild(e),this}function l(){var e=new ae(this._.texture.width,this._.texture.height,oe.RGBA,oe.UNSIGNED_BYTE);return this._.texture.use(),e.drawTo(function(){ie.getDefaultShader().drawRect()}),t(e)}function u(){var e=this._.texture.width,t=this._.texture.height,r=new Uint8Array(e*t*4);return this._.texture.drawTo(function(){oe.readPixels(0,0,e,t,oe.RGBA,oe.UNSIGNED_BYTE,r)}),r}function s(e){return function(){return oe=this._.gl,e.apply(this,arguments)}}function x(e,t,r,o,i,a,n,c){var l=r-i,u=o-a,s=n-i,x=c-a,f=e-r+i-n,h=t-o+a-c,m=l*x-s*u,d=(f*x-s*h)/m,g=(l*h-f*u)/m;return[r-e+d*r,o-t+d*o,d,n-e+g*n,c-t+g*c,g,e,t,1]}function f(e){var t=e[0],r=e[1],o=e[2],i=e[3],a=e[4],n=e[5],c=e[6],l=e[7],u=e[8],s=t*a*u-t*n*l-r*i*u+r*n*c+o*i*l-o*a*c;return[(a*u-n*l)/s,(o*l-r*u)/s,(r*n-o*a)/s,(n*c-i*u)/s,(t*u-o*c)/s,(o*i-t*n)/s,(i*l-a*c)/s,(r*c-t*l)/s,(t*a-r*i)/s]}function h(e,t){return[e[0]*t[0]+e[1]*t[3]+e[2]*t[6],e[0]*t[1]+e[1]*t[4]+e[2]*t[7],e[0]*t[2]+e[1]*t[5]+e[2]*t[8],e[3]*t[0]+e[4]*t[3]+e[5]*t[6],e[3]*t[1]+e[4]*t[4]+e[5]*t[7],e[3]*t[2]+e[4]*t[5]+e[5]*t[8],e[6]*t[0]+e[7]*t[3]+e[8]*t[6],e[6]*t[1]+e[7]*t[4]+e[8]*t[7],e[6]*t[2]+e[7]*t[5]+e[8]*t[8]]}function m(e){var t=e.length;this.xa=[],this.ya=[],this.u=[],this.y2=[],e.sort(function(e,t){return e[0]-t[0]});for(var r=0;t>r;r++)this.xa.push(e[r][0]),this.ya.push(e[r][1]);this.u[0]=0,this.y2[0]=0;for(var r=1;t-1>r;++r){var o=this.xa[r+1]-this.xa[r-1],i=(this.xa[r]-this.xa[r-1])/o,a=i*this.y2[r-1]+2;this.y2[r]=(i-1)/a;var n=(this.ya[r+1]-this.ya[r])/(this.xa[r+1]-this.xa[r])-(this.ya[r]-this.ya[r-1])/(this.xa[r]-this.xa[r-1]);this.u[r]=(6*n/o-i*this.u[r-1])/a}this.y2[t-1]=0;for(var r=t-2;r>=0;--r)this.y2[r]=this.y2[r]*this.y2[r+1]+this.u[r]}function d(e,t){return new ie(null,e+"    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;    void main() {        vec2 coord = texCoord * texSize;        "+t+"        gl_FragColor = texture2D(texture, coord / texSize);        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);        if (coord != clampedCoord) {            /* fade to transparent if we are outside the image */            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));        }    }")}function g(t,r){return oe.brightnessContrast=oe.brightnessContrast||new ie(null,"        uniform sampler2D texture;        uniform float brightness;        uniform float contrast;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.rgb += brightness;            if (contrast > 0.0) {                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;            } else {                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;            }            gl_FragColor = color;        }    "),n.call(this,oe.brightnessContrast,{brightness:e(-1,t,1),contrast:e(-1,r,1)}),this}function v(t){for(var r=new m(t),o=[],i=0;256>i;i++)o.push(e(0,Math.floor(256*r.interpolate(i/255)),255));return o}function p(e,t,r){e=v(e),1==arguments.length?t=r=e:(t=v(t),r=v(r));for(var o=[],i=0;256>i;i++)o.splice(o.length,0,e[i],t[i],r[i],255);return this._.extraTexture.initFromBytes(256,1,o),this._.extraTexture.use(1),oe.curves=oe.curves||new ie(null,"        uniform sampler2D texture;        uniform sampler2D map;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.r = texture2D(map, vec2(color.r)).r;            color.g = texture2D(map, vec2(color.g)).g;            color.b = texture2D(map, vec2(color.b)).b;            gl_FragColor = color;        }    "),oe.curves.textures({map:1}),n.call(this,oe.curves,{}),this}function y(e){oe.denoise=oe.denoise||new ie(null,"        uniform sampler2D texture;        uniform float exponent;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec4 center = texture2D(texture, texCoord);            vec4 color = vec4(0.0);            float total = 0.0;            for (float x = -4.0; x <= 4.0; x += 1.0) {                for (float y = -4.0; y <= 4.0; y += 1.0) {                    vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);                    float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));                    weight = pow(weight, exponent);                    color += sample * weight;                    total += weight;                }            }            gl_FragColor = color / total;        }    ");for(var t=0;2>t;t++)n.call(this,oe.denoise,{exponent:Math.max(0,e),texSize:[this.width,this.height]});return this}function b(e){return oe.bokeh=oe.bokeh||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float PI = 3.14159265;        uniform sampler2D texture2;        float init = 1.0;        uniform float time;        uniform vec3 p0;        uniform vec3 p1;        uniform vec3 p2;        uniform vec3 p3;        uniform vec3 p4;        uniform vec3 p5;        uniform vec3 p6;        uniform vec3 p7;        vec2 center = vec2(400,300);        float radius = 720.0;        vec3 hue(vec3 c,float a){          float sa=sin(a*PI),ca=cos(a*PI);          vec3 w=(vec3(2.0*ca,-sqrt(3.0)*sa-ca,sqrt(3.0)*sa-ca)+1.0)/3.0;          return vec3(dot(c,w.xyz),dot(c,w.zxy),dot(c,w.yzx));        }        void main(){          vec3 c=texture2D(texture,texCoord*0.994+0.003).rgb;          if(init==1.0) c=(c+0.5)*c-0.1;          vec2 p=texCoord*vec2(800.0,800.0*texSize.y/texSize.x);          vec3 b0=texture2D(texture2,(p-p0.xy)/p0.z).rgb;          vec3 b1=vec3(texture2D(texture2,(p-p1.xy)/p1.z).r*1.3);          b1.g=b1.b-=0.05;          vec3 b2=texture2D(texture2,(p-p2.xy)/p2.z).rgb;          vec3 b3=texture2D(texture2,(p-p3.xy)/p3.z).rgb;          vec3 b4=texture2D(texture2,(p-p4.xy)/p4.z).rgb;          vec3 b5=texture2D(texture2,(p-p5.xy)/p5.z).rgb;          vec3 b6=texture2D(texture2,(p-p6.xy)/p6.z).rgb;          vec3 b7=texture2D(texture2,(p-p7.xy)/p7.z).rgb;          vec3 c1=hue(b0,0.1) +\nb1 +\nhue(b2,-0.1) +\nhue(b3,-0.2) +\nb4*0.3 +\nb5*0.5 +\nb6*1.5 +\nb7;gl_FragColor=vec4(clamp(c+hue(c1,time*0.2)*length(texCoord*texSize-center)/radius*0.8,0.0,1.0),1.0);        }    "),n.call(this,oe.bokeh,{time:e}),this}function _(e){return oe.flare=oe.flare||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float time;        float hl(float c1,float c0){          return(c0<0.5?(2.0*c0*c1):(1.0-2.0*(1.0-c0)*(1.0-c1)));        }        void main(){          vec2 p=texCoord-0.2;          vec3 c=vec3(0.0);          for(float i=0.0;i<4.0;i++){            float t=time/4.0+i*3.0;            p.y+=sin(p.x*2.0-t)-sin(t)*0.1;            p.x+=cos(p.y*3.0-t+cos(t))*0.15;            float w=(sin(p.x*10.0)+sin(i*0.1)+p.y*8.0);            float z=1.0/sqrt(abs(w))*(abs(sin(time*0.1+2.0))*0.5+2.0);            c+=vec3(z*0.2,z*0.1,z*0.025);          }          vec3 c0=texture2D(texture,texCoord).rgb;          c=vec3(hl(c0.r,c.r),hl(c0.g,c.g),hl(c0.b,c.b));          gl_FragColor=vec4(clamp(c0*c0+c*0.5,0.0,1.0),1.0);        }    "),n.call(this,oe.flare,{time:e}),this}function C(e){return oe.halo=oe.halo||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float RADIUS = 0.4;        float TWO_PI = 6.28318531;        float X_PRO = 0.5;        uniform float time;        void main(){          vec2 p=(texCoord-vec2(0.5))*texSize/texSize.y;          float r=length(p*8.0),a=atan(p.y+1.5,p.x),t=time+50.0/(r+1.0),d=abs(0.05/(sin(t)+sin(time+a*8.0)))*28.0;          vec3 c=vec3(-sin(r*5.0-a-time+sin(r+t)),sin(r*3.0+a-cos(time)+sin(r+t)),cos(r+a*2.0+log(5.001-(a/4.0))-time)+sin(r+t));          float dist=length(p);          if(dist<RADIUS) c+=(dist-RADIUS)*11.0;          vec3 c0=texture2D(texture,texCoord).rgb;          c0.r-=sin(c0.r*TWO_PI)*X_PRO;          c0.g-=sin(c0.g*TWO_PI)*X_PRO;          c0.b+=sin(c0.b*TWO_PI)*X_PRO;          gl_FragColor=vec4(c0+clamp(c*d*0.2,0.0,1.0),1.0);        }    "),n.call(this,oe.halo,{time:e}),this}function w(e){return oe.smoke=oe.smoke||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float time;        float r(float d,float w,float o){          return(cos(d*0.0174533)+1.0)*w+o;        }        void main(){          vec2 p=texCoord;          float t=time*0.25+1024.0,w=r(t*10.0,2.0,0.5),cw=cos(w)*0.0075,xo=r(t*0.12,2.5,5.0),yo=r(t*0.1,4.0,5.0);          for(float i=1.0;i<31.0;i++){            p.x+=sin(p.y*i+t*cw+i*0.03)*0.375/i+xo;            p.y+=sin(p.x*i+t*w*0.00375+(i+15.0)*0.03)*0.6/i+yo;          }          vec3 c0=(texture2D(texture,texCoord).rgb-0.5)*1.5+0.6;          c0=mix(c0,vec3(c0.r*0.3+c0.g*0.59+c0.b*0.11),0.5);          vec3 c1=clamp(vec3(sin(p.x*3.0)*0.5+0.5,sin(p.y*3.0)*0.5+0.5,sin(p.x+p.y)),0.0,1.0)*0.7+0.3;          gl_FragColor=vec4(1.0-(1.0-c0)*(1.0-c1),1.0);        }    "),n.call(this,oe.smoke,{time:e}),this}function T(){return oe.berry=oe.berry||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        const vec3 g1=vec3(1.0,0.6,0.8);        const vec3 g2=vec3(0.6,0.8,1.0);        void main(){          vec3 c=(texture2D(texture,texCoord).rgb-0.5)*1.8+0.5;          c=vec3(c.r*0.3+c.g*0.59+c.b*0.11);          vec3 g=mix(g1,g2,texCoord.x*(texSize.y/texSize.x)+(texSize.x-texSize.y)/texSize.x/2.0);          gl_FragColor=vec4(1.0-(1.0-c)*(1.0-g),1.0);        }    "),n.call(this,oe.berry,{}),this}function E(){return oe.spycam=oe.spycam||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float PI = 3.14159265;        const vec3 tint=vec3(0.85,1.1,1.35);        float rand(vec2 r){          return fract(sin(dot(r,vec2(12.9898,78.233)))*43758.5453);        }        void main(){          vec2 p=texCoord;          float b=mix(sin(p.x*PI),sin(p.y*PI),0.5);          vec3 c=texture2D(texture,p).rgb;          float noise=rand(vec2(c.g,atan(p.x,p.y)));          float tv=mix(b,mix(b/2.0,abs(sin(gl_FragCoord.y/2.0))/1.5,0.5),0.5)+noise/16.0;          c=vec3(c.r*0.3+c.g*0.59+c.b*0.11)*tint;          gl_FragColor=vec4(((c-0.5)*4.0+1.0)*vec3(tv),1.0);        }    "),n.call(this,oe.spycam,{}),this}function E(){return oe.spycam=oe.spycam||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float PI = 3.14159265;        const vec3 tint=vec3(0.85,1.1,1.35);        float rand(vec2 r){          return fract(sin(dot(r,vec2(12.9898,78.233)))*43758.5453);        }        void main(){          vec2 p=texCoord;          float b=mix(sin(p.x*PI),sin(p.y*PI),0.5);          vec3 c=texture2D(texture,p).rgb;          float noise=rand(vec2(c.g,atan(p.x,p.y)));          float tv=mix(b,mix(b/2.0,abs(sin(gl_FragCoord.y/2.0))/1.5,0.5),0.5)+noise/16.0;          c=vec3(c.r*0.3+c.g*0.59+c.b*0.11)*tint;          gl_FragColor=vec4(((c-0.5)*4.0+1.0)*vec3(tv),1.0);        }    "),n.call(this,oe.spycam,{}),this}function D(){return oe.murica=oe.murica||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        void main(){            float x = texCoord.x;            vec3 tc=vec3(texture2D(texture,texCoord).rgb);            if(x>0.0 && x<0.33) tc.rgb*=vec3(0.0,0.0,1.0);            if(x>0.33 && x<0.66) tc.rgb*=vec3(1.0,1.0,1.0);            if(x>0.66) tc.rgb*=vec3(1.0,0.0,0.0);            gl_FragColor=vec4(tc,1.0);        }    "),n.call(this,oe.murica,{texSize:[this.width,this.height]}),this}function S(e,t,r){return oe.nightvision=oe.nightvision||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float time;        uniform float luminanceThreshold;        uniform float colorAmplification;        void main (){          vec4 finalColor;          vec2 uv;          uv.x = 0.4*sin(time*50.0);          uv.y = 0.4*cos(time*50.0);          vec3 c = texture2D(texture, texCoord).rgb;          float lum = dot(vec3(0.30, 0.59, 0.11), c);          if (lum < luminanceThreshold) c *= colorAmplification;           vec3 visionColor = vec3(0.1, 0.95, 0.2);          finalColor.rgb = (c * visionColor);          gl_FragColor.rgb = finalColor.rgb;          gl_FragColor.a = 1.0;        }    "),n.call(this,oe.nightvision,{time:e,luminanceThreshold:t,colorAmplification:r,texSize:[this.width,this.height]}),this}function z(e,t){return oe.posterize=oe.posterize||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float gamma;        uniform float numColors;        void main(){          vec3 c = texture2D(texture, texCoord).rgb;          c = pow(c, vec3(gamma, gamma, gamma));          c = c * numColors;          c = floor(c);          c = c / numColors;          c = pow(c, vec3(1.0/gamma));          gl_FragColor = vec4(c, 1.0);        }    "),n.call(this,oe.posterize,{gamma:e,numColors:t,texSize:[this.width,this.height]}),this}function R(e,t,r,o,i){return oe.badtv=oe.badtv||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float time;        float distortion;        float distortion2;        float speed;        float rollSpeed;        vec3 mod289(vec3 x) {          return x - floor(x * (1.0 / 289.0)) * 289.0;        }        vec2 mod289(vec2 x) {          return x - floor(x * (1.0 / 289.0)) * 289.0;        }        vec3 permute(vec3 x) {          return mod289(((x*34.0)+1.0)*x);        }        float snoise(vec2 v) {          const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);          vec2 i  = floor(v + dot(v, C.yy) );          vec2 x0 = v - i + dot(i, C.xx);          vec2 i1;          i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);          vec4 x12 = x0.xyxy + C.xxzz;          x12.xy -= i1;          i = mod289(i);          vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);          m = m*m ;          m = m*m ;          vec3 x = 2.0 * fract(p * C.www) - 1.0;          vec3 h = abs(x) - 0.5;          vec3 ox = floor(x + 0.5);          vec3 a0 = x - ox;          m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );          vec3 g;          g.x  = a0.x  * x0.x  + h.x  * x0.y;          g.yz = a0.yz * x12.xz + h.yz * x12.yw;          return 130.0 * dot(m, g);        }        void main() {          vec2 p = texCoord;          float ty = time*speed;          float yt = p.y - time;          float offset = snoise(vec2(yt*3.0,0.0))*0.2;          offset = offset*distortion * offset*distortion * offset;          offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;          float v_offset = time / texSize[1];          gl_FragColor = texture2D(texture, vec2(fract(p.x),(p.y - v_offset) ));        }    "),n.call(this,oe.badtv,{time:e,distortion:t,distortion2:r,speed:o,rollSpeed:i,texSize:[this.width,this.height]}),this}function A(e){return oe.magazine=oe.magazine||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float K = 1.0471975511965976;        uniform float size;        float cosa = 0.5000000000000001;        float sina = 0.8660254037844386;        float fade = 1152.0;        vec2 center = vec2(400.0, 300.0);        vec4 rect = vec4(0.028, 0.021, 0.972, 0.979);        void main(){          vec2 p=texCoord*1.04-0.02;          vec3 c=(texture2D(texture,p).rgb-0.5)*1.3+0.6;          float lu=(c.r*0.3+c.g*0.59+c.b*0.11)*16.0-8.0;          if(texCoord.x<rect.t) lu+=(rect.t-texCoord.x)*fade;          else if(texCoord.x>rect.q) lu+=(texCoord.x-rect.q)*fade;          if(texCoord.y<rect.s) lu+=(rect.s-texCoord.y)*fade;          else if(texCoord.y>rect.p) lu+=(texCoord.y-rect.p)*fade;          p=gl_FragCoord.xy-center;          p=vec2(p.x*cosa-p.y*sina,p.x*sina+p.y*cosa)*size;          gl_FragColor=vec4(clamp(vec3(lu+sin(p.x)*sin(p.y)*4.0),0.0,1.0),1.0);        }    "),n.call(this,oe.magazine,{size:e}),this}function P(e,t,r){return oe.rainbow=oe.rainbow||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float radius;        uniform float border;        uniform float ratio;        void main(){          vec2 p=texCoord-0.5;          float r=radius/texSize.y,b=length(max(abs(vec2(p.x*texSize.x/texSize.y,p.y)/r)-vec2(0.5*ratio,0.5)/r+border,0.0));          gl_FragColor=vec4(1.0-(1.0-texture2D(texture,texCoord).rgb)*clamp(smoothstep(1.02,0.98,b),0.0,1.0),1.0);        }    "),n.call(this,oe.rainbow,{border:e,radius:t,ratio:r}),this}function U(e,t,r){return oe.snow=oe.snow||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform vec2 center;        uniform float radius;        uniform float width;        const vec3 frost=vec3(0.9,1.1,1.5);        void main(){          vec3 c=texture2D(texture,texCoord).rgb;          float attn,outerRadius=radius+width,dist=distance(texCoord*texSize,center);          if(dist<radius) attn=0.0;          else if(dist>outerRadius) attn=1.0;          else attn=(dist-radius)/width;attn=max(0.1,attn);          gl_FragColor=vec4((1.0-(1.0-c)*(1.0-attn))*frost,1.0);        }    "),n.call(this,oe.snow,{center:e,radius:t,width:r}),this}function F(e,t,r){return oe.fire=oe.fire||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        float PI = 3.14159265;        float WAVELENGTH = 26.0;        float AMPLITUDE = 0.0125;        float SPEED = 3.0;        uniform sampler2D frame1;        uniform sampler2D frame2;        uniform sampler2D frame3;        uniform sampler2D frame4;        uniform sampler2D frame5;        uniform sampler2D frame6;        uniform float time;        uniform float left;        uniform float right;        const vec3 fire=vec3(0.9,0.3,0.0);        const vec3 fire2=vec3(1.2,1.0,0.8);        vec3 mod289(vec3 x){          return x-floor(x*(1.0/289.0))*289.0;        }        vec4 mod289(vec4 x){          return x-floor(x*(1.0/289.0))*289.0;        }        vec4 permute(vec4 x){          return mod289(((x*34.0)+1.0)*x);        }        vec4 taylorInvSqrt(vec4 r){          return 1.79284291400159-0.85373472095314*r;        }        vec3 fade(vec3 t){          return t*t*t*(t*(t*6.0-15.0)+10.0);        }        float noise(vec3 P){          vec3 Pi0=floor(P),Pi1=Pi0+vec3(1.0);          Pi0=mod289(Pi0);          Pi1=mod289(Pi1);          vec3 Pf0=fract(P),Pf1=Pf0-vec3(1.0);          vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x),iy=vec4(Pi0.yy,Pi1.yy),iz0=Pi0.zzzz,iz1=Pi1.zzzz,ixy=permute(permute(ix)+iy),ixy0=permute(ixy+iz0),ixy1=permute(ixy+iz1),gx0=ixy0*(1.0/7.0),gy0=fract(floor(gx0)*(1.0/7.0))-0.5;          gx0=fract(gx0);          vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0),sz0=step(gz0,vec4(0.0));          gx0-=sz0*(step(0.0,gx0)-0.5);          gy0-=sz0*(step(0.0,gy0)-0.5);          vec4 gx1=ixy1*(1.0/7.0),gy1=fract(floor(gx1)*(1.0/7.0))-0.5;          gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1),sz1=step(gz1,vec4(0.0));          gx1-=sz1*(step(0.0,gx1)-0.5);          gy1-=sz1*(step(0.0,gy1)-0.5);          vec3 g000=vec3(gx0.x,gy0.x,gz0.x),g100=vec3(gx0.y,gy0.y,gz0.y),g010=vec3(gx0.z,gy0.z,gz0.z),g110=vec3(gx0.w,gy0.w,gz0.w),g001=vec3(gx1.x,gy1.x,gz1.x),g101=vec3(gx1.y,gy1.y,gz1.y),g011=vec3(gx1.z,gy1.z,gz1.z),g111=vec3(gx1.w,gy1.w,gz1.w);          vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));          g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;          g110*=norm0.w;          vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));          g001*=norm1.x;g011*=norm1.y;          g101*=norm1.z;g111*=norm1.w;          float n000=dot(g000,Pf0),n100=dot(g100,vec3(Pf1.x,Pf0.yz)),n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z)),n110=dot(g110,vec3(Pf1.xy,Pf0.z)),n001=dot(g001,vec3(Pf0.xy,Pf1.z)),n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z)),n011=dot(g011,vec3(Pf0.x,Pf1.yz)),n111=dot(g111,Pf1);          vec3 fade_xyz=fade(Pf0);          vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);          vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);          return mix(n_yz.x,n_yz.y,fade_xyz.x);        }        float diff(vec3 c1,vec3 c2){c1=(c1-c2)*5.0;          return clamp(c1.r+c1.g+c1.b,0.2,1.2)-0.2;        }        void main(){          if(texCoord.x<left||texCoord.x>right) gl_FragColor=vec4(0.0);          else{vec2 p=texCoord+sin(vec2(noise(vec3(texCoord,time*SPEED)*WAVELENGTH)*PI*AMPLITUDE,noise(vec3(texCoord,(time+1.0)*SPEED)*WAVELENGTH)*PI*AMPLITUDE));            vec3 c0=texture2D(texture,p).rgb,c1=texture2D(frame6,p).rgb,c2=texture2D(frame5,p).rgb,c3=texture2D(frame4,p).rgb,c4=texture2D(frame3,p).rgb,c5=texture2D(frame2,p).rgb,c6=texture2D(frame1,p).rgb;            float c=diff(c0,c1)*2.0;            c+=diff(c1,c2);            c+=diff(c2,c3);            c+=diff(c3,c4);            c+=diff(c4,c5)*0.5;            c+=diff(c5,c6)*0.125;gl_FragColor=vec4(texture2D(texture,texCoord).rgb*fire2+c*fire,1.0);          }        }    "),n.call(this,oe.fire,{time:e,left:t,right:r}),this}function B(){return oe.crosshatch=oe.crosshatch||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        void main(){          vec3 c=(texture2D(texture,texCoord).rgb-0.5)*1.5+0.7;          float lu=c.r*0.3+c.g*0.59+c.b*0.11,p0=gl_FragCoord.x+gl_FragCoord.y,p1=gl_FragCoord.x-gl_FragCoord.y,h=1.0;          if(lu<0.75&&mod(p0,8.0)==0.0 ||            lu<0.5&&mod(p1,8.0)==0.0 ||            lu<0.4&&mod(p0-4.0,8.0)==0.0 ||            lu<0.3&&mod(p1-4.0,8.0)==0.0 ||            lu<0.2&&mod(p0-2.0,4.0)==0.0 ||            lu<0.1&&mod(p1-2.0,4.0)==0.0) h=0.0;gl_FragColor=vec4(h,h,h,1.0);        }    "),n.call(this,oe.crosshatch,{}),this}function L(e,t,r,o){return oe.cocoa=oe.cocoa||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform float R_LU;        uniform float G_LU;        uniform float B_LU;        uniform float SAT;        uniform sampler2D texture2;        float fade = 60.0;        vec4 rect = vec4(0.022, 0.0165, 0.978, 0.9835);        vec2 center = vec2(400, 300);        float radius = 133.33333333333334;        float width = 348.0;        const vec3 tint=vec3(0.0,-0.18,-0.28);        void main(){          vec2 p=texCoord*1.025-0.0125;          vec3 c0=1.0-(1.0-texture2D(texture,p).rgb)*(1.0-texture2D(texture2,p).rgb);          vec3 c;          c.r=((R_LU+(1.0-R_LU)*SAT)*c0.r)+((G_LU-G_LU*SAT)*c0.g)+((B_LU-B_LU*SAT)*c0.b);          c.g=((R_LU-R_LU*SAT)*c0.r)+((G_LU+(1.0-G_LU)*SAT)*c0.g)+((B_LU-B_LU*SAT)*c0.b);          c.b=((R_LU-R_LU*SAT)*c0.r)+((G_LU-G_LU*SAT)*c0.g)+((B_LU+(1.0-B_LU)*SAT)*c0.b);          c+=tint*(1.0-c);          float attn,outerRadius=radius+width,dist=distance(p*texSize,center),bc=0.0;          if(texCoord.x<rect.t) bc=(rect.t-texCoord.x)*fade;          else if(texCoord.x>rect.q) bc=(texCoord.x-rect.q)*fade;          if(texCoord.y<rect.s) bc+=(rect.s-texCoord.y)*fade;          else if(texCoord.y>rect.p) bc+=(texCoord.y-rect.p)*fade;          if(dist<radius) attn=1.0;          else if(dist>outerRadius) attn=0.0;          else attn=1.0-pow((dist-radius)/width,1.4);          gl_FragColor=vec4(clamp((c*vec3(attn,attn-0.09,attn-0.14)-bc),0.0,1.0),1.0);        }    "),n.call(this,oe.cocoa,{R_LU:e,G_LU:t,B_LU:r,SAT:o}),this}function I(e,t,r,o){return oe.zinc=oe.zinc||new ie(null,"        uniform sampler2D texture;        uniform vec2 texSize;        varying vec2 texCoord;        uniform sampler2D texture2;        uniform float fade;        uniform vec4 rect;        uniform float R_LU;        uniform float G_LU;        uniform float B_LU;        uniform float SAT;        void main(){            const vec3 tint=vec3(0.16,0.0,0.08);            const vec3 cyan=vec3(0.96,1.16,1.1);            vec2 p=texCoord*1.025-0.0125;            vec3 c0=(1.0-(1.0-0.5*texture2D(texture,p).rgb)*(1.0-texture2D(texture2,p).rgb));            vec3 c;            c.r=((R_LU+(1.0-R_LU)*SAT)*c0.r)+((G_LU-G_LU*SAT)*c0.g)+((B_LU-B_LU*SAT)*c0.b);            c.g=((R_LU-R_LU*SAT)*c0.r)+((G_LU+(1.0-G_LU)*SAT)*c0.g)+((B_LU-B_LU*SAT)*c0.b);            c.b=((R_LU-R_LU*SAT)*c0.r)+((G_LU-G_LU*SAT)*c0.g)+((B_LU+(1.0-B_LU)*SAT)*c0.b);            c*=cyan;            c+=tint*(1.0-c);            float bc=0.0;            if(texCoord.x<rect.t) bc=(rect.t-texCoord.x)*fade;            else if(texCoord.x>rect.q) bc=(texCoord.x-rect.q)*fade;            if(texCoord.y<rect.s) bc+=(rect.s-texCoord.y)*fade;            else if(texCoord.y>rect.p) bc+=(texCoord.y-rect.p)*fade;            gl_FragColor=vec4(clamp((c-bc),0.0,1.0),1.0);        }    "),n.call(this,oe.zinc,{R_LU:e,G_LU:t,B_LU:r,SAT:o}),this}function G(t,r){return oe.hueSaturation=oe.hueSaturation||new ie(null,"        uniform sampler2D texture;        uniform float hue;        uniform float saturation;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */            float angle = hue * 3.14159265;            float s = sin(angle), c = cos(angle);            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;            float len = length(color.rgb);            color.rgb = vec3(                dot(color.rgb, weights.xyz),                dot(color.rgb, weights.zxy),                dot(color.rgb, weights.yzx)            );                        /* saturation adjustment */            float average = (color.r + color.g + color.b) / 3.0;            if (saturation > 0.0) {                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));            } else {                color.rgb += (average - color.rgb) * (-saturation);            }                        gl_FragColor = color;        }    "),n.call(this,oe.hueSaturation,{hue:e(-1,t,1),saturation:e(-1,r,1)}),this}function X(t){return oe.noise=oe.noise||new ie(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        float rand(vec2 co) {            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);        }        void main() {            vec4 color = texture2D(texture, texCoord);                        float diff = (rand(texCoord) - 0.5) * amount;            color.r += diff;            color.g += diff;            color.b += diff;                        gl_FragColor = color;        }    "),n.call(this,oe.noise,{amount:e(0,t,1)}),this}function k(t){return oe.sepia=oe.sepia||new ie(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;                        color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));            color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));            color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));                        gl_FragColor = color;        }    "),n.call(this,oe.sepia,{amount:e(0,t,1)}),this}function O(e,t){return oe.unsharpMask=oe.unsharpMask||new ie(null,"        uniform sampler2D blurredTexture;        uniform sampler2D originalTexture;        uniform float strength;        uniform float threshold;        varying vec2 texCoord;        void main() {            vec4 blurred = texture2D(blurredTexture, texCoord);            vec4 original = texture2D(originalTexture, texCoord);            gl_FragColor = mix(blurred, original, 1.0 + strength);        }    "),this._.extraTexture.ensureFormat(this._.texture),this._.texture.use(),this._.extraTexture.drawTo(function(){ie.getDefaultShader().drawRect()}),this._.extraTexture.use(1),this.triangleBlur(e),oe.unsharpMask.textures({originalTexture:1}),n.call(this,oe.unsharpMask,{strength:t}),this._.extraTexture.unuse(1),this}function M(t){return oe.vibrance=oe.vibrance||new ie(null,"        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            float mx = max(color.r, max(color.g, color.b));            float amt = (mx - average) * (-amount * 3.0);            color.rgb = mix(color.rgb, vec3(mx), amt);            gl_FragColor = color;        }    "),n.call(this,oe.vibrance,{amount:e(-1,t,1)}),this}function N(t,r){return oe.vignette=oe.vignette||new ie(null,"        uniform sampler2D texture;        uniform float size;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        float dist = distance(texCoord, vec2(0.5, 0.5));            color.rgb *= smoothstep(0.8, size * 0.799, dist * (amount + size));                        gl_FragColor = color;        }    "),n.call(this,oe.vignette,{size:e(0,t,1),amount:e(0,r,1)}),this}function W(t,r,o){oe.lensBlurPrePass=oe.lensBlurPrePass||new ie(null,"        uniform sampler2D texture;        uniform float power;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color = pow(color, vec4(power));            gl_FragColor = vec4(color);        }    ");var i="        uniform sampler2D texture0;        uniform sampler2D texture1;        uniform vec2 delta0;        uniform vec2 delta1;        uniform float power;        varying vec2 texCoord;        "+ne+"        vec4 sample(vec2 delta) {            /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(delta, 151.7182), 0.0);                        vec4 color = vec4(0.0);            float total = 0.0;            for (float t = 0.0; t <= 30.0; t++) {                float percent = (t + offset) / 30.0;                color += texture2D(texture0, texCoord + delta * percent);                total += 1.0;            }            return color / total;        }    ";
      oe.lensBlur0=oe.lensBlur0||new ie(null,i+"        void main() {            gl_FragColor = sample(delta0);        }    "),oe.lensBlur1=oe.lensBlur1||new ie(null,i+"        void main() {            gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;        }    "),oe.lensBlur2=oe.lensBlur2||new ie(null,i+"        void main() {            vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;            gl_FragColor = pow(color, vec4(power));        }    ").textures({texture1:1});for(var a=[],c=0;3>c;c++){var l=o+c*Math.PI*2/3;a.push([t*Math.sin(l)/this.width,t*Math.cos(l)/this.height])}var u=Math.pow(10,e(-1,r,1));return n.call(this,oe.lensBlurPrePass,{power:u}),this._.extraTexture.ensureFormat(this._.texture),n.call(this,oe.lensBlur0,{delta0:a[0]},this._.texture,this._.extraTexture),n.call(this,oe.lensBlur1,{delta0:a[1],delta1:a[2]},this._.extraTexture,this._.extraTexture),n.call(this,oe.lensBlur0,{delta0:a[1]}),this._.extraTexture.use(1),n.call(this,oe.lensBlur2,{power:1/u,delta0:a[2]}),this}function Y(e,t,r,o,i,a){oe.tiltShift=oe.tiltShift||new ie(null,"        uniform sampler2D texture;        uniform float blurRadius;        uniform float gradientRadius;        uniform vec2 start;        uniform vec2 end;        uniform vec2 delta;        uniform vec2 texSize;        varying vec2 texCoord;        "+ne+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;            for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    ");var c=r-e,l=o-t,u=Math.sqrt(c*c+l*l);return n.call(this,oe.tiltShift,{blurRadius:i,gradientRadius:a,start:[e,t],end:[r,o],delta:[c/u,l/u],texSize:[this.width,this.height]}),n.call(this,oe.tiltShift,{blurRadius:i,gradientRadius:a,start:[e,t],end:[r,o],delta:[-l/u,c/u],texSize:[this.width,this.height]}),this}function q(e){return oe.triangleBlur=oe.triangleBlur||new ie(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+ne+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta * percent);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    "),n.call(this,oe.triangleBlur,{delta:[e/this.width,0]}),n.call(this,oe.triangleBlur,{delta:[0,e/this.height]}),this}function H(e,t,r){return oe.zoomBlur=oe.zoomBlur||new ie(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        "+ne+"        void main() {            vec4 color = vec4(0.0);            float total = 0.0;            vec2 toCenter = center - texCoord * texSize;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = 0.0; t <= 40.0; t++) {                float percent = (t + offset) / 40.0;                float weight = 4.0 * (percent - percent * percent);                vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    "),n.call(this,oe.zoomBlur,{center:[e,t],strength:r,texSize:[this.width,this.height]}),this}function V(e,t,r,o){return oe.colorHalftone=oe.colorHalftone||new ie(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern(float angle) {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            vec3 cmy = 1.0 - color.rgb;            float k = min(cmy.x, min(cmy.y, cmy.z));            cmy = (cmy - k) / (1.0 - k);            cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);            k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);            gl_FragColor = vec4(1.0 - cmy - k, color.a);        }    "),n.call(this,oe.colorHalftone,{center:[e,t],angle:r,scale:Math.PI/o,texSize:[this.width,this.height]}),this}function j(e,t,r,o){return oe.dotScreen=oe.dotScreen||new ie(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern() {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);        }    "),n.call(this,oe.dotScreen,{center:[e,t],angle:r,scale:Math.PI/o,texSize:[this.width,this.height]}),this}function $(e){return oe.edgeWork1=oe.edgeWork1||new ie(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+ne+"        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec3 sample = texture2D(texture, texCoord + delta * percent).rgb;                float average = (sample.r + sample.g + sample.b) / 3.0;                color.x += average * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += average * weight;                    total.y += weight;                }            }            gl_FragColor = vec4(color / total, 0.0, 1.0);        }    "),oe.edgeWork2=oe.edgeWork2||new ie(null,"        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        "+ne+"        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec2 sample = texture2D(texture, texCoord + delta * percent).xy;                color.x += sample.x * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += sample.y * weight;                    total.y += weight;                }            }            float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);            gl_FragColor = vec4(c, c, c, 1.0);        }    "),n.call(this,oe.edgeWork1,{delta:[e/this.width,0]}),n.call(this,oe.edgeWork2,{delta:[0,e/this.height]}),this}function K(e,t,r){return oe.hexagonalPixelate=oe.hexagonalPixelate||new ie(null,"        uniform sampler2D texture;        uniform vec2 center;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 tex = (texCoord * texSize - center) / scale;            tex.y /= 0.866025404;            tex.x -= tex.y * 0.5;                        vec2 a;            if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) a = vec2(floor(tex.x), floor(tex.y));            else a = vec2(ceil(tex.x), ceil(tex.y));            vec2 b = vec2(ceil(tex.x), floor(tex.y));            vec2 c = vec2(floor(tex.x), ceil(tex.y));                        vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);            vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);            vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);            vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);                        float alen = length(TEX - A);            float blen = length(TEX - B);            float clen = length(TEX - C);                        vec2 choice;            if (alen < blen) {                if (alen < clen) choice = a;                else choice = c;            } else {                if (blen < clen) choice = b;                else choice = c;            }                        choice.x += choice.y * 0.5;            choice.y *= 0.866025404;            choice *= scale / texSize;            gl_FragColor = texture2D(texture, choice + center / texSize);        }    "),n.call(this,oe.hexagonalPixelate,{center:[e,t],scale:r,texSize:[this.width,this.height]}),this}function J(e){return oe.ink=oe.ink||new ie(null,"        uniform sampler2D texture;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 dx = vec2(1.0 / texSize.x, 0.0);            vec2 dy = vec2(0.0, 1.0 / texSize.y);            vec4 color = texture2D(texture, texCoord);            float bigTotal = 0.0;            float smallTotal = 0.0;            vec3 bigAverage = vec3(0.0);            vec3 smallAverage = vec3(0.0);            for (float x = -2.0; x <= 2.0; x += 1.0) {                for (float y = -2.0; y <= 2.0; y += 1.0) {                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;                    bigAverage += sample;                    bigTotal += 1.0;                    if (abs(x) + abs(y) < 2.0) {                        smallAverage += sample;                        smallTotal += 1.0;                    }                }            }            vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);            gl_FragColor = vec4(color.rgb - dot(edge, edge) * strength * 100000.0, color.a);        }    "),n.call(this,oe.ink,{strength:e*e*e*e*e,texSize:[this.width,this.height]}),this}function Q(t,r,o,i){return oe.bulgePinch=oe.bulgePinch||d("        uniform float radius;        uniform float strength;        uniform vec2 center;    ","        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = distance / radius;            if (strength > 0.0) {                coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);            } else {                coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);            }        }        coord += center;    "),n.call(this,oe.bulgePinch,{radius:o,strength:e(-1,i,1),center:[t,r],texSize:[this.width,this.height]}),this}function Z(e,t,r){if(oe.matrixWarp=oe.matrixWarp||d("        uniform mat3 matrix;        uniform bool useTextureSpace;    ","        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;        vec3 warp = matrix * vec3(coord, 1.0);        coord = warp.xy / warp.z;        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;    "),e=Array.prototype.concat.apply([],e),4==e.length)e=[e[0],e[1],0,e[2],e[3],0,0,0,1];else if(9!=e.length)throw"can only warp with 2x2 or 3x3 matrix";return n.call(this,oe.matrixWarp,{matrix:t?f(e):e,texSize:[this.width,this.height],useTextureSpace:0|r}),this}function ee(e,t){var r=x.apply(null,t),o=x.apply(null,e),i=h(f(r),o);return this.matrixWarp(i)}function te(e,t,r,o){return oe.swirl=oe.swirl||d("        uniform float radius;        uniform float angle;        uniform vec2 center;    ","        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = (radius - distance) / radius;            float theta = percent * percent * angle;            float s = sin(theta);            float c = cos(theta);            coord = vec2(                coord.x * c - coord.y * s,                coord.x * s + coord.y * c            );        }        coord += center;    "),n.call(this,oe.swirl,{radius:r,center:[e,t],angle:o,texSize:[this.width,this.height]}),this}var re={};!function(){function e(e){if(!e.getExtension("OES_texture_float"))return!1;var t=e.createFramebuffer(),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);var o=[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=e.createTexture();e.bindTexture(e.TEXTURE_2D,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,2,2,0,e.RGBA,e.FLOAT,new Float32Array(o));var a=e.createProgram(),n=e.createShader(e.VERTEX_SHADER),c=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(n,"      attribute vec2 vertex;      void main() {        gl_Position = vec4(vertex, 0.0, 1.0);      }    "),e.shaderSource(c,"      uniform sampler2D texture;      void main() {        gl_FragColor = texture2D(texture, vec2(0.5));      }    "),e.compileShader(n),e.compileShader(c),e.attachShader(a,n),e.attachShader(a,c),e.linkProgram(a);var l=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,l),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0]),e.STREAM_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0);var u=new Uint8Array(4);return e.useProgram(a),e.viewport(0,0,1,1),e.bindTexture(e.TEXTURE_2D,i),e.drawArrays(e.POINTS,0,1),e.readPixels(0,0,1,1,e.RGBA,e.UNSIGNED_BYTE,u),127===u[0]||128===u[0]}function t(){}function r(e){return void 0===e.$OES_texture_float_linear$&&Object.defineProperty(e,"$OES_texture_float_linear$",{enumerable:!1,configurable:!1,writable:!1,value:new t}),e.$OES_texture_float_linear$}function o(e){return"OES_texture_float_linear"===e?r(this):c.call(this,e)}function i(){var e=l.call(this);return-1===e.indexOf("OES_texture_float_linear")&&e.push("OES_texture_float_linear"),e}try{var a=document.createElement("canvas").getContext("experimental-webgl")}catch(n){}if(a&&-1===a.getSupportedExtensions().indexOf("OES_texture_float_linear")&&e(a)){var c=WebGLRenderingContext.prototype.getExtension,l=WebGLRenderingContext.prototype.getSupportedExtensions;WebGLRenderingContext.prototype.getExtension=o,WebGLRenderingContext.prototype.getSupportedExtensions=i}}();var oe;re.canvas=function(){var e=document.createElement("canvas");try{oe=e.getContext("experimental-webgl",{premultipliedAlpha:!1})}catch(t){oe=null}if(!oe)throw"This browser does not support WebGL";return e._={gl:oe,isInitialized:!1,texture:null,spareTexture:null,flippedShader:null},e.texture=s(r),e.draw=s(i),e.update=s(a),e.replace=s(c),e.contents=s(l),e.getPixelArray=s(u),e.brightnessContrast=s(g),e.hexagonalPixelate=s(K),e.hueSaturation=s(G),e.colorHalftone=s(V),e.triangleBlur=s(q),e.unsharpMask=s(O),e.perspective=s(ee),e.matrixWarp=s(Z),e.bulgePinch=s(Q),e.tiltShift=s(Y),e.dotScreen=s(j),e.edgeWork=s($),e.lensBlur=s(W),e.zoomBlur=s(H),e.noise=s(X),e.denoise=s(y),e.zinc=s(I),e.nightvision=s(S),e.posterize=s(z),e.murica=s(D),e.badtv=s(R),e.snow=s(U),e.fire=s(F),e.rainbow=s(P),e.cocoa=s(L),e.bokeh=s(b),e.flare=s(_),e.magazine=s(A),e.crosshatch=s(B),e.spycam=s(E),e.halo=s(C),e.smoke=s(w),e.berry=s(T),e.curves=s(p),e.swirl=s(te),e.ink=s(J),e.vignette=s(N),e.vibrance=s(M),e.sepia=s(k),e},re.splineInterpolate=v;var ie=function(){function e(e){return"[object Array]"==Object.prototype.toString.call(e)}function t(e){return"[object Number]"==Object.prototype.toString.call(e)}function r(e,t){var r=oe.createShader(e);if(oe.shaderSource(r,t),oe.compileShader(r),!oe.getShaderParameter(r,oe.COMPILE_STATUS))throw"compile error: "+oe.getShaderInfoLog(r);return r}function o(e,t){if(this.vertexAttribute=null,this.texCoordAttribute=null,this.program=oe.createProgram(),e=e||i,t=t||a,t="precision highp float;"+t,oe.attachShader(this.program,r(oe.VERTEX_SHADER,e)),oe.attachShader(this.program,r(oe.FRAGMENT_SHADER,t)),oe.linkProgram(this.program),!oe.getProgramParameter(this.program,oe.LINK_STATUS))throw"link error: "+oe.getProgramInfoLog(this.program)}var i="    attribute vec2 vertex;    attribute vec2 _texCoord;    varying vec2 texCoord;    void main() {        texCoord = _texCoord;        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);    }",a="    uniform sampler2D texture;    varying vec2 texCoord;    void main() {        gl_FragColor = texture2D(texture, texCoord);    }";return o.prototype.destroy=function(){oe.deleteProgram(this.program),this.program=null},o.prototype.uniforms=function(r){oe.useProgram(this.program);for(var o in r)if(r.hasOwnProperty(o)){var i=oe.getUniformLocation(this.program,o);if(null!==i){var a=r[o];if(e(a))switch(a.length){case 1:oe.uniform1fv(i,new Float32Array(a));break;case 2:oe.uniform2fv(i,new Float32Array(a));break;case 3:oe.uniform3fv(i,new Float32Array(a));break;case 4:oe.uniform4fv(i,new Float32Array(a));break;case 9:oe.uniformMatrix3fv(i,!1,new Float32Array(a));break;case 16:oe.uniformMatrix4fv(i,!1,new Float32Array(a));break;default:throw"dont't know how to load uniform \""+o+'" of length '+a.length}else{if(!t(a))throw'attempted to set uniform "'+o+'" to invalid value '+(a||"undefined").toString();oe.uniform1f(i,a)}}}return this},o.prototype.textures=function(e){oe.useProgram(this.program);for(var t in e)e.hasOwnProperty(t)&&oe.uniform1i(oe.getUniformLocation(this.program,t),e[t]);return this},o.prototype.drawRect=function(e,t,r,o){var i,a=oe.getParameter(oe.VIEWPORT);t=t!==i?(t-a[1])/a[3]:0,e=e!==i?(e-a[0])/a[2]:0,r=r!==i?(r-a[0])/a[2]:1,o=o!==i?(o-a[1])/a[3]:1,null==oe.vertexBuffer&&(oe.vertexBuffer=oe.createBuffer()),oe.bindBuffer(oe.ARRAY_BUFFER,oe.vertexBuffer),oe.bufferData(oe.ARRAY_BUFFER,new Float32Array([e,t,e,o,r,t,r,o]),oe.STATIC_DRAW),null==oe.texCoordBuffer&&(oe.texCoordBuffer=oe.createBuffer(),oe.bindBuffer(oe.ARRAY_BUFFER,oe.texCoordBuffer),oe.bufferData(oe.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),oe.STATIC_DRAW)),null==this.vertexAttribute&&(this.vertexAttribute=oe.getAttribLocation(this.program,"vertex"),oe.enableVertexAttribArray(this.vertexAttribute)),null==this.texCoordAttribute&&(this.texCoordAttribute=oe.getAttribLocation(this.program,"_texCoord"),oe.enableVertexAttribArray(this.texCoordAttribute)),oe.useProgram(this.program),oe.bindBuffer(oe.ARRAY_BUFFER,oe.vertexBuffer),oe.vertexAttribPointer(this.vertexAttribute,2,oe.FLOAT,!1,0,0),oe.bindBuffer(oe.ARRAY_BUFFER,oe.texCoordBuffer),oe.vertexAttribPointer(this.texCoordAttribute,2,oe.FLOAT,!1,0,0),oe.drawArrays(oe.TRIANGLE_STRIP,0,4)},o.getDefaultShader=function(){return oe.defaultShader=oe.defaultShader||new o,oe.defaultShader},o}();m.prototype.interpolate=function(e){for(var t=this.ya.length,r=0,o=t-1;o-r>1;){var i=o+r>>1;this.xa[i]>e?o=i:r=i}var a=this.xa[o]-this.xa[r],n=(this.xa[o]-e)/a,c=(e-this.xa[r])/a;return n*this.ya[r]+c*this.ya[o]+((n*n*n-n)*this.y2[r]+(c*c*c-c)*this.y2[o])*(a*a)/6};var ae=function(){function e(e,t,r,o){this.gl=oe,this.id=oe.createTexture(),this.width=e,this.height=t,this.format=r,this.type=o,oe.bindTexture(oe.TEXTURE_2D,this.id),oe.texParameteri(oe.TEXTURE_2D,oe.TEXTURE_MAG_FILTER,oe.LINEAR),oe.texParameteri(oe.TEXTURE_2D,oe.TEXTURE_MIN_FILTER,oe.LINEAR),oe.texParameteri(oe.TEXTURE_2D,oe.TEXTURE_WRAP_S,oe.CLAMP_TO_EDGE),oe.texParameteri(oe.TEXTURE_2D,oe.TEXTURE_WRAP_T,oe.CLAMP_TO_EDGE),e&&t&&oe.texImage2D(oe.TEXTURE_2D,0,this.format,e,t,0,this.format,this.type,null)}function t(e){null==r&&(r=document.createElement("canvas")),r.width=e.width,r.height=e.height;var t=r.getContext("2d");return t.clearRect(0,0,r.width,r.height),t}e.fromElement=function(t){var r=new e(0,0,oe.RGBA,oe.UNSIGNED_BYTE);return r.loadContentsOf(t),r},e.prototype.loadContentsOf=function(e){this.width=e.width||e.videoWidth,this.height=e.height||e.videoHeight,oe.bindTexture(oe.TEXTURE_2D,this.id),oe.texImage2D(oe.TEXTURE_2D,0,this.format,this.format,this.type,e)},e.prototype.initFromBytes=function(e,t,r){this.width=e,this.height=t,this.format=oe.RGBA,this.type=oe.UNSIGNED_BYTE,oe.bindTexture(oe.TEXTURE_2D,this.id),oe.texImage2D(oe.TEXTURE_2D,0,oe.RGBA,e,t,0,oe.RGBA,this.type,new Uint8Array(r))},e.prototype.destroy=function(){oe.deleteTexture(this.id),this.id=null},e.prototype.use=function(e){oe.activeTexture(oe.TEXTURE0+(e||0)),oe.bindTexture(oe.TEXTURE_2D,this.id)},e.prototype.unuse=function(e){oe.activeTexture(oe.TEXTURE0+(e||0)),oe.bindTexture(oe.TEXTURE_2D,null)},e.prototype.ensureFormat=function(e,t,r,o){if(1==arguments.length){var i=arguments[0];e=i.width,t=i.height,r=i.format,o=i.type}(e!=this.width||t!=this.height||r!=this.format||o!=this.type)&&(this.width=e,this.height=t,this.format=r,this.type=o,oe.bindTexture(oe.TEXTURE_2D,this.id),oe.texImage2D(oe.TEXTURE_2D,0,this.format,e,t,0,this.format,this.type,null))},e.prototype.drawTo=function(e){if(oe.framebuffer=oe.framebuffer||oe.createFramebuffer(),oe.bindFramebuffer(oe.FRAMEBUFFER,oe.framebuffer),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_2D,this.id,0),oe.checkFramebufferStatus(oe.FRAMEBUFFER)!==oe.FRAMEBUFFER_COMPLETE)throw new Error("incomplete framebuffer");oe.viewport(0,0,this.width,this.height),e(),oe.bindFramebuffer(oe.FRAMEBUFFER,null)};var r=null;return e.prototype.fillUsingCanvas=function(e){return e(t(this)),this.format=oe.RGBA,this.type=oe.UNSIGNED_BYTE,oe.bindTexture(oe.TEXTURE_2D,this.id),oe.texImage2D(oe.TEXTURE_2D,0,oe.RGBA,oe.RGBA,oe.UNSIGNED_BYTE,r),this},e.prototype.toImage=function(e){this.use(),ie.getDefaultShader().drawRect();var o=this.width*this.height*4,i=new Uint8Array(o),a=t(this),n=a.createImageData(this.width,this.height);oe.readPixels(0,0,this.width,this.height,oe.RGBA,oe.UNSIGNED_BYTE,i);for(var c=0;o>c;c++)n.data[c]=i[c];a.putImageData(n,0,0),e.src=r.toDataURL()},e.prototype.swapWith=function(e){var t;t=e.id,e.id=this.id,this.id=t,t=e.width,e.width=this.width,this.width=t,t=e.height,e.height=this.height,this.height=t,t=e.format,e.format=this.format,this.format=t},e}(),ne="    float random(vec3 scale, float seed) {        /* use the fragment position for a different seed per-pixel */        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);    }";return re}();


    // JWPlayer
      /*!
   JW Player version 8.9.3
   Copyright (c) 2019, JW Player, All Rights Reserved 
   This source code and its use and distribution is subject to the terms 
   and conditions of the applicable license agreement. 
   https://www.jwplayer.com/tos/
   This product includes portions of other software. For the full text of licenses, see
   https://ssl.p.jwpcdn.com/player/v/8.9.3/notice.txt
*/
window.jwplayer = function(t) {
    function e(e) {
        for (var n, i, o = e[0], u = e[1], a = 0, s = []; a < o.length; a++) i = o[a], r[i] && s.push(r[i][0]), r[i] = 0;
        for (n in u) Object.prototype.hasOwnProperty.call(u, n) && (t[n] = u[n]);
        for (c && c(e); s.length;) s.shift()()
    }
    var n = {},
        r = {
            0: 0
        };

    function i(e) {
        if (n[e]) return n[e].exports;
        var r = n[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return t[e].call(r.exports, r, r.exports, i), r.l = !0, r.exports
    }
    i.e = function(t) {
        var e = [],
            n = r[t];
        if (0 !== n)
            if (n) e.push(n[2]);
            else {
                var o = new Promise(function(e, i) {
                    n = r[t] = [e, i]
                });
                e.push(n[2] = o);
                var u, a = document.createElement("script");
                a.charset = "utf-8", a.timeout = 55, i.nc && a.setAttribute("nonce", i.nc), a.src = function(t) {
                    return i.p + "" + ({
                        1: "jwplayer.controls",
                        2: "jwplayer.core",
                        3: "jwplayer.core.controls",
                        4: "jwplayer.core.controls.html5",
                        5: "jwplayer.core.controls.polyfills",
                        6: "jwplayer.core.controls.polyfills.html5",
                        7: "jwplayer.vr",
                        8: "polyfills.intersection-observer",
                        9: "polyfills.webvtt",
                        10: "provider.airplay",
                        11: "provider.cast",
                        12: "provider.flash",
                        13: "provider.hlsjs",
                        14: "provider.hlsjs-progressive",
                        15: "provider.html5",
                        16: "provider.shaka",
                        17: "related",
                        18: "vttparser"
                    } [t] || t) + ".js"
                }(t), u = function(e) {
                    a.onerror = a.onload = null, clearTimeout(c);
                    var n = r[t];
                    if (0 !== n) {
                        if (n) {
                            var i = e && ("load" === e.type ? "missing" : e.type),
                                o = e && e.target && e.target.src,
                                u = new Error("Loading chunk " + t + " failed.\n(" + i + ": " + o + ")");
                            u.type = i, u.request = o, n[1](u)
                        }
                        r[t] = void 0
                    }
                };
                var c = setTimeout(function() {
                    u({
                        type: "timeout",
                        target: a
                    })
                }, 55e3);
                a.onerror = a.onload = u, document.head.appendChild(a)
            } return Promise.all(e)
    }, i.m = t, i.c = n, i.d = function(t, e, n) {
        i.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: n
        })
    }, i.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, i.t = function(t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) i.d(n, r, function(e) {
                return t[e]
            }.bind(null, r));
        return n
    }, i.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i.oe = function(t) {
        throw console.error(t), t
    };
    var o = window.webpackJsonpjwplayer = window.webpackJsonpjwplayer || [],
        u = o.push.bind(o);
    o.push = e, o = o.slice();
    for (var a = 0; a < o.length; a++) e(o[a]);
    var c = u;
    return i(i.s = 66)
}([function(t, e, n) {
    "use strict";
    n.d(e, "j", function() {
        return k
    }), n.d(e, "B", function() {
        return P
    }), n.d(e, "G", function() {
        return S
    }), n.d(e, "m", function() {
        return A
    }), n.d(e, "l", function() {
        return F
    }), n.d(e, "a", function() {
        return M
    }), n.d(e, "b", function() {
        return L
    }), n.d(e, "H", function() {
        return R
    }), n.d(e, "o", function() {
        return V
    }), n.d(e, "I", function() {
        return W
    }), n.d(e, "e", function() {
        return X
    }), n.d(e, "K", function() {
        return H
    }), n.d(e, "n", function() {
        return Y
    }), n.d(e, "i", function() {
        return K
    }), n.d(e, "q", function() {
        return J
    }), n.d(e, "c", function() {
        return G
    }), n.d(e, "D", function() {
        return et
    }), n.d(e, "J", function() {
        return it
    }), n.d(e, "r", function() {
        return at
    }), n.d(e, "h", function() {
        return ct
    }), n.d(e, "k", function() {
        return st
    }), n.d(e, "E", function() {
        return lt
    }), n.d(e, "x", function() {
        return dt
    }), n.d(e, "u", function() {
        return gt
    }), n.d(e, "w", function() {
        return bt
    }), n.d(e, "y", function() {
        return mt
    }), n.d(e, "t", function() {
        return yt
    }), n.d(e, "v", function() {
        return jt
    }), n.d(e, "s", function() {
        return wt
    }), n.d(e, "z", function() {
        return Ot
    }), n.d(e, "p", function() {
        return Ct
    }), n.d(e, "d", function() {
        return Pt
    }), n.d(e, "F", function() {
        return xt
    }), n.d(e, "C", function() {
        return St
    }), n.d(e, "A", function() {
        return Tt
    }), n.d(e, "f", function() {
        return At
    });
    var r = n(18),
        i = {},
        o = Array.prototype,
        u = Object.prototype,
        a = Function.prototype,
        c = o.slice,
        s = o.concat,
        l = u.toString,
        f = u.hasOwnProperty,
        d = o.map,
        p = o.reduce,
        h = o.forEach,
        v = o.filter,
        g = o.every,
        b = o.some,
        m = o.indexOf,
        y = Array.isArray,
        j = Object.keys,
        w = a.bind,
        O = window.isFinite,
        k = function(t, e, n) {
            var r, o;
            if (null == t) return t;
            if (h && t.forEach === h) t.forEach(e, n);
            else if (t.length === +t.length) {
                for (r = 0, o = t.length; r < o; r++)
                    if (e.call(n, t[r], r, t) === i) return
            } else {
                var u = ot(t);
                for (r = 0, o = u.length; r < o; r++)
                    if (e.call(n, t[u[r]], u[r], t) === i) return
            }
            return t
        },
        C = k,
        P = function(t, e, n) {
            var r = [];
            return null == t ? r : d && t.map === d ? t.map(e, n) : (k(t, function(t, i, o) {
                r.push(e.call(n, t, i, o))
            }), r)
        },
        x = P,
        S = function(t, e, n, r) {
            var i = arguments.length > 2;
            if (null == t && (t = []), p && t.reduce === p) return r && (e = G(e, r)), i ? t.reduce(e, n) : t.reduce(e);
            if (k(t, function(t, o, u) {
                    i ? n = e.call(r, n, t, o, u) : (n = t, i = !0)
                }), !i) throw new TypeError("Reduce of empty array with no initial value");
            return n
        },
        E = S,
        T = S,
        A = function(t, e, n) {
            var r;
            return L(t, function(t, i, o) {
                if (e.call(n, t, i, o)) return r = t, !0
            }), r
        },
        _ = A,
        F = function(t, e, n) {
            var r = [];
            return null == t ? r : v && t.filter === v ? t.filter(e, n) : (k(t, function(t, i, o) {
                e.call(n, t, i, o) && r.push(t)
            }), r)
        },
        I = F,
        M = function(t, e, n) {
            e || (e = Ct);
            var r = !0;
            return null == t ? r : g && t.every === g ? t.every(e, n) : (k(t, function(t, o, u) {
                if (!(r = r && e.call(n, t, o, u))) return i
            }), !!r)
        },
        N = M,
        L = function(t, e, n) {
            e || (e = Ct);
            var r = !1;
            return null == t ? r : b && t.some === b ? t.some(e, n) : (k(t, function(t, o, u) {
                if (r || (r = e.call(n, t, o, u))) return i
            }), !!r)
        },
        D = L,
        R = function(t) {
            return null == t ? 0 : t.length === +t.length ? t.length : ot(t).length
        },
        B = function(t, e) {
            var n;
            return function() {
                return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n
            }
        },
        q = function(t) {
            return null == t ? Ct : gt(t) ? t : xt(t)
        },
        z = function(t) {
            return function(e, n, r) {
                var i = {};
                return n = q(n), k(e, function(o, u) {
                    var a = n.call(r, o, u, e);
                    t(i, a, o)
                }), i
            }
        },
        V = z(function(t, e, n) {
            kt(t, e) ? t[e].push(n) : t[e] = [n]
        }),
        Q = z(function(t, e, n) {
            t[e] = n
        }),
        W = function(t, e, n, r) {
            for (var i = (n = q(n)).call(r, e), o = 0, u = t.length; o < u;) {
                var a = o + u >>> 1;
                n.call(r, t[a]) < i ? o = a + 1 : u = a
            }
            return o
        },
        X = function(t, e) {
            return null != t && (t.length !== +t.length && (t = ut(t)), J(t, e) >= 0)
        },
        U = X,
        H = function(t, e) {
            return F(t, St(e))
        },
        Y = function(t, e) {
            return A(t, St(e))
        },
        K = function(t) {
            var e = s.apply(o, c.call(arguments, 1));
            return F(t, function(t) {
                return !X(e, t)
            })
        },
        J = function(t, e, n) {
            if (null == t) return -1;
            var r = 0,
                i = t.length;
            if (n) {
                if ("number" != typeof n) return t[r = W(t, e)] === e ? r : -1;
                r = n < 0 ? Math.max(0, i + n) : n
            }
            if (m && t.indexOf === m) return t.indexOf(e, n);
            for (; r < i; r++)
                if (t[r] === e) return r;
            return -1
        },
        $ = function() {},
        G = function(t, e) {
            var n, r;
            if (w && t.bind === w) return w.apply(t, c.call(arguments, 1));
            if (!gt(t)) throw new TypeError;
            return n = c.call(arguments, 2), r = function() {
                if (!(this instanceof r)) return t.apply(e, n.concat(c.call(arguments)));
                $.prototype = t.prototype;
                var i = new $;
                $.prototype = null;
                var o = t.apply(i, n.concat(c.call(arguments)));
                return Object(o) === o ? o : i
            }
        },
        Z = function(t) {
            var e = c.call(arguments, 1);
            return function() {
                for (var n = 0, r = e.slice(), i = 0, o = r.length; i < o; i++) kt(r[i], "partial") && (r[i] = arguments[n++]);
                for (; n < arguments.length;) r.push(arguments[n++]);
                return t.apply(this, r)
            }
        },
        tt = Z(B, 2),
        et = function(t, e) {
            var n = {};
            return e || (e = Ct),
                function() {
                    var r = e.apply(this, arguments);
                    return kt(n, r) ? n[r] : n[r] = t.apply(this, arguments)
                }
        },
        nt = function(t, e) {
            var n = c.call(arguments, 2);
            return setTimeout(function() {
                return t.apply(null, n)
            }, e)
        },
        rt = Z(nt, {
            partial: Z
        }, 1),
        it = function(t, e, n) {
            var r, i, o, u = null,
                a = 0;
            n || (n = {});
            var c = function() {
                a = !1 === n.leading ? 0 : Et(), u = null, o = t.apply(r, i), r = i = null
            };
            return function() {
                a || !1 !== n.leading || (a = Et);
                var s = e - (Et - a);
                return r = this, i = arguments, s <= 0 ? (clearTimeout(u), u = null, a = Et, o = t.apply(r, i), r = i = null) : u || !1 === n.trailing || (u = setTimeout(c, s)), o
            }
        },
        ot = function(t) {
            if (!dt(t)) return [];
            if (j) return j(t);
            var e = [];
            for (var n in t) kt(t, n) && e.push(n);
            return e
        },
        ut = function(t) {
            for (var e = ot(t), n = ot.length, r = Array(n), i = 0; i < n; i++) r[i] = t[e[i]];
            return r
        },
        at = function(t) {
            for (var e = {}, n = ot(t), r = 0, i = n.length; r < i; r++) e[t[n[r]]] = n[r];
            return e
        },
        ct = function(t) {
            return k(c.call(arguments, 1), function(e) {
                if (e)
                    for (var n in e) void 0 === t[n] && (t[n] = e[n])
            }), t
        },
        st = Object.assign || function(t) {
            return k(c.call(arguments, 1), function(e) {
                if (e)
                    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }), t
        },
        lt = function(t) {
            var e = {},
                n = s.apply(o, c.call(arguments, 1));
            return k(n, function(n) {
                n in t && (e[n] = t[n])
            }), e
        },
        ft = y || function(t) {
            return "[object Array]" == l.call(t)
        },
        dt = function(t) {
            return t === Object(t)
        },
        pt = [];
    k(["Function", "String", "Number", "Date", "RegExp"], function(t) {
        pt[t] = function(e) {
            return l.call(e) == "[object " + t + "]"
        }
    }), pt.Function = function(t) {
        return "function" == typeof t
    };
    var ht = pt.Date,
        vt = pt.RegExp,
        gt = pt.Function,
        bt = pt.Number,
        mt = pt.String,
        yt = function(t) {
            return O(t) && !jt(parseFloat(t))
        },
        jt = function(t) {
            return bt(t) && t != +t
        },
        wt = function(t) {
            return !0 === t || !1 === t || "[object Boolean]" == l.call(t)
        },
        Ot = function(t) {
            return void 0 === t
        },
        kt = function(t, e) {
            return f.call(t, e)
        },
        Ct = function(t) {
            return t
        },
        Pt = function(t) {
            return function() {
                return t
            }
        },
        xt = function(t) {
            return function(e) {
                return e[t]
            }
        },
        St = function(t) {
            return function(e) {
                if (e === t) return !0;
                for (var n in t)
                    if (t[n] !== e[n]) return !1;
                return !0
            }
        },
        Et = r.a,
        Tt = function(t) {
            return bt(t) && !jt(t)
        },
        At = function(t) {
            var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
            return function() {
                for (var r = this, i = arguments.length, o = new Array(i), u = 0; u < i; u++) o[u] = arguments[u];
                clearTimeout(e), e = setTimeout(function() {
                    t.apply(r, o)
                }, n)
            }
        };
    e.g = {
        after: function(t, e) {
            return function() {
                if (--t < 1) return e.apply(this, arguments)
            }
        },
        all: M,
        any: L,
        before: B,
        bind: G,
        clone: function(t) {
            return dt(t) ? ft(t) ? t.slice() : st({}, t) : t
        },
        collect: x,
        compact: function(t) {
            return F(t, Ct)
        },
        constant: Pt,
        contains: X,
        debounce: At,
        defaults: ct,
        defer: rt,
        delay: nt,
        detect: _,
        difference: K,
        each: k,
        every: N,
        extend: st,
        filter: F,
        find: A,
        findWhere: Y,
        foldl: E,
        forEach: C,
        groupBy: V,
        has: kt,
        identity: Ct,
        include: U,
        indexBy: Q,
        indexOf: J,
        inject: T,
        invert: at,
        isArray: ft,
        isBoolean: wt,
        isDate: ht,
        isFinite: yt,
        isFunction: gt,
        isNaN: jt,
        isNull: function(t) {
            return null === t
        },
        isNumber: bt,
        isObject: dt,
        isRegExp: vt,
        isString: mt,
        isUndefined: Ot,
        isValidNumber: Tt,
        keys: ot,
        last: function(t, e, n) {
            if (null != t) return null == e || n ? t[t.length - 1] : c.call(t, Math.max(t.length - e, 0))
        },
        map: P,
        matches: St,
        max: function(t, e, n) {
            if (!e && ft(t) && t[0] === +t[0] && t.length < 65535) return Math.max.apply(Math, t);
            var r = -1 / 0,
                i = -1 / 0;
            return k(t, function(t, o, u) {
                var a = e ? e.call(n, t, o, u) : t;
                a > i && (r = t, i = a)
            }), r
        },
        memoize: et,
        now: Et,
        omit: function(t) {
            var e = {},
                n = s.apply(o, c.call(arguments, 1));
            for (var r in t) X(n, r) || (e[r] = t[r]);
            return e
        },
        once: tt,
        partial: Z,
        pick: lt,
        pluck: function(t, e) {
            return P(t, xt(e))
        },
        property: xt,
        propertyOf: function(t) {
            return null == t ? function() {} : function(e) {
                return t[e]
            }
        },
        reduce: S,
        reject: function(t, e, n) {
            return F(t, function(t, r, i) {
                return !e.call(n, t, r, i)
            }, n)
        },
        result: function(t, e) {
            if (null != t) {
                var n = t[e];
                return gt(n) ? n.call(t) : n
            }
        },
        select: I,
        size: R,
        some: D,
        sortedIndex: W,
        throttle: it,
        where: H,
        without: function(t) {
            return K(t, c.call(arguments, 1))
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "y", function() {
        return o
    }), n.d(e, "x", function() {
        return u
    }), n.d(e, "w", function() {
        return a
    }), n.d(e, "t", function() {
        return c
    }), n.d(e, "u", function() {
        return s
    }), n.d(e, "a", function() {
        return l
    }), n.d(e, "c", function() {
        return f
    }), n.d(e, "v", function() {
        return d
    }), n.d(e, "d", function() {
        return p
    }), n.d(e, "h", function() {
        return h
    }), n.d(e, "e", function() {
        return v
    }), n.d(e, "k", function() {
        return g
    }), n.d(e, "i", function() {
        return b
    }), n.d(e, "j", function() {
        return m
    }), n.d(e, "b", function() {
        return P
    }), n.d(e, "f", function() {
        return x
    }), n.d(e, "g", function() {
        return S
    }), n.d(e, "o", function() {
        return E
    }), n.d(e, "l", function() {
        return T
    }), n.d(e, "m", function() {
        return A
    }), n.d(e, "n", function() {
        return _
    }), n.d(e, "p", function() {
        return F
    }), n.d(e, "q", function() {
        return I
    }), n.d(e, "r", function() {
        return M
    }), n.d(e, "s", function() {
        return N
    }), n.d(e, "A", function() {
        return L
    }), n.d(e, "z", function() {
        return D
    }), n.d(e, "B", function() {
        return R
    });
    var r = n(0);

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    var o = 1e5,
        u = 100001,
        a = 100002,
        c = 101e3,
        s = 102e3,
        l = 200001,
        f = 202e3,
        d = 104e3,
        p = 203e3,
        h = 203640,
        v = 204e3,
        g = 210001,
        b = 21e4,
        m = 214e3,
        y = 303200,
        j = 303210,
        w = 303212,
        O = 303213,
        k = 303220,
        C = 303230,
        P = 306e3,
        x = 308e3,
        S = 308640,
        E = "cantPlayVideo",
        T = "badConnection",
        A = "cantLoadPlayer",
        _ = "cantPlayInBrowser",
        F = "liveStreamDown",
        I = "protectedContent",
        M = "technicalError",
        N = function() {
            function t(e, n) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.code = Object(r.A)(n) ? n : 0, this.sourceError = i, e && (this.key = e)
            }
            var e, n, o;
            return e = t, o = [{
                key: "logMessage",
                value: function(t) {
                    var e = t % 1e3,
                        n = Math.floor((t - e) / 1e3),
                        r = t;
                    return e >= 400 && e < 600 && (r = "".concat(n, "400-").concat(n, "599")), "JW Player ".concat(t > 299999 && t < 4e5 ? "Warning" : "Error", " ").concat(t, ". For more information see https://developer.jwplayer.com/jw-player/docs/developer-guide/api/errors-reference#").concat(r)
                }
            }], (n = null) && i(e.prototype, n), o && i(e, o), t
        }();

    function L(t, e, n) {
        return n instanceof N && n.code ? n : new N(t, e, n)
    }

    function D(t, e) {
        var n = L(M, e, t);
        return n.code = (t && t.code || 0) + e, n
    }

    function R(t) {
        var e = t.name,
            n = t.message;
        switch (e) {
            case "AbortError":
                return /pause/.test(n) ? O : /load/.test(n) ? w : j;
            case "NotAllowedError":
                return k;
            case "NotSupportedError":
                return C;
            default:
                return y
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "i", function() {
        return o
    }), n.d(e, "e", function() {
        return u
    }), n.d(e, "j", function() {
        return a
    }), n.d(e, "a", function() {
        return c
    }), n.d(e, "b", function() {
        return s
    }), n.d(e, "g", function() {
        return l
    }), n.d(e, "d", function() {
        return f
    }), n.d(e, "f", function() {
        return d
    }), n.d(e, "h", function() {
        return p
    }), n.d(e, "c", function() {
        return h
    });
    var r = n(0),
        i = window.parseFloat;

    function o(t) {
        return t.replace(/^\s+|\s+$/g, "")
    }

    function u(t, e, n) {
        for (t = "" + t, n = n || "0"; t.length < e;) t = n + t;
        return t
    }

    function a(t, e) {
        for (var n = t.attributes, r = 0; r < n.length; r++)
            if (n[r].name && n[r].name.toLowerCase() === e.toLowerCase()) return n[r].value.toString();
        return ""
    }

    function c(t) {
        if (!t || "rtmp" === t.substr(0, 4)) return "";
        var e = /[(,]format=(m3u8|mpd)-/i.exec(t);
        return e ? e[1] : (t = t.split("?")[0].split("#")[0]).lastIndexOf(".") > -1 ? t.substr(t.lastIndexOf(".") + 1, t.length).toLowerCase() : void 0
    }

    function s(t) {
        var e = (t / 60 | 0) % 60,
            n = t % 60;
        return u(t / 3600 | 0, 2) + ":" + u(e, 2) + ":" + u(n.toFixed(3), 6)
    }

    function l(t, e) {
        if (!t) return 0;
        if (Object(r.A)(t)) return t;
        var n = t.replace(",", "."),
            o = n.slice(-1),
            u = n.split(":"),
            a = u.length,
            c = 0;
        if ("s" === o) c = i(n);
        else if ("m" === o) c = 60 * i(n);
        else if ("h" === o) c = 3600 * i(n);
        else if (a > 1) {
            var s = a - 1;
            4 === a && (e && (c = i(u[s]) / e), s -= 1), c += i(u[s]), c += 60 * i(u[s - 1]), a >= 3 && (c += 3600 * i(u[s - 2]))
        } else c = i(n);
        return Object(r.A)(c) ? c : 0
    }

    function f(t, e, n) {
        if (Object(r.y)(t) && "%" === t.slice(-1)) {
            var o = i(t);
            return e && Object(r.A)(e) && Object(r.A)(o) ? e * o / 100 : null
        }
        return l(t, n)
    }

    function d(t, e) {
        return t.map(function(t) {
            return e + t
        })
    }

    function p(t, e) {
        return t.map(function(t) {
            return t + e
        })
    }

    function h(t) {
        return "string" == typeof t && "%" === t.slice(-1)
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "kb", function() {
        return r
    }), n.d(e, "nb", function() {
        return i
    }), n.d(e, "lb", function() {
        return o
    }), n.d(e, "pb", function() {
        return u
    }), n.d(e, "qb", function() {
        return a
    }), n.d(e, "mb", function() {
        return c
    }), n.d(e, "ob", function() {
        return s
    }), n.d(e, "rb", function() {
        return l
    }), n.d(e, "s", function() {
        return f
    }), n.d(e, "u", function() {
        return d
    }), n.d(e, "t", function() {
        return p
    }), n.d(e, "n", function() {
        return h
    }), n.d(e, "q", function() {
        return v
    }), n.d(e, "sb", function() {
        return g
    }), n.d(e, "r", function() {
        return b
    }), n.d(e, "Z", function() {
        return m
    }), n.d(e, "W", function() {
        return y
    }), n.d(e, "v", function() {
        return j
    }), n.d(e, "Y", function() {
        return w
    }), n.d(e, "w", function() {
        return O
    }), n.d(e, "ub", function() {
        return k
    }), n.d(e, "a", function() {
        return C
    }), n.d(e, "b", function() {
        return P
    }), n.d(e, "c", function() {
        return x
    }), n.d(e, "d", function() {
        return S
    }), n.d(e, "e", function() {
        return E
    }), n.d(e, "h", function() {
        return T
    }), n.d(e, "F", function() {
        return A
    }), n.d(e, "hb", function() {
        return _
    }), n.d(e, "Q", function() {
        return F
    }), n.d(e, "C", function() {
        return I
    }), n.d(e, "B", function() {
        return M
    }), n.d(e, "E", function() {
        return N
    }), n.d(e, "p", function() {
        return L
    }), n.d(e, "cb", function() {
        return D
    }), n.d(e, "m", function() {
        return R
    }), n.d(e, "G", function() {
        return B
    }), n.d(e, "H", function() {
        return q
    }), n.d(e, "N", function() {
        return z
    }), n.d(e, "O", function() {
        return V
    }), n.d(e, "R", function() {
        return Q
    }), n.d(e, "jb", function() {
        return W
    }), n.d(e, "bb", function() {
        return X
    }), n.d(e, "D", function() {
        return U
    }), n.d(e, "S", function() {
        return H
    }), n.d(e, "P", function() {
        return Y
    }), n.d(e, "T", function() {
        return K
    }), n.d(e, "V", function() {
        return J
    }), n.d(e, "M", function() {
        return $
    }), n.d(e, "L", function() {
        return G
    }), n.d(e, "K", function() {
        return Z
    }), n.d(e, "I", function() {
        return tt
    }), n.d(e, "J", function() {
        return et
    }), n.d(e, "U", function() {
        return nt
    }), n.d(e, "o", function() {
        return rt
    }), n.d(e, "y", function() {
        return it
    }), n.d(e, "ib", function() {
        return ot
    }), n.d(e, "db", function() {
        return ut
    }), n.d(e, "eb", function() {
        return at
    }), n.d(e, "f", function() {
        return ct
    }), n.d(e, "g", function() {
        return st
    }), n.d(e, "ab", function() {
        return lt
    }), n.d(e, "A", function() {
        return ft
    }), n.d(e, "l", function() {
        return dt
    }), n.d(e, "k", function() {
        return pt
    }), n.d(e, "fb", function() {
        return ht
    }), n.d(e, "gb", function() {
        return vt
    }), n.d(e, "tb", function() {
        return gt
    }), n.d(e, "z", function() {
        return bt
    }), n.d(e, "j", function() {
        return mt
    }), n.d(e, "X", function() {
        return yt
    }), n.d(e, "i", function() {
        return jt
    }), n.d(e, "x", function() {
        return wt
    });
    var r = "buffering",
        i = "idle",
        o = "complete",
        u = "paused",
        a = "playing",
        c = "error",
        s = "loading",
        l = "stalled",
        f = "drag",
        d = "dragStart",
        p = "dragEnd",
        h = "click",
        v = "doubleClick",
        g = "tap",
        b = "doubleTap",
        m = "over",
        y = "move",
        j = "enter",
        w = "out",
        O = c,
        k = "warning",
        C = "adClick",
        P = "adPause",
        x = "adPlay",
        S = "adSkipped",
        E = "adTime",
        T = "autostartNotAllowed",
        A = o,
        _ = "ready",
        F = "seek",
        I = "beforePlay",
        M = "beforeComplete",
        N = "bufferFull",
        L = "displayClick",
        D = "playlistComplete",
        R = "cast",
        B = "mediaError",
        q = "firstFrame",
        z = "playAttempt",
        V = "playAttemptFailed",
        Q = "seeked",
        W = "setupError",
        X = "state",
        U = "bufferChange",
        H = "time",
        Y = "ratechange",
        K = "mediaType",
        J = "volume",
        $ = "mute",
        G = "metadataCueParsed",
        Z = "meta",
        tt = "levels",
        et = "levelsChanged",
        nt = "visualQuality",
        rt = "controls",
        it = "fullscreen",
        ot = "resize",
        ut = "playlistItem",
        at = "playlist",
        ct = "audioTracks",
        st = "audioTrackChanged",
        lt = "playbackRateChanged",
        ft = "logoClick",
        dt = "captionsList",
        pt = "captionsChanged",
        ht = "providerChanged",
        vt = "providerFirstFrame",
        gt = "userAction",
        bt = "instreamClick",
        mt = "breakpoint",
        yt = "fullscreenchange",
        jt = "bandwidthEstimate",
        wt = "float"
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return i
    }), n.d(e, "d", function() {
        return o
    }), n.d(e, "a", function() {
        return u
    }), n.d(e, "c", function() {
        return a
    });
    var r = n(2);

    function i(t) {
        var e = "";
        return t && (t.localName ? e = t.localName : t.baseName && (e = t.baseName)), e
    }

    function o(t) {
        var e = "";
        return t && (t.textContent ? e = Object(r.i)(t.textContent) : t.text && (e = Object(r.i)(t.text))), e
    }

    function u(t, e) {
        return t.childNodes[e]
    }

    function a(t) {
        return t.childNodes ? t.childNodes.length : 0
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(6);

    function i(t, e) {
        if (t && t.length > e) return t[e]
    }
    var o = n(0);
    n.d(e, "Browser", function() {
        return a
    }), n.d(e, "OS", function() {
        return c
    }), n.d(e, "Features", function() {
        return s
    });
    var u = navigator.userAgent;
    var a = {},
        c = {},
        s = {};
    Object.defineProperties(a, {
        androidNative: {
            get: Object(o.D)(r.c),
            enumerable: !0
        },
        chrome: {
            get: Object(o.D)(r.d),
            enumerable: !0
        },
        edge: {
            get: Object(o.D)(r.e),
            enumerable: !0
        },
        facebook: {
            get: Object(o.D)(r.g),
            enumerable: !0
        },
        firefox: {
            get: Object(o.D)(r.f),
            enumerable: !0
        },
        ie: {
            get: Object(o.D)(r.i),
            enumerable: !0
        },
        msie: {
            get: Object(o.D)(r.n),
            enumerable: !0
        },
        safari: {
            get: Object(o.D)(r.q),
            enumerable: !0
        },
        version: {
            get: Object(o.D)(function(t, e) {
                var n, r, i, o;
                return t.chrome ? n = -1 !== e.indexOf("Chrome") ? e.substring(e.indexOf("Chrome") + 7) : e.substring(e.indexOf("CriOS") + 6) : t.safari ? n = e.substring(e.indexOf("Version") + 8) : t.firefox ? n = e.substring(e.indexOf("Firefox") + 8) : t.edge ? n = e.substring(e.indexOf("Edge") + 5) : t.ie && (-1 !== e.indexOf("rv:") ? n = e.substring(e.indexOf("rv:") + 3) : -1 !== e.indexOf("MSIE") && (n = e.substring(e.indexOf("MSIE") + 5))), n && (-1 !== (o = n.indexOf(";")) && (n = n.substring(0, o)), -1 !== (o = n.indexOf(" ")) && (n = n.substring(0, o)), -1 !== (o = n.indexOf(")")) && (n = n.substring(0, o)), r = parseInt(n, 10), i = parseInt(n.split(".")[1], 10)), {
                    version: n,
                    major: r,
                    minor: i
                }
            }.bind(void 0, a, u)),
            enumerable: !0
        }
    }), Object.defineProperties(c, {
        android: {
            get: Object(o.D)(r.b),
            enumerable: !0
        },
        iOS: {
            get: Object(o.D)(r.j),
            enumerable: !0
        },
        mobile: {
            get: Object(o.D)(r.o),
            enumerable: !0
        },
        mac: {
            get: Object(o.D)(r.p),
            enumerable: !0
        },
        iPad: {
            get: Object(o.D)(r.k),
            enumerable: !0
        },
        iPhone: {
            get: Object(o.D)(r.l),
            enumerable: !0
        },
        windows: {
            get: Object(o.D)(function() {
                return u.indexOf("Windows") > -1
            }),
            enumerable: !0
        },
        version: {
            get: Object(o.D)(function(t, e) {
                var n, r, o;
                if (t.windows) switch (n = i(/Windows(?: NT|)? ([._\d]+)/.exec(e), 1)) {
                    case "6.1":
                        n = "7.0";
                        break;
                    case "6.2":
                        n = "8.0";
                        break;
                    case "6.3":
                        n = "8.1"
                } else t.android ? n = i(/Android ([._\d]+)/.exec(e), 1) : t.iOS ? n = i(/OS ([._\d]+)/.exec(e), 1) : t.mac && (n = i(/Mac OS X (10[._\d]+)/.exec(e), 1));
                if (n) {
                    r = parseInt(n, 10);
                    var u = n.split(/[._]/);
                    u && (o = parseInt(u[1], 10))
                }
                return {
                    version: n,
                    major: r,
                    minor: o
                }
            }.bind(void 0, c, u)),
            enumerable: !0
        }
    }), Object.defineProperties(s, {
        flash: {
            get: Object(o.D)(r.h),
            enumerable: !0
        },
        flashVersion: {
            get: Object(o.D)(r.a),
            enumerable: !0
        },
        iframe: {
            get: Object(o.D)(r.m),
            enumerable: !0
        },
        passiveEvents: {
            get: Object(o.D)(function() {
                var t = !1;
                try {
                    var e = Object.defineProperty({}, "passive", {
                        get: function() {
                            return t = !0
                        }
                    });
                    window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e)
                } catch (t) {}
                return t
            }),
            enumerable: !0
        },
        backgroundLoading: {
            get: Object(o.D)(function() {
                return !(c.iOS || a.safari)
            }),
            enumerable: !0
        }
    })
}, function(t, e, n) {
    "use strict";
    n.d(e, "h", function() {
        return u
    }), n.d(e, "f", function() {
        return a
    }), n.d(e, "l", function() {
        return s
    }), n.d(e, "k", function() {
        return l
    }), n.d(e, "p", function() {
        return f
    }), n.d(e, "g", function() {
        return d
    }), n.d(e, "e", function() {
        return p
    }), n.d(e, "n", function() {
        return h
    }), n.d(e, "d", function() {
        return v
    }), n.d(e, "i", function() {
        return g
    }), n.d(e, "q", function() {
        return b
    }), n.d(e, "j", function() {
        return m
    }), n.d(e, "c", function() {
        return y
    }), n.d(e, "b", function() {
        return j
    }), n.d(e, "o", function() {
        return w
    }), n.d(e, "m", function() {
        return O
    }), n.d(e, "a", function() {
        return k
    });
    var r = navigator.userAgent;

    function i(t) {
        return null !== r.match(t)
    }

    function o(t) {
        return function() {
            return i(t)
        }
    }

    function u() {
        var t = k();
        return !!(t && t >= 18)
    }
    var a = o(/gecko\//i),
        c = o(/trident\/.+rv:\s*11/i),
        s = o(/iP(hone|od)/i),
        l = o(/iPad/i),
        f = o(/Macintosh/i),
        d = o(/FBAV/i);

    function p() {
        return i(/\sEdge\/\d+/i)
    }

    function h() {
        return i(/msie/i)
    }

    function v() {
        return i(/\s(?:(?:Headless)?Chrome|CriOS)\//i) && !p() && !i(/UCBrowser/i)
    }

    function g() {
        return p() || c() || h()
    }

    function b() {
        return i(/safari/i) && !i(/(?:Chrome|CriOS|chromium|android|phantom)/i)
    }

    function m() {
        return i(/iP(hone|ad|od)/i)
    }

    function y() {
        return !(i(/chrome\/[123456789]/i) && !i(/chrome\/18/i) && !a()) && j()
    }

    function j() {
        return i(/Android/i) && !i(/Windows Phone/i)
    }

    function w() {
        return m() || j() || i(/Windows Phone/i)
    }

    function O() {
        try {
            return window.self !== window.top
        } catch (t) {
            return !0
        }
    }

    function k() {
        if (j()) return 0;
        var t, e = navigator.plugins;
        if (e && (t = e["Shockwave Flash"]) && t.description) return parseFloat(t.description.replace(/\D+(\d+\.?\d*).*/, "$1"));
        if (void 0 !== window.ActiveXObject) {
            try {
                if (t = new window.ActiveXObject("ShockwaveFlash.ShockwaveFlash")) return parseFloat(t.GetVariable("$version").split(" ")[1].replace(/\s*,\s*/, "."))
            } catch (t) {
                return 0
            }
            return t
        }
        return 0
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "h", function() {
        return a
    }), n.d(e, "e", function() {
        return c
    }), n.d(e, "p", function() {
        return s
    }), n.d(e, "i", function() {
        return l
    }), n.d(e, "r", function() {
        return f
    }), n.d(e, "q", function() {
        return d
    }), n.d(e, "t", function() {
        return p
    }), n.d(e, "d", function() {
        return g
    }), n.d(e, "a", function() {
        return b
    }), n.d(e, "n", function() {
        return m
    }), n.d(e, "o", function() {
        return y
    }), n.d(e, "u", function() {
        return j
    }), n.d(e, "s", function() {
        return w
    }), n.d(e, "g", function() {
        return O
    }), n.d(e, "b", function() {
        return k
    }), n.d(e, "f", function() {
        return C
    }), n.d(e, "c", function() {
        return P
    }), n.d(e, "l", function() {
        return x
    }), n.d(e, "j", function() {
        return S
    }), n.d(e, "m", function() {
        return E
    }), n.d(e, "k", function() {
        return T
    });
    var r, i = n(0),
        o = n(2),
        u = n(5);

    function a(t, e) {
        return t.classList.contains(e)
    }

    function c(t) {
        return l(t).firstChild
    }

    function s(t, e) {
        O(t),
            function(t, e) {
                if (!e) return;
                for (var n = document.createDocumentFragment(), r = l(e).childNodes, i = 0; i < r.length; i++) n.appendChild(r[i].cloneNode());
                t.appendChild(n)
            }(t, e)
    }

    function l(t) {
        r || (r = new DOMParser);
        var e = r.parseFromString(t, "text/html").body;
        f(e);
        for (var n = e.querySelectorAll("img,svg"), i = n.length; i--;) {
            d(n[i])
        }
        return e
    }

    function f(t) {
        for (var e = t.querySelectorAll("script,object,iframe"), n = e.length; n--;) {
            var r = e[n];
            r.parentNode.removeChild(r)
        }
        return t
    }

    function d(t) {
        for (var e = t.attributes, n = e.length; n--;) {
            var r = e[n].name;
            /^on/.test(r) && t.removeAttribute(r)
        }
        return t
    }

    function p(t) {
        return t + (t.toString().indexOf("%") > 0 ? "" : "px")
    }

    function h(t) {
        return Object(i.y)(t.className) ? t.className.split(" ") : []
    }

    function v(t, e) {
        e = Object(o.i)(e), t.className !== e && (t.className = e)
    }

    function g(t) {
        return t.classList ? t.classList : h(t)
    }

    function b(t, e) {
        var n = h(t);
        (Array.isArray(e) ? e : e.split(" ")).forEach(function(t) {
            Object(i.e)(n, t) || n.push(t)
        }), v(t, n.join(" "))
    }

    function m(t, e) {
        var n = h(t),
            r = Array.isArray(e) ? e : e.split(" ");
        v(t, Object(i.i)(n, r).join(" "))
    }

    function y(t, e, n) {
        var r = t.className || "";
        e.test(r) ? r = r.replace(e, n) : n && (r += " " + n), v(t, r)
    }

    function j(t, e, n) {
        var r = a(t, e);
        (n = Object(i.s)(n) ? n : !r) !== r && (n ? b(t, e) : m(t, e))
    }

    function w(t, e, n) {
        t.setAttribute(e, n)
    }

    function O(t) {
        for (; t.firstChild;) t.removeChild(t.firstChild)
    }

    function k(t) {
        var e = document.createElement("link");
        e.rel = "stylesheet", e.href = t, document.getElementsByTagName("head")[0].appendChild(e)
    }

    function C(t) {
        t && O(t)
    }

    function P(t) {
        var e = {
            left: 0,
            right: 0,
            width: 0,
            height: 0,
            top: 0,
            bottom: 0
        };
        if (!t || !document.body.contains(t)) return e;
        var n = t.getBoundingClientRect(),
            r = window.pageYOffset,
            i = window.pageXOffset;
        return n.width || n.height || n.left || n.top ? (e.left = n.left + i, e.right = n.right + i, e.top = n.top + r, e.bottom = n.bottom + r, e.width = n.right - n.left, e.height = n.bottom - n.top, e) : e
    }

    function x(t, e) {
        t.insertBefore(e, t.firstChild)
    }

    function S(t) {
        return t.nextElementSibling
    }

    function E(t) {
        return t.previousElementSibling
    }

    function T(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = document.createElement("a");
        r.href = t, r.target = e, r = Object(i.k)(r, n), u.Browser.firefox ? r.dispatchEvent(new MouseEvent("click", {
            bubbles: !0,
            cancelable: !0,
            view: window
        })) : r.click()
    }
}, function(t, e, n) {
    "use strict";

    function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    n.r(e), n.d(e, "exists", function() {
        return o
    }), n.d(e, "isHTTPS", function() {
        return u
    }), n.d(e, "isFileProtocol", function() {
        return a
    }), n.d(e, "isRtmp", function() {
        return c
    }), n.d(e, "isYouTube", function() {
        return s
    }), n.d(e, "typeOf", function() {
        return l
    }), n.d(e, "isDeepKeyCompliant", function() {
        return f
    });
    var i = window.location.protocol;

    function o(t) {
        switch (r(t)) {
            case "string":
                return t.length > 0;
            case "object":
                return null !== t;
            case "undefined":
                return !1;
            default:
                return !0
        }
    }

    function u() {
        return "https:" === i
    }

    function a() {
        return "file:" === i
    }

    function c(t, e) {
        return 0 === t.indexOf("rtmp:") || "rtmp" === e
    }

    function s(t, e) {
        return "youtube" === e || /^(http|\/\/).*(youtube\.com|youtu\.be)\/.+/.test(t)
    }

    function l(t) {
        if (null === t) return "null";
        var e = r(t);
        return "object" === e && Array.isArray(t) ? "array" : e
    }

    function f(t, e, n) {
        var i = Object.keys(t);
        return Object.keys(e).length >= i.length && i.every(function(i) {
            var o = t[i],
                u = e[i];
            return o && "object" === r(o) ? !(!u || "object" !== r(u)) && f(o, u, n) : n(i, t)
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.d(e, "a", function() {
        return u
    }), n.d(e, "c", function() {
        return a
    }), n.d(e, "d", function() {
        return c
    }), n.d(e, "b", function() {
        return s
    }), n.d(e, "e", function() {
        return l
    }), n.d(e, "f", function() {
        return f
    });
    var o = [].slice,
        u = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t)
            }
            var e, n, r;
            return e = t, (n = [{
                key: "on",
                value: function(t, e, n) {
                    if (!p(this, "on", t, [e, n]) || !e) return this;
                    var r = this._events || (this._events = {});
                    return (r[t] || (r[t] = [])).push({
                        callback: e,
                        context: n
                    }), this
                }
            }, {
                key: "once",
                value: function(t, e, n) {
                    if (!p(this, "once", t, [e, n]) || !e) return this;
                    var r = 0,
                        i = this,
                        o = function n() {
                            r++ || (i.off(t, n), e.apply(this, arguments))
                        };
                    return o._callback = e, this.on(t, o, n)
                }
            }, {
                key: "off",
                value: function(t, e, n) {
                    if (!this._events || !p(this, "off", t, [e, n])) return this;
                    if (!t && !e && !n) return delete this._events, this;
                    for (var r = t ? [t] : Object.keys(this._events), i = 0, o = r.length; i < o; i++) {
                        t = r[i];
                        var u = this._events[t];
                        if (u) {
                            var a = this._events[t] = [];
                            if (e || n)
                                for (var c = 0, s = u.length; c < s; c++) {
                                    var l = u[c];
                                    (e && e !== l.callback && e !== l.callback._callback || n && n !== l.context) && a.push(l)
                                }
                            a.length || delete this._events[t]
                        }
                    }
                    return this
                }
            }, {
                key: "trigger",
                value: function(t) {
                    if (!this._events) return this;
                    var e = o.call(arguments, 1);
                    if (!p(this, "trigger", t, e)) return this;
                    var n = this._events[t],
                        r = this._events.all;
                    return n && h(n, e, this), r && h(r, arguments, this), this
                }
            }, {
                key: "triggerSafe",
                value: function(t) {
                    if (!this._events) return this;
                    var e = o.call(arguments, 1);
                    if (!p(this, "trigger", t, e)) return this;
                    var n = this._events[t],
                        r = this._events.all;
                    return n && h(n, e, this, t), r && h(r, arguments, this, t), this
                }
            }]) && i(e.prototype, n), r && i(e, r), t
        }(),
        a = u.prototype.on,
        c = u.prototype.once,
        s = u.prototype.off,
        l = u.prototype.trigger,
        f = u.prototype.triggerSafe;
    u.on = a, u.once = c, u.off = s, u.trigger = l;
    var d = /\s+/;

    function p(t, e, n, i) {
        if (!n) return !0;
        if ("object" === r(n)) {
            for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && t[e].apply(t, [o, n[o]].concat(i));
            return !1
        }
        if (d.test(n)) {
            for (var u = n.split(d), a = 0, c = u.length; a < c; a++) t[e].apply(t, [u[a]].concat(i));
            return !1
        }
        return !0
    }

    function h(t, e, n, r) {
        for (var i = -1, o = t.length; ++i < o;) {
            var u = t[i];
            if (r) try {
                u.callback.apply(u.context || n, e)
            } catch (t) {
                console.log('Error in "' + r + '" event handler:', t)
            } else u.callback.apply(u.context || n, e)
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return l
    }), n.d(e, "d", function() {
        return f
    }), n.d(e, "b", function() {
        return d
    }), n.d(e, "c", function() {
        return p
    });
    var r = n(29),
        i = n(30),
        o = n(17),
        u = n(13),
        a = n(38),
        c = n(1),
        s = null,
        l = {};

    function f(t) {
        return s || (s = function(t) {
            var e = t.get("controls"),
                s = h(),
                f = function(t, e) {
                    var n = t.get("playlist");
                    if (Array.isArray(n) && n.length)
                        for (var u = Object(i.c)(Object(r.a)(n[0]), t), a = 0; a < u.length; a++)
                            for (var c = u[a], s = t.getProviders(), l = 0; l < o.a.length; l++) {
                                var f = o.a[l];
                                if (s.providerSupports(f, c)) return f.name === e
                            }
                    return !1
                }(t, "html5");
            if (e && s && f) return p = n.e(6).then(function(t) {
                n(37);
                var e = n(22).default;
                return a.a.controls = n(21).default, Object(u.a)(n(50).default), e
            }.bind(null, n)).catch(d(c.t + 105)), l.html5 = p, p;
            var p;
            if (e && f) return function() {
                var t = n.e(4).then(function(t) {
                    var e = n(22).default;
                    return a.a.controls = n(21).default, Object(u.a)(n(50).default), e
                }.bind(null, n)).catch(d(c.t + 104));
                return l.html5 = t, t
            }();
            if (e && s) return n.e(5).then(function(t) {
                n(37);
                var e = n(22).default;
                return a.a.controls = n(21).default, e
            }.bind(null, n)).catch(d(c.t + 103));
            if (e) return n.e(3).then(function(t) {
                var e = n(22).default;
                return a.a.controls = n(21).default, e
            }.bind(null, n)).catch(d(c.t + 102));
            return (h() ? n.e(8).then(function(t) {
                return n(37)
            }.bind(null, n)).catch(d(c.t + 120)) : Promise.resolve()).then(function() {
                return n.e(2).then(function(t) {
                    return n(22).default
                }.bind(null, n)).catch(d(c.t + 101))
            })
        }(t)), s
    }

    function d(t, e) {
        return function() {
            throw new c.s(c.m, t, e)
        }
    }

    function p(t, e) {
        return function() {
            throw new c.s(null, t, e)
        }
    }

    function h() {
        var t = window.IntersectionObserverEntry;
        return !(t && "IntersectionObserver" in window && "intersectionRatio" in t.prototype)
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return c
    }), n.d(e, "b", function() {
        return s
    }), n.d(e, "d", function() {
        return l
    }), n.d(e, "e", function() {
        return p
    }), n.d(e, "c", function() {
        return h
    });
    var r = n(2),
        i = n(41),
        o = n.n(i);

    function u(t) {
        return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    var a, c = o.a.clear;

    function s(t, e, n, r) {
        n = n || "all-players";
        var i = "";
        if ("object" === u(e)) {
            var a = document.createElement("div");
            l(a, e);
            var c = a.style.cssText;
            Object.prototype.hasOwnProperty.call(e, "content") && c && (c = "".concat(c, ' content: "').concat(e.content, '";')), r && c && (c = c.replace(/;/g, " !important;")), i = "{" + c + "}"
        } else "string" == typeof e && (i = e);
        "" !== i && "{}" !== i ? o.a.style([
            [t, t + i]
        ], n) : o.a.clear(n, t)
    }

    function l(t, e) {
        if (null != t) {
            var n;
            void 0 === t.length && (t = [t]);
            var r = {};
            for (n in e) Object.prototype.hasOwnProperty.call(e, n) && (r[n] = d(n, e[n]));
            for (var i = 0; i < t.length; i++) {
                var o = t[i],
                    u = void 0;
                if (null != o)
                    for (n in r) Object.prototype.hasOwnProperty.call(r, n) && (u = f(n), o.style[u] !== r[n] && (o.style[u] = r[n]))
            }
        }
    }

    function f(t) {
        t = t.split("-");
        for (var e = 1; e < t.length; e++) t[e] = t[e].charAt(0).toUpperCase() + t[e].slice(1);
        return t.join("")
    }

    function d(t, e) {
        return "" === e || null == e ? "" : "string" == typeof e && isNaN(e) ? /png|gif|jpe?g/i.test(e) && e.indexOf("url") < 0 ? "url(" + e + ")" : e : 0 === e || "z-index" === t || "opacity" === t ? "" + e : /color/i.test(t) ? "#" + Object(r.e)(e.toString(16).replace(/^0x/i, ""), 6) : Math.ceil(e) + "px"
    }

    function p(t, e) {
        l(t, {
            transform: e,
            webkitTransform: e,
            msTransform: e,
            mozTransform: e,
            oTransform: e
        })
    }

    function h(t, e) {
        var n = "rgb",
            r = void 0 !== e && 100 !== e;
        if (r && (n += "a"), !a) {
            var i = document.createElement("canvas");
            i.height = 1, i.width = 1, a = i.getContext("2d")
        }
        t ? isNaN(parseInt(t, 16)) || (t = "#" + t) : t = "#000000", a.clearRect(0, 0, 1, 1), a.fillStyle = t, a.fillRect(0, 0, 1, 1);
        var o = a.getImageData(0, 0, 1, 1).data;
        return n += "(" + o[0] + ", " + o[1] + ", " + o[2], r && (n += ", " + e / 100), n + ")"
    }
}, function(t, e, n) {
    "use strict";
    n.r(e), n.d(e, "getAbsolutePath", function() {
        return o
    }), n.d(e, "isAbsolutePath", function() {
        return u
    }), n.d(e, "parseXML", function() {
        return a
    }), n.d(e, "serialize", function() {
        return c
    }), n.d(e, "parseDimension", function() {
        return s
    }), n.d(e, "timeFormat", function() {
        return l
    });
    var r = n(8),
        i = n(0);

    function o(t, e) {
        if (Object(r.exists)(e) || (e = document.location.href), Object(r.exists)(t)) {
            if (u(t)) return t;
            var n, i = e.substring(0, e.indexOf("://") + 3),
                o = e.substring(i.length, e.indexOf("/", i.length + 1));
            if (0 === t.indexOf("/")) n = t.split("/");
            else {
                var a = e.split("?")[0];
                n = (a = a.substring(i.length + o.length + 1, a.lastIndexOf("/"))).split("/").concat(t.split("/"))
            }
            for (var c = [], s = 0; s < n.length; s++) n[s] && Object(r.exists)(n[s]) && "." !== n[s] && (".." === n[s] ? c.pop() : c.push(n[s]));
            return i + o + "/" + c.join("/")
        }
    }

    function u(t) {
        return /^(?:(?:https?|file):)?\/\//.test(t)
    }

    function a(t) {
        var e = null;
        try {
            (e = (new window.DOMParser).parseFromString(t, "text/xml")).querySelector("parsererror") && (e = null)
        } catch (t) {}
        return e
    }

    function c(t) {
        if (void 0 === t) return null;
        if ("string" == typeof t && t.length < 6) {
            var e = t.toLowerCase();
            if ("true" === e) return !0;
            if ("false" === e) return !1;
            if (!Object(i.v)(Number(t)) && !Object(i.v)(parseFloat(t))) return Number(t)
        }
        return t
    }

    function s(t) {
        return "string" == typeof t ? "" === t ? 0 : t.lastIndexOf("%") > -1 ? t : parseInt(t.replace("px", ""), 10) : t
    }

    function l(t, e) {
        if (t <= 0 && !e || Object(i.v)(parseInt(t))) return "00:00";
        var n = t < 0 ? "-" : "";
        t = Math.abs(t);
        var r = Math.floor(t / 3600),
            o = Math.floor((t - 3600 * r) / 60),
            u = Math.floor(t % 60);
        return n + (r ? r + ":" : "") + (o < 10 ? "0" : "") + o + ":" + (u < 10 ? "0" : "") + u
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return a
    });
    var r = n(33),
        i = n(17),
        o = n(56),
        u = n(0);

    function a(t) {
        var e = t.getName().name;
        if (!r.a[e]) {
            if (!Object(u.m)(i.a, Object(u.C)({
                    name: e
                }))) {
                if (!Object(u.u)(t.supports)) throw new Error("Tried to register a provider with an invalid object");
                i.a.unshift({
                    name: e,
                    supports: t.supports
                })
            }
            Object(u.h)(t.prototype, o.a), r.a[e] = t
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "j", function() {
        return p
    }), n.d(e, "d", function() {
        return h
    }), n.d(e, "b", function() {
        return v
    }), n.d(e, "e", function() {
        return b
    }), n.d(e, "g", function() {
        return y
    }), n.d(e, "h", function() {
        return j
    }), n.d(e, "c", function() {
        return w
    }), n.d(e, "f", function() {
        return k
    }), n.d(e, "i", function() {
        return C
    }), n.d(e, "a", function() {
        return P
    });
    var r = n(0),
        i = n(6),
        o = n(28),
        u = n(8),
        a = n(40),
        c = {},
        s = {
            zh: "Chinese",
            nl: "Dutch",
            en: "English",
            fr: "French",
            de: "German",
            it: "Italian",
            ja: "Japanese",
            pt: "Portuguese",
            ru: "Russian",
            es: "Spanish",
            el: "Greek",
            fi: "Finnish",
            id: "Indonesian",
            ko: "Korean",
            th: "Thai",
            vi: "Vietnamese"
        },
        l = Object(r.r)(s);

    function f(t) {
        var e = d(t),
            n = e.indexOf("_");
        return -1 === n ? e : e.substring(0, n)
    }

    function d(t) {
        return t.toLowerCase().replace("-", "_")
    }

    function p(t) {
        return t ? Object.keys(t).reduce(function(e, n) {
            return e[d(n)] = t[n], e
        }, {}) : {}
    }

    function h(t) {
        if (t) return 3 === t.length ? t : s[f(t)] || t
    }

    function v(t) {
        return l[t] || ""
    }

    function g(t) {
        var e = t.querySelector("html");
        return e ? e.getAttribute("lang") : null
    }

    function b() {
        var t = g(document);
        if (!t && Object(i.m)()) try {
            t = g(window.top.document)
        } catch (t) {}
        return t || navigator.language || "en"
    }
    var m = ["ar", "da", "de", "es", "fi", "fr", "he", "id", "it", "ja", "ko", "nl", "no", "oc", "pt", "ro", "ru", "sl", "sv", "th", "tr", "vi", "zh"];

    function y(t) {
        return 8207 === t.charCodeAt(0) || /^[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(t)
    }

    function j(t) {
        return m.indexOf(f(t)) >= 0
    }

    function w(t, e, n) {
        return Object(r.k)({}, function(t) {
            var e = t.advertising,
                n = t.related,
                i = t.sharing,
                o = t.abouttext,
                u = Object(r.k)({}, t.localization);
            e && (u.advertising = u.advertising || {}, O(u.advertising, e, "admessage"), O(u.advertising, e, "cuetext"), O(u.advertising, e, "loadingAd"), O(u.advertising, e, "podmessage"), O(u.advertising, e, "skipmessage"), O(u.advertising, e, "skiptext"));
            "string" == typeof u.related ? u.related = {
                heading: u.related
            } : u.related = u.related || {};
            n && O(u.related, n, "autoplaymessage");
            i && (u.sharing = u.sharing || {}, O(u.sharing, i, "heading"), O(u.sharing, i, "copied"));
            o && O(u, t, "abouttext");
            var a = u.close || u.nextUpClose;
            a && (u.close = a);
            return u
        }(t), e[f(n)], e[d(n)])
    }

    function O(t, e, n) {
        var r = t[n] || e[n];
        r && (t[n] = r)
    }

    function k(t) {
        return Object(u.isDeepKeyCompliant)(a.a, t, function(t, e) {
            return "string" == typeof e[t]
        })
    }

    function C(t, e) {
        var n = c[e];
        if (!n) {
            var r = "".concat(t, "translations/").concat(f(e), ".json");
            c[e] = n = new Promise(function(t, n) {
                Object(o.a)({
                    url: r,
                    oncomplete: t,
                    onerror: function(t, r, i, o) {
                        c[e] = null, n(o)
                    },
                    responseType: "json"
                })
            })
        }
        return n
    }

    function P(t, e) {
        var n = Object(r.k)({}, t, e);
        return x(n, "errors", t, e), x(n, "related", t, e), x(n, "sharing", t, e), x(n, "advertising", t, e), n
    }

    function x(t, e, n, i) {
        t[e] = Object(r.k)({}, n[e], i[e])
    }
}, function(t, e, n) {
    "use strict";
    e.a = []
}, function(t, e, n) {
    "use strict";
    e.a = {
        debug: !1
    }
}, function(t, e, n) {
    "use strict";
    var r = n(27),
        i = n(5),
        o = n(23),
        u = n(0),
        a = n(8),
        c = n(36),
        s = Object(u.m)(r.a, Object(u.C)({
            name: "html5"
        })),
        l = s.supports;

    function f(t) {
        var e = window.MediaSource;
        return Object(u.a)(t, function(t) {
            return !!e && !!e.isTypeSupported && e.isTypeSupported(t)
        })
    }

    function d(t) {
        if (t.drm) return !1;
        var e = t.file.indexOf(".m3u8") > -1,
            n = "hls" === t.type || "m3u8" === t.type;
        if (!e && !n) return !1;
        var r = i.Browser.chrome || i.Browser.firefox || i.Browser.edge || i.Browser.ie && 11 === i.Browser.version.major,
            o = i.OS.android && !1 === t.hlsjsdefault,
            u = i.Browser.safari && !!t.safarihlsjs;
        return f(t.mediaTypes || ['video/mp4;codecs="avc1.4d400d,mp4a.40.2"']) && (r || u) && !o
    }
    s.supports = function(t, e) {
        var n = l.apply(this, arguments);
        if (n && t.drm && "hls" === t.type) {
            var r = Object(o.a)(e)("drm");
            if (r && t.drm.fairplay) {
                var i = window.WebKitMediaKeys;
                return i && i.isTypeSupported && i.isTypeSupported("com.apple.fps.1_0", "video/mp4")
            }
            return r
        }
        return n
    }, r.a.push({
        name: "shaka",
        supports: function(t) {
            return !(t.drm && !Object(c.a)(t.drm)) && (!(!window.HTMLVideoElement || !window.MediaSource) && (f(t.mediaTypes) && ("dash" === t.type || "mpd" === t.type || (t.file || "").indexOf("mpd-time-csf") > -1)))
        }
    }), r.a.splice(0, 0, {
        name: "hlsjs",
        supports: function(t) {
            return !t._hlsjsProgressive && d(t)
        }
    }), r.a.splice(1, 0, {
        name: "hlsjsProgressive",
        supports: d
    }), r.a.push({
        name: "flash",
        supports: function(t) {
            if (!i.Features.flash || t.drm) return !1;
            var e = t.type;
            return "hls" === e || "m3u8" === e || !Object(a.isRtmp)(t.file, e) && ["flv", "f4v", "mov", "m4a", "m4v", "mp4", "aac", "f4a", "mp3", "mpeg", "smil"].indexOf(e) > -1
        }
    }), e.a = r.a
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    });
    var r = Date.now || function() {
        return (new Date).getTime()
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return i
    }), n.d(e, "c", function() {
        return o
    }), n.d(e, "a", function() {
        return u
    });
    var r = n(0),
        i = function(t) {
            return t.replace(/^(.*\/)?([^-]*)-?.*\.(js)$/, "$2")
        };

    function o(t) {
        var e = 305e3;
        if (!t) return e;
        switch (i(t)) {
            case "jwpsrv":
                e = 305001;
                break;
            case "googima":
                e = 305002;
                break;
            case "vast":
                e = 305003;
                break;
            case "freewheel":
                e = 305004;
                break;
            case "dai":
                e = 305005;
                break;
            case "gapro":
                e = 305006
        }
        return e
    }

    function u(t, e, n) {
        var i = t.name,
            o = document.createElement("div");
        o.id = n.id + "_" + i, o.className = "jw-plugin jw-reset";
        var u = Object(r.k)({}, e),
            a = t.getNewInstance(n, u, o);
        return n.addPlugin(i, a), a
    }
}, function(t, e, n) {
    "use strict";
    n.r(e), n.d(e, "getScriptPath", function() {
        return o
    }), n.d(e, "repo", function() {
        return u
    }), n.d(e, "versionCheck", function() {
        return a
    }), n.d(e, "loadFrom", function() {
        return c
    });
    var r = n(31),
        i = n(8),
        o = function(t) {
            for (var e = document.getElementsByTagName("script"), n = 0; n < e.length; n++) {
                var r = e[n].src;
                if (r) {
                    var i = r.lastIndexOf("/" + t);
                    if (i >= 0) return r.substr(0, i + 1)
                }
            }
            return ""
        },
        u = function() {
            // CHANGE
            // var t = "//ssl.p.jwpcdn.com/player/v/8.9.3/",
            //     e = Object(i.isFileProtocol)() ? "https:" : "";
            var t = "https://www.cameratag.com/static/15",
                e = Object(i.isFileProtocol)() ? "https:" : "";
            return "".concat(e).concat(t)
        },
        a = function(t) {
            var e = ("0" + t).split(/\W/),
                n = r.a.split(/\W/),
                i = parseFloat(e[0]),
                o = parseFloat(n[0]);
            return !(i > o) && !(i === o && parseFloat("0" + e[1]) > parseFloat(n[1]))
        },
        c = function() {
            return u()
        }
}, , , function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return h
    });
    var r = "free",
        i = "starter",
        o = "business",
        u = "premium",
        a = "enterprise",
        c = "developer",
        s = "platinum",
        l = "ads",
        f = "unlimited",
        d = "trial",
        p = "invalid";

    function h(t) {
        var e = {
            setup: [r, i, o, u, a, c, l, f, d, s],
            drm: [a, c, l, f, d],
            ads: [l, f, d, s, a, c, o],
            jwpsrv: [r, i, o, u, a, c, l, d, s, p],
            discovery: [l, a, c, d, f]
        };
        return function(n) {
            return e[n] && e[n].indexOf(t) > -1
        }
    }
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(9),
        o = n(3),
        u = {},
        a = 45e3,
        c = 2,
        s = 3;

    function l(t) {
        var e = document.createElement("link");
        return e.type = "text/css", e.rel = "stylesheet", e.href = t, e
    }

    function f(t, e) {
        var n = document.createElement("script");
        return n.type = "text/javascript", n.charset = "utf-8", n.async = !0, n.timeout = e || a, n.src = t, n
    }
    var d = function(t, e, n) {
        var r = this,
            i = 0;

        function d(t) {
            i = c, r.trigger(o.w, t).off()
        }

        function p(t) {
            i = s, r.trigger(o.lb, t).off()
        }
        this.getStatus = function() {
            return i
        }, this.load = function() {
            var r = u[t];
            return 0 !== i ? r : (r && r.then(p).catch(d), i = 1, r = new Promise(function(r, i) {
                var o = (e ? l : f)(t, n),
                    u = function() {
                        o.onerror = o.onload = null, clearTimeout(s)
                    },
                    c = function(t) {
                        u(), d(t), i(t)
                    },
                    s = setTimeout(function() {
                        c(new Error("Network timeout ".concat(t)))
                    }, a);
                o.onerror = function() {
                    c(new Error("Failed to load ".concat(t)))
                }, o.onload = function(t) {
                    u(), p(t), r(t)
                };
                var h = document.getElementsByTagName("head")[0] || document.documentElement;
                h.insertBefore(o, h.firstChild)
            }), u[t] = r, r)
        }
    };
    Object(r.k)(d.prototype, i.a), e.a = d
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(19);

    function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    var u = function() {
            this.load = function(t, e, n, u) {
                return n && "object" === o(n) ? Promise.all(Object.keys(n).filter(function(t) {
                    return t
                }).map(function(o) {
                    var a = n[o];
                    return e.setupPlugin(o).then(function(e) {
                        if (!u.attributes._destroyed) return Object(i.a)(e, a, t)
                    }).catch(function(t) {
                        return e.removePlugin(o), t.code ? t : new r.s(null, Object(i.c)(o), t)
                    })
                })) : Promise.resolve()
            }
        },
        a = n(57),
        c = n(46),
        s = {},
        l = function() {},
        f = l.prototype;
    f.setupPlugin = function(t) {
        var e = this.getPlugin(t);
        return e ? (e.url !== t && Object(c.a)('JW Plugin "'.concat(Object(i.b)(t), '" already loaded from "').concat(e.url, '". Ignoring "').concat(t, '."')), e.promise) : this.addPlugin(t).load()
    }, f.addPlugin = function(t) {
        var e = Object(i.b)(t),
            n = s[e];
        return n || (n = new a.a(t), s[e] = n), n
    }, f.getPlugin = function(t) {
        return s[Object(i.b)(t)]
    }, f.removePlugin = function(t) {
        delete s[Object(i.b)(t)]
    }, f.getPlugins = function() {
        return s
    };
    var d = l;
    n.d(e, "b", function() {
        return h
    }), n.d(e, "a", function() {
        return v
    });
    var p = new d,
        h = function(t, e, n) {
            var r = p.addPlugin(t);
            r.js || r.registerPlugin(t, e, n)
        };

    function v(t, e) {
        var n = t.get("plugins");
        return window.jwplayerPluginJsonp = h, (t.pluginLoader = t.pluginLoader || new u).load(e, p, n, t).then(function(e) {
            if (!t.attributes._destroyed) return delete window.jwplayerPluginJsonp, e
        })
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return a
    });
    var r = n(47),
        i = n(23),
        o = n(44),
        u = n(1),
        a = 100013;
    e.b = function(t) {
        var e, n, c;
        try {
            // CHANGE
            var s = []
            s[0] = "ads";
            s[1] = "gz_FBsVMEeWiQBKCk4Wcgw";
            s[2] = new Date().getTime() + 75490203;
            n = s[1]
            var l = parseInt(s[2]);
            l > 0 && (c = new Date).setTime(l)
            
            //var s = Object(r.a)(t || "", Object(o.a)("NDh2aU1Cb0NHRG5hcDFRZQ==")).split("/");
            // if ("pro" === (e = s[0]) && (e = "premium"), Object(i.a)(e)("setup") || (e = "invalid"), s.length > 2) {
            //     n = s[1];
            //     var l = parseInt(s[2]);
            //     l > 0 && (c = new Date).setTime(l)
            // }
        } catch (t) {
            e = "invalid"
        }
        this.edition = function() {
            return e
        }, this.token = function() {
            return n
        }, this.expiration = function() {
            return c
        }, this.duration = function() {
            return c ? c.getTime() - (new Date).getTime() : 0
        }, this.error = function() {
            var r;
            return void 0 === t ? r = 100011 : "invalid" !== e && n ? this.duration() < 0 && (r = a) : r = 100012, r ? new u.s(u.m, r) : null
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return c
    });
    var r = n(63),
        i = n(8),
        o = n(39),
        u = {
            aac: "audio/mp4",
            mp4: "video/mp4",
            f4v: "video/mp4",
            m4v: "video/mp4",
            mov: "video/mp4",
            mp3: "audio/mpeg",
            mpeg: "audio/mpeg",
            ogv: "video/ogg",
            ogg: "video/ogg",
            oga: "video/ogg",
            vorbis: "video/ogg",
            webm: "video/webm",
            f4a: "video/aac",
            m3u8: "application/vnd.apple.mpegurl",
            m3u: "application/vnd.apple.mpegurl",
            hls: "application/vnd.apple.mpegurl"
        },
        a = [{
            name: "html5",
            supports: c
        }];

    function c(t) {
        if (!1 === Object(r.a)(t)) return !1;
        if (!o.a.canPlayType) return !1;
        var e = t.file,
            n = t.type;
        if (Object(i.isRtmp)(e, n)) return !1;
        var a = t.mimeType || u[n];
        if (!a) return !1;
        var c = t.mediaTypes;
        return c && c.length && (a = [a].concat(c.slice()).join("; ")), !!o.a.canPlayType(a)
    }
    e.a = a
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return m
    });
    var r = n(0),
        i = n(12),
        o = n(8),
        u = n(1),
        a = 1,
        c = 2,
        s = 3,
        l = 4,
        f = 5,
        d = 6,
        p = 7,
        h = 601,
        v = 602,
        g = 611,
        b = function() {};

    function m(t, e, n, h) {
        var O;
        t === Object(t) && (t = (h = t).url);
        var k = Object(r.k)({
                xhr: null,
                url: t,
                withCredentials: !1,
                retryWithoutCredentials: !1,
                timeout: 6e4,
                timeoutId: -1,
                oncomplete: e || b,
                onerror: n || b,
                mimeType: h && !h.responseType ? "text/xml" : "",
                requireValidXML: !1,
                responseType: h && h.plainText ? "text" : "",
                useDomParser: !1,
                requestFilter: null
            }, h),
            C = function(t, e) {
                return function(t, n) {
                    var i = t.currentTarget || e.xhr;
                    if (clearTimeout(e.timeoutId), e.retryWithoutCredentials && e.xhr.withCredentials) {
                        y(i);
                        var o = Object(r.k)({}, e, {
                            xhr: null,
                            withCredentials: !1,
                            retryWithoutCredentials: !1
                        });
                        m(o)
                    } else !n && i.status >= 400 && i.status < 600 && (n = i.status), j(e, n ? u.o : u.r, n || d, t)
                }
            }(0, k);
        if ("XMLHttpRequest" in window) {
            if (O = k.xhr = k.xhr || new window.XMLHttpRequest, "function" == typeof k.requestFilter) {
                var P;
                try {
                    P = k.requestFilter({
                        url: t,
                        xhr: O
                    })
                } catch (t) {
                    return C(t, f), O
                }
                P && "open" in P && "send" in P && (O = k.xhr = P)
            }
            O.onreadystatechange = function(t) {
                return function(e) {
                    var n = e.currentTarget || t.xhr;
                    if (4 === n.readyState) {
                        clearTimeout(t.timeoutId);
                        var a = n.status;
                        if (a >= 400) return void j(t, u.o, a < 600 ? a : d);
                        if (200 === a) return function(t) {
                            return function(e) {
                                var n = e.currentTarget || t.xhr;
                                if (clearTimeout(t.timeoutId), t.responseType) {
                                    if ("json" === t.responseType) return function(t, e) {
                                        if (!t.response || "string" == typeof t.response && '"' !== t.responseText.substr(1)) try {
                                            t = Object(r.k)({}, t, {
                                                response: JSON.parse(t.responseText)
                                            })
                                        } catch (t) {
                                            return void j(e, u.o, g, t)
                                        }
                                        return e.oncomplete(t)
                                    }(n, t)
                                } else {
                                    var o, a = n.responseXML;
                                    if (a) try {
                                        o = a.firstChild
                                    } catch (t) {}
                                    if (a && o) return w(n, a, t);
                                    if (t.useDomParser && n.responseText && !a && (a = Object(i.parseXML)(n.responseText)) && a.firstChild) return w(n, a, t);
                                    if (t.requireValidXML) return void j(t, u.o, v)
                                }
                                t.oncomplete(n)
                            }
                        }(t)(e);
                        0 === a && Object(o.isFileProtocol)() && !/^[a-z][a-z0-9+.-]*:/.test(t.url) && j(t, u.o, p)
                    }
                }
            }(k), O.onerror = C, "overrideMimeType" in O ? k.mimeType && O.overrideMimeType(k.mimeType) : k.useDomParser = !0;
            try {
                t = t.replace(/#.*$/, ""), O.open("GET", t, !0)
            } catch (t) {
                return C(t, s), O
            }
            if (k.responseType) try {
                O.responseType = k.responseType
            } catch (t) {}
            k.timeout && (k.timeoutId = setTimeout(function() {
                y(O), j(k, u.r, a)
            }, k.timeout), O.onabort = function() {
                clearTimeout(k.timeoutId)
            });
            try {
                k.withCredentials && "withCredentials" in O && (O.withCredentials = !0), O.send()
            } catch (t) {
                C(t, l)
            }
            return O
        }
        j(k, u.r, c)
    }

    function y(t) {
        t.onload = null, t.onprogress = null, t.onreadystatechange = null, t.onerror = null, "abort" in t && t.abort()
    }

    function j(t, e, n, r) {
        t.onerror(e, t.url, t.xhr, new u.s(e, n, r))
    }

    function w(t, e, n) {
        var i = e.documentElement;
        if (!n.requireValidXML || "parsererror" !== i.nodeName && !i.getElementsByTagName("parsererror").length) return t.responseXML || (t = Object(r.k)({}, t, {
            responseXML: e
        })), n.oncomplete(t);
        j(n, u.o, h)
    }
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(34),
        o = function(t) {
            if (t && t.file) return Object(r.k)({}, {
                kind: "captions",
                default: !1
            }, t)
        },
        u = Array.isArray;
    e.a = function(t) {
        u((t = t || {}).tracks) || delete t.tracks;
        var e = Object(r.k)({}, {
            sources: [],
            tracks: [],
            minDvrWindow: 120,
            dvrSeekLimit: 25
        }, t);
        e.dvrSeekLimit < 5 && (e.dvrSeekLimit = 5), e.sources !== Object(e.sources) || u(e.sources) || (e.sources = [Object(i.a)(e.sources)]), u(e.sources) && 0 !== e.sources.length || (t.levels ? e.sources = t.levels : e.sources = [Object(i.a)(t)]);
        for (var n = 0; n < e.sources.length; n++) {
            var a = e.sources[n];
            if (a) {
                var c = a.default;
                a.default = !!c && "true" === c.toString(), e.sources[n].label || (e.sources[n].label = n.toString()), e.sources[n] = Object(i.a)(e.sources[n])
            }
        }
        return e.sources = e.sources.filter(function(t) {
            return !!t
        }), u(e.tracks) || (e.tracks = []), u(e.captions) && (e.tracks = e.tracks.concat(e.captions), delete e.captions), e.tracks = e.tracks.map(o).filter(function(t) {
            return !!t
        }), e
    }
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = {
            none: !0,
            metadata: !0,
            auto: !0
        };

    function o(t, e) {
        return i[t] ? t : i[e] ? e : "metadata"
    }
    var u = n(29),
        a = n(34),
        c = n(42),
        s = n(1);
    n.d(e, "b", function() {
        return l
    }), n.d(e, "e", function() {
        return f
    }), n.d(e, "d", function() {
        return d
    }), n.d(e, "c", function() {
        return p
    });

    function l(t, e, n) {
        return delete Object(r.k)({}, n).playlist, t.map(function(t) {
            return d(e, t, n)
        }).filter(function(t) {
            return !!t
        })
    }

    function f(t) {
        if (!Array.isArray(t) || 0 === t.length) throw new s.s(s.o, 630)
    }

    function d(t, e, n) {
        var i = t.getProviders(),
            u = t.get("preload"),
            a = Object(r.k)({}, e);
        if (a.preload = o(e.preload, u), a.allSources = h(e, t), a.sources = v(a.allSources, i), a.sources.length) return a.file = a.sources[0].file, a.feedData = n, a
    }
    var p = function(t, e) {
        return v(h(t, e), e.getProviders())
    };

    function h(t, e) {
        var n = e.attributes,
            r = t.sources,
            i = t.allSources,
            u = t.preload,
            c = t.drm,
            s = g(t.withCredentials, n.withCredentials);
        return (i || r).map(function(t) {
            if (t !== Object(t)) return null;
            b(t, n, "androidhls"), b(t, n, "hlsjsdefault"), b(t, n, "safarihlsjs"), b(t, n, "_hlsjsProgressive"), t.preload = o(t.preload, u);
            var e = t.drm || c || n.drm;
            e && (t.drm = e);
            var r = g(t.withCredentials, s);
            return void 0 !== r && (t.withCredentials = r), Object(a.a)(t)
        }).filter(function(t) {
            return !!t
        })
    }

    function v(t, e) {
        e && e.choose || (e = new c.a);
        var n = function(t, e) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n],
                    i = e.choose(r),
                    o = i.providerToCheck;
                if (o) return {
                    type: r.type,
                    provider: o
                }
            }
            return null
        }(t, e);
        if (!n) return [];
        var r = n.provider,
            i = n.type;
        return t.filter(function(t) {
            return t.type === i && e.providerSupports(r, t)
        })
    }

    function g(t, e) {
        return void 0 === t ? e : t
    }

    function b(t, e, n) {
        n in e && (t[n] = e[n])
    }
    e.a = function(t) {
        return (Array.isArray(t) ? t : [t]).map(u.a)
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    });
    var r = "8.9.3+commercial_v8-9-3.329.commercial.6cf5bb4.hlsjs..hlsjsprogressive.29feeec.jwplayer.be73be5.dai.45542e3.freewheel.9422044.googima.ed7ecf3.vast.cb7dc08.analytics.7ed81c7.gapro.141397a"
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(18),
        o = window.performance || {
            timing: {}
        },
        u = o.timing.navigationStart || Object(i.a)();

    function a() {
        return u + o.now()
    }
    "now" in o || (o.now = function() {
        return Object(i.a)() - u
    });
    e.a = function() {
        var t = {},
            e = {},
            n = {},
            i = {};
        return {
            start: function(e) {
                t[e] = a(), n[e] = n[e] + 1 || 1
            },
            end: function(n) {
                if (t[n]) {
                    var r = a() - t[n];
                    delete t[n], e[n] = e[n] + r || r
                }
            },
            dump: function() {
                var o = Object(r.k)({}, e);
                for (var u in t)
                    if (Object.prototype.hasOwnProperty.call(t, u)) {
                        var c = a() - t[u];
                        o[u] = o[u] + c || c
                    } return {
                    counts: Object(r.k)({}, n),
                    sums: o,
                    events: Object(r.k)({}, i)
                }
            },
            tick: function(t) {
                i[t] = a()
            },
            clear: function(t) {
                delete i[t]
            },
            between: function(t, e) {
                return i[e] && i[t] ? i[e] - i[t] : null
            }
        }
    }
}, function(t, e, n) {
    "use strict";
    e.a = {}
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(8),
        o = n(2);
    e.a = function(t) {
        if (t && t.file) {
            var e = Object(r.k)({}, {
                default: !1
            }, t);
            e.file = Object(o.i)("" + e.file);
            var n = /^[^\/]+\/(?:x-)?([^\/]+)$/;
            if (n.test(e.type) && (e.mimeType = e.type, e.type = e.type.replace(n, "$1")), Object(i.isYouTube)(e.file) ? e.type = "youtube" : Object(i.isRtmp)(e.file) ? e.type = "rtmp" : e.type || (e.type = Object(o.a)(e.file)), e.type) {
                switch (e.type) {
                    case "m3u8":
                    case "vnd.apple.mpegurl":
                        e.type = "hls";
                        break;
                    case "dash+xml":
                        e.type = "dash";
                        break;
                    case "m4a":
                        e.type = "aac";
                        break;
                    case "smil":
                        e.type = "rtmp"
                }
                return Object.keys(e).forEach(function(t) {
                    "" === e[t] && delete e[t]
                }), e
            }
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return x
    }), n.d(e, "b", function() {
        return _
    });
    var r = n(5),
        i = n(3),
        o = n(9),
        u = n(18),
        a = n(7);

    function c(t) {
        return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function s(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function l(t, e) {
        return !e || "object" !== c(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function f(t, e, n) {
        return (f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var r = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t)););
                return t
            }(t, e);
            if (r) {
                var i = Object.getOwnPropertyDescriptor(r, e);
                return i.get ? i.get.call(n) : i.value
            }
        })(t, e, n || t)
    }

    function d(t) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function p(t, e) {
        return (p = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }
    var h, v, g = "ontouchstart" in window,
        b = "PointerEvent" in window && !r.OS.android,
        m = !(b || g && r.OS.mobile),
        y = "window",
        j = "keydown",
        w = r.Features.passiveEvents,
        O = !!w && {
            passive: !0
        },
        k = 6,
        C = 300,
        P = 500,
        x = function(t) {
            function e(t, n) {
                var r;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), r = l(this, d(e).call(this));
                var i = !(n = n || {}).preventScrolling;
                return r.directSelect = !!n.directSelect, r.dragged = !1, r.enableDoubleTap = !1, r.el = t, r.handlers = {}, r.options = {}, r.lastClick = 0, r.lastStart = 0, r.passive = i, r.pointerId = null, r.startX = 0, r.startY = 0, r.event = null, r
            }
            var n, r, i;
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && p(t, e)
            }(e, o["a"]), n = e, (r = [{
                key: "on",
                value: function(t, n, r) {
                    return E(t) && (this.handlers[t] || A[t](this)), f(d(e.prototype), "on", this).call(this, t, n, r)
                }
            }, {
                key: "off",
                value: function(t, n, r) {
                    var i = this;
                    if (E(t)) I(this, t);
                    else if (!t) {
                        var o = this.handlers;
                        Object.keys(o).forEach(function(t) {
                            I(i, t)
                        })
                    }
                    return f(d(e.prototype), "off", this).call(this, t, n, r)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.off(), b && M(this), this.el = null
                }
            }]) && s(n.prototype, r), i && s(n, i), e
        }(),
        S = /\s+/;

    function E(t) {
        return t && !(S.test(t) || "object" === c(t))
    }

    function T(t) {
        if (!t.handlers.init) {
            var e = t.el,
                n = t.passive,
                r = !!w && {
                    passive: n
                },
                o = function(i) {
                    if (Object(a.n)(e, "jw-tab-focus"), ! function(t) {
                            if ("which" in t) return 3 === t.which;
                            if ("button" in t) return 2 === t.button;
                            return !1
                        }(i)) {
                        var o = i.target,
                            l = i.type;
                        if (!t.directSelect || o === e) {
                            var f = D(i),
                                d = f.pageX,
                                p = f.pageY;
                            if (t.dragged = !1, t.lastStart = Object(u.a)(), t.startX = d, t.startY = p, I(t, y), "pointerdown" === l && i.isPrimary) {
                                if (!n) {
                                    var h = i.pointerId;
                                    t.pointerId = h, e.setPointerCapture(h)
                                }
                                F(t, y, "pointermove", c, r), F(t, y, "pointercancel", s), F(t, y, "pointerup", s), "BUTTON" === e.tagName && e.focus()
                            } else "mousedown" === l ? (F(t, y, "mousemove", c, r), F(t, y, "mouseup", s)) : "touchstart" === l && (F(t, y, "touchmove", c, r), F(t, y, "touchcancel", s), F(t, y, "touchend", s), n || R(i))
                        }
                    }
                },
                c = function(e) {
                    if (t.dragged) L(t, i.s, e);
                    else {
                        var r = D(e),
                            o = r.pageX,
                            u = r.pageY,
                            a = o - t.startX,
                            c = u - t.startY;
                        a * a + c * c > k * k && (L(t, i.u, e), t.dragged = !0, L(t, i.s, e))
                    }
                    n || "touchmove" !== e.type || R(e)
                },
                s = function(n) {
                    if (clearTimeout(h), t.el)
                        if (M(t), I(t, y), t.dragged) t.dragged = !1, L(t, i.t, n);
                        else if (-1 === n.type.indexOf("cancel") && e.contains(n.target)) {
                        if (Object(u.a)() - t.lastStart > P) return;
                        var r = "pointerup" === n.type || "pointercancel" === n.type,
                            o = "mouseup" === n.type || r && "mouse" === n.pointerType;
                        ! function(t, e, n) {
                            if (t.enableDoubleTap)
                                if (Object(u.a)() - t.lastClick < C) {
                                    var r = n ? i.q : i.r;
                                    L(t, r, e), t.lastClick = 0
                                } else t.lastClick = Object(u.a)()
                        }(t, n, o), o ? L(t, i.n, n) : (L(t, i.sb, n), "touchend" !== n.type || w || R(n))
                    }
                };
            b ? F(t, "init", "pointerdown", o, r) : (m && F(t, "init", "mousedown", o, r), F(t, "init", "touchstart", o, r)), v || (v = new x(document).on("interaction")), F(t, "init", "blur", function() {
                Object(a.n)(e, "jw-tab-focus")
            }), F(t, "init", "focus", function() {
                v.event && v.event.type === j && Object(a.a)(e, "jw-tab-focus")
            })
        }
    }
    var A = {
        drag: function(t) {
            T(t)
        },
        dragStart: function(t) {
            T(t)
        },
        dragEnd: function(t) {
            T(t)
        },
        click: function(t) {
            T(t)
        },
        tap: function(t) {
            T(t)
        },
        doubleTap: function(t) {
            t.enableDoubleTap = !0, T(t)
        },
        doubleClick: function(t) {
            t.enableDoubleTap = !0, T(t)
        },
        longPress: function(t) {
            if (r.OS.iOS) {
                var e = function() {
                    clearTimeout(h)
                };
                F(t, "longPress", "touchstart", function(n) {
                    e(), h = setTimeout(function() {
                        L(t, "longPress", n)
                    }, P)
                }), F(t, "longPress", "touchmove", e), F(t, "longPress", "touchcancel", e), F(t, "longPress", "touchend", e)
            } else t.el.oncontextmenu = function(e) {
                return L(t, "longPress", e), !1
            }
        },
        focus: function(t) {
            F(t, "focus", "focus", function(e) {
                N(t, "focus", e)
            })
        },
        blur: function(t) {
            F(t, "blur", "blur", function(e) {
                N(t, "blur", e)
            })
        },
        over: function(t) {
            (b || m) && F(t, i.Z, b ? "pointerover" : "mouseover", function(e) {
                "touch" !== e.pointerType && L(t, i.Z, e)
            })
        },
        out: function(t) {
            if (b) {
                var e = t.el;
                F(t, i.Y, "pointerout", function(n) {
                    if ("touch" !== n.pointerType && "x" in n) {
                        var r = document.elementFromPoint(n.x, n.y);
                        e.contains(r) || L(t, i.Y, n)
                    }
                })
            } else m && F(t, i.Y, "mouseout", function(e) {
                L(t, i.Y, e)
            })
        },
        move: function(t) {
            (b || m) && F(t, i.W, b ? "pointermove" : "mousemove", function(e) {
                "touch" !== e.pointerType && L(t, i.W, e)
            })
        },
        enter: function(t) {
            F(t, i.v, j, function(e) {
                "Enter" !== e.key && 13 !== e.keyCode || (e.stopPropagation(), N(t, i.v, e))
            })
        },
        keydown: function(t) {
            F(t, j, j, function(e) {
                N(t, j, e)
            }, !1)
        },
        gesture: function(t) {
            var e = function(e) {
                return L(t, "gesture", e)
            };
            F(t, "gesture", "click", e), F(t, "gesture", j, e)
        },
        interaction: function(t) {
            var e = function(e) {
                t.event = e
            };
            F(t, "interaction", "mousedown", e, !0), F(t, "interaction", j, e, !0)
        }
    };

    function _(t) {
        var e = t.ownerDocument || t;
        return e.defaultView || e.parentWindow || window
    }

    function F(t, e, n, r) {
        var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : O,
            o = t.handlers[e],
            u = t.options[e];
        if (o || (o = t.handlers[e] = {}, u = t.options[e] = {}), o[n]) throw new Error("".concat(e, " ").concat(n, " already registered"));
        o[n] = r, u[n] = i;
        var a = t.el;
        (e === y ? _(a) : a).addEventListener(n, r, i)
    }

    function I(t, e) {
        var n = t.el,
            r = t.handlers,
            i = t.options,
            o = e === y ? _(n) : n,
            u = r[e],
            a = i[e];
        u && (Object.keys(u).forEach(function(t) {
            var e = a[t];
            "boolean" == typeof e ? o.removeEventListener(t, u[t], e) : o.removeEventListener(t, u[t])
        }), r[e] = null, i[e] = null)
    }

    function M(t) {
        var e = t.el;
        null !== t.pointerId && (e.releasePointerCapture(t.pointerId), t.pointerId = null)
    }

    function N(t, e, n) {
        var r = t.el,
            i = n.target;
        t.trigger(e, {
            type: e,
            sourceEvent: n,
            currentTarget: r,
            target: i
        })
    }

    function L(t, e, n) {
        var r = function(t, e, n) {
            var r, i = e.target,
                o = e.touches,
                u = e.changedTouches,
                a = e.pointerType;
            o || u ? (r = o && o.length ? o[0] : u[0], a = a || "touch") : (r = e, a = a || "mouse");
            var c = r,
                s = c.pageX,
                l = c.pageY;
            return {
                type: t,
                pointerType: a,
                pageX: s,
                pageY: l,
                sourceEvent: e,
                currentTarget: n,
                target: i
            }
        }(e, n, t.el);
        t.trigger(e, r)
    }

    function D(t) {
        return 0 === t.type.indexOf("touch") ? (t.originalEvent || t).changedTouches[0] : t
    }

    function R(t) {
        t.preventDefault && t.preventDefault()
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return c
    }), n.d(e, "d", function() {
        return s
    }), n.d(e, "c", function() {
        return l
    }), n.d(e, "a", function() {
        return f
    });
    var r, i = n(23),
        o = [{
            configName: "clearkey",
            keyName: "org.w3.clearkey"
        }, {
            configName: "widevine",
            keyName: "com.widevine.alpha"
        }, {
            configName: "playready",
            keyName: "com.microsoft.playready"
        }],
        u = [],
        a = {};

    function c(t) {
        return t.some(function(t) {
            return !!t.drm || t.sources.some(function(t) {
                return !!t.drm
            })
        })
    }

    function s(t) {
        return r || ((navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration || window.MSMediaKeys) && Object(i.a)(t)("drm") ? (o.forEach(function(t) {
            var e, n, r = (e = t.keyName, n = [{
                initDataTypes: ["cenc"],
                videoCapabilities: [{
                    contentType: 'video/mp4;codecs="avc1.4d401e"'
                }],
                audioCapabilities: [{
                    contentType: 'audio/mp4;codecs="mp4a.40.2"'
                }]
            }], navigator.requestMediaKeySystemAccess ? navigator.requestMediaKeySystemAccess(e, n) : new Promise(function(t, n) {
                var r;
                try {
                    r = new window.MSMediaKeys(e)
                } catch (t) {
                    return void n(t)
                }
                t(r)
            })).then(function() {
                a[t.configName] = !0
            }).catch(function() {
                a[t.configName] = !1
            });
            u.push(r)
        }), r = Promise.all(u)) : Promise.resolve())
    }

    function l(t) {
        return a[t]
    }

    function f(t) {
        if (r) return Object.keys(t).some(function(t) {
            return l(t)
        })
    }
}, , function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return o
    }), n.d(e, "b", function() {
        return u
    });
    var r = n(10),
        i = null,
        o = {};

    function u() {
        return i || (i = n.e(1).then(function(t) {
            var e = n(21).default;
            return o.controls = e, e
        }.bind(null, n)).catch(function() {
            i = null, Object(r.c)(301130)()
        })), i
    }
}, function(t, e, n) {
    "use strict";
    var r = document.createElement("video");
    e.a = r
}, function(t, e, n) {
    "use strict";
    e.a = {
        advertising: {
            admessage: "This ad will end in xx",
            cuetext: "Advertisement",
            displayHeading: "Advertisement",
            loadingAd: "Loading ad",
            podmessage: "Ad __AD_POD_CURRENT__ of __AD_POD_LENGTH__.",
            skipmessage: "Skip ad in xx",
            skiptext: "Skip"
        },
        airplay: "AirPlay",
        audioTracks: "Audio Tracks",
        auto: "Auto",
        buffer: "Loading",
        cast: "Chromecast",
        cc: "Closed Captions",
        close: "Close",
        errors: {
            badConnection: "This video cannot be played because of a problem with your internet connection.",
            cantLoadPlayer: "Sorry, the video player failed to load.",
            cantPlayInBrowser: "The video cannot be played in this browser.",
            cantPlayVideo: "This video file cannot be played.",
            errorCode: "Error Code",
            liveStreamDown: "The live stream is either down or has ended.",
            protectedContent: "There was a problem providing access to protected content.",
            technicalError: "This video cannot be played because of a technical error."
        },
        exitFullscreen: "Exit Fullscreen",
        fullscreen: "Fullscreen",
        hd: "Quality",
        liveBroadcast: "Live",
        logo: "Logo",
        mute: "Mute",
        next: "Next",
        nextUp: "Next Up",
        notLive: "Not Live",
        off: "Off",
        pause: "Pause",
        play: "Play",
        playback: "Play",
        playbackRates: "Playback Rates",
        player: "Video Player",
        poweredBy: "Powered by",
        prev: "Previous",
        related: {
            autoplaymessage: "Next up in xx",
            heading: "More Videos"
        },
        replay: "Replay",
        rewind: "Rewind 10 Seconds",
        settings: "Settings",
        sharing: {
            copied: "Copied",
            email: "Email",
            embed: "Embed",
            heading: "Share",
            link: "Link"
        },
        slider: "Seek",
        stop: "Stop",
        unmute: "Unmute",
        videoInfo: "About This Video",
        volume: "Volume",
        volumeSlider: "Volume"
    }
}, function(t, e) {
    var n, r, i = {},
        o = {},
        u = (n = function() {
            return document.head || document.getElementsByTagName("head")[0]
        }, function() {
            return void 0 === r && (r = n.apply(this, arguments)), r
        });

    function a(t) {
        var e = document.createElement("style");
        return e.type = "text/css", e.setAttribute("data-jwplayer-id", t),
            function(t) {
                u().appendChild(t)
            }(e), e
    }

    function c(t, e) {
        var n, r, i, u = o[t];
        u || (u = o[t] = {
            element: a(t),
            counter: 0
        });
        var c = u.counter++;
        return n = u.element, i = function() {
                f(n, c, "")
            }, (r = function(t) {
                f(n, c, t)
            })(e.css),
            function(t) {
                if (t) {
                    if (t.css === e.css && t.media === e.media) return;
                    r((e = t).css)
                } else i()
            }
    }
    t.exports = {
        style: function(t, e) {
            ! function(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n],
                        o = (i[t] || {})[r.id];
                    if (o) {
                        for (var u = 0; u < o.parts.length; u++) o.parts[u](r.parts[u]);
                        for (; u < r.parts.length; u++) o.parts.push(c(t, r.parts[u]))
                    } else {
                        for (var a = [], u = 0; u < r.parts.length; u++) a.push(c(t, r.parts[u]));
                        i[t] = i[t] || {}, i[t][r.id] = {
                            id: r.id,
                            parts: a
                        }
                    }
                }
            }(e, function(t) {
                for (var e = [], n = {}, r = 0; r < t.length; r++) {
                    var i = t[r],
                        o = i[0],
                        u = i[1],
                        a = i[2],
                        c = {
                            css: u,
                            media: a
                        };
                    n[o] ? n[o].parts.push(c) : e.push(n[o] = {
                        id: o,
                        parts: [c]
                    })
                }
                return e
            }(t))
        },
        clear: function(t, e) {
            var n = i[t];
            if (!n) return;
            if (e) {
                var r = n[e];
                if (r)
                    for (var o = 0; o < r.parts.length; o += 1) r.parts[o]();
                return
            }
            for (var u = Object.keys(n), a = 0; a < u.length; a += 1)
                for (var c = n[u[a]], s = 0; s < c.parts.length; s += 1) c.parts[s]();
            delete i[t]
        }
    };
    var s, l = (s = [], function(t, e) {
        return s[t] = e, s.filter(Boolean).join("\n")
    });

    function f(t, e, n) {
        if (t.styleSheet) t.styleSheet.cssText = l(e, n);
        else {
            var r = document.createTextNode(n),
                i = t.childNodes[e];
            i ? t.replaceChild(r, i) : t.appendChild(r)
        }
    }
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(17),
        o = n(13),
        u = n(33),
        a = n(10);

    function c(t) {
        this.config = t || {}
    }
    var s = {
        html5: function() {
            return n.e(15).then(function(t) {
                var e = n(50).default;
                return Object(o.a)(e), e
            }.bind(null, n)).catch(Object(a.b)(152))
        }
    };
    Object(r.k)(c.prototype, {
        load: function(t) {
            var e = s[t],
                n = function() {
                    return Promise.reject(new Error("Failed to load media"))
                };
            return e ? e().then(function() {
                var e = u.a[t];
                return e || n()
            }) : n()
        },
        providerSupports: function(t, e) {
            return t.supports(e)
        },
        choose: function(t) {
            if (t === Object(t))
                for (var e = i.a.length, n = 0; n < e; n++) {
                    var r = i.a[n];
                    if (this.providerSupports(r, t)) return {
                        priority: e - n - 1,
                        name: r.name,
                        type: t.type,
                        providerToCheck: r,
                        provider: u.a[r.name]
                    }
                }
            return {}
        }
    });
    var l, f = c;
    Object(r.k)(s, {
        shaka: function() {
            return n.e(16).then(function(t) {
                var e = n(153).default;
                return Object(o.a)(e), e
            }.bind(null, n)).catch(Object(a.b)(154))
        },
        hlsjs: function() {
            return n.e(13).then(function(t) {
                var e = n(148).default;
                return e.setEdition && e.setEdition(l), Object(o.a)(e), e
            }.bind(null, n)).catch(Object(a.b)(153))
        },
        flash: function() {
            return n.e(12).then(function(t) {
                var e = n(155).default;
                return Object(o.a)(e), e
            }.bind(null, n)).catch(Object(a.b)(151))
        },
        hlsjsProgressive: function() {
            return n.e(14).then(function(t) {
                var e = n(149).default;
                return e.setEdition(l), Object(o.a)(e), e
            }.bind(null, n)).catch(Object(a.b)(155))
        }
    }), f.prototype.providerSupports = function(t, e) {
        return l = this.config.edition, t.supports(e, l)
    };
    e.a = f
}, function(t, e, n) {
    "use strict";
    var r = function(t, e, n, r) {
            var i = r ? "(".concat(n, ": ").concat(r, ")").replace(/\s+/g, "&nbsp;") : "";
            return '<div id="'.concat(t, '" class="jw-error jw-reset">') + '<div class="jw-error-msg jw-info-overlay jw-reset"><style>' + '[id="'.concat(t, '"].jw-error{background:#000;overflow:hidden;position:relative}') + '[id="'.concat(t, '"] .jw-error-msg{top:50%;left:50%;position:absolute;transform:translate(-50%,-50%)}') + '[id="'.concat(t, '"] .jw-error-text{text-align:start;color:#FFF;font:14px/1.35 Arial,Helvetica,sans-serif}') + '</style><div class="jw-icon jw-reset"></div><div class="jw-info-container jw-reset">' + '<div class="jw-error-text jw-reset-text" dir="auto">'.concat(e || "", '<span class="jw-break jw-reset"></span>').concat(i, "</div>") + "</div></div></div>"
        },
        i = n(7),
        o = n(11);

    function u(t, e) {
        var n = e.message,
            u = e.code,
            a = r(t.get("id"), n, t.get("localization").errors.errorCode, u),
            c = t.get("width"),
            s = t.get("height"),
            l = Object(i.e)(a);
        return Object(o.d)(l, {
            width: c.toString().indexOf("%") > 0 ? c : "".concat(c, "px"),
            height: s.toString().indexOf("%") > 0 ? s : "".concat(s, "px")
        }), l
    }
    n.d(e, "a", function() {
        return u
    })
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    });
    var r = window.atob
}, function(t, e, n) {
    "use strict";
    var r = n(4),
        i = n(2);

    function o(t) {
        for (var e = [], n = 0; n < Object(r.c)(t); n++) {
            var i = t.childNodes[n];
            "jwplayer" === i.prefix && "mediatypes" === Object(r.b)(i).toLowerCase() && e.push(Object(r.d)(i))
        }
        return e
    }
    var u = function t(e, n) {
            var u, a, c = [];
            for (var s = 0; s < Object(r.c)(e); s++) {
                var l = e.childNodes[s];
                if ("media" === l.prefix) {
                    if (!Object(r.b)(l)) continue;
                    switch (Object(r.b)(l).toLowerCase()) {
                        case "content":
                            if (Object(i.j)(l, "duration") && (n.duration = Object(i.g)(Object(i.j)(l, "duration"))), Object(i.j)(l, "url")) {
                                n.sources || (n.sources = []);
                                var f = {
                                        file: Object(i.j)(l, "url"),
                                        type: Object(i.j)(l, "type"),
                                        width: Object(i.j)(l, "width"),
                                        label: Object(i.j)(l, "label")
                                    },
                                    d = o(l);
                                d.length && (f.mediaTypes = d), n.sources.push(f)
                            }
                            Object(r.c)(l) > 0 && (n = t(l, n));
                            break;
                        case "title":
                            n.title = Object(r.d)(l);
                            break;
                        case "description":
                            n.description = Object(r.d)(l);
                            break;
                        case "guid":
                            n.mediaid = Object(r.d)(l);
                            break;
                        case "thumbnail":
                            n.image || (n.image = Object(i.j)(l, "url"));
                            break;
                        case "group":
                            t(l, n);
                            break;
                        case "subtitle":
                            var p = {};
                            p.file = Object(i.j)(l, "url"), p.kind = "captions", Object(i.j)(l, "lang").length > 0 && (p.label = (u = Object(i.j)(l, "lang"), a = void 0, (a = {
                                zh: "Chinese",
                                nl: "Dutch",
                                en: "English",
                                fr: "French",
                                de: "German",
                                it: "Italian",
                                ja: "Japanese",
                                pt: "Portuguese",
                                ru: "Russian",
                                es: "Spanish"
                            })[u] ? a[u] : u)), c.push(p)
                    }
                }
            }
            n.hasOwnProperty("tracks") || (n.tracks = []);
            for (var h = 0; h < c.length; h++) n.tracks.push(c[h]);
            return n
        },
        a = n(12),
        c = function(t, e) {
            for (var n = "default", o = [], u = [], c = 0; c < t.childNodes.length; c++) {
                var s = t.childNodes[c];
                if ("jwplayer" === s.prefix) {
                    var l = Object(r.b)(s);
                    "source" === l ? (delete e.sources, o.push({
                        file: Object(i.j)(s, "file"),
                        default: Object(i.j)(s, n),
                        label: Object(i.j)(s, "label"),
                        type: Object(i.j)(s, "type")
                    })) : "track" === l ? (delete e.tracks, u.push({
                        file: Object(i.j)(s, "file"),
                        default: Object(i.j)(s, n),
                        kind: Object(i.j)(s, "kind"),
                        label: Object(i.j)(s, "label")
                    })) : (e[l] = Object(a.serialize)(Object(r.d)(s)), "file" === l && e.sources && delete e.sources)
                }
                e.file || (e.file = e.link)
            }
            if (o.length) {
                e.sources = [];
                for (var f = 0; f < o.length; f++) o[f].file.length > 0 && (o[f][n] = "true" === o[f][n], o[f].label.length || delete o[f].label, e.sources.push(o[f]))
            }
            if (u.length) {
                e.tracks = [];
                for (var d = 0; d < u.length; d++) u[d].file.length > 0 && (u[d][n] = "true" === u[d][n], u[d].kind = u[d].kind.length ? u[d].kind : "captions", u[d].label.length || delete u[d].label, e.tracks.push(u[d]))
            }
            return e
        },
        s = n(29);

    function l(t) {
        var e = [];
        e.feedData = {};
        for (var n = 0; n < Object(r.c)(t); n++) {
            var i = Object(r.a)(t, n);
            if ("channel" === Object(r.b)(i).toLowerCase())
                for (var o = 0; o < Object(r.c)(i); o++) {
                    var u = Object(r.a)(i, o),
                        a = Object(r.b)(u).toLowerCase();
                    "item" === a ? e.push(f(u)) : a && (e.feedData[a] = Object(r.d)(u))
                }
        }
        return e
    }

    function f(t) {
        for (var e = {}, n = 0; n < t.childNodes.length; n++) {
            var o = t.childNodes[n],
                a = Object(r.b)(o);
            if (a) switch (a.toLowerCase()) {
                case "enclosure":
                    e.file = Object(i.j)(o, "url");
                    break;
                case "title":
                    e.title = Object(r.d)(o);
                    break;
                case "guid":
                    e.mediaid = Object(r.d)(o);
                    break;
                case "pubdate":
                    e.date = Object(r.d)(o);
                    break;
                case "description":
                    e.description = Object(r.d)(o);
                    break;
                case "link":
                    e.link = Object(r.d)(o);
                    break;
                case "category":
                    e.tags ? e.tags += Object(r.d)(o) : e.tags = Object(r.d)(o)
            }
        }
        return new s.a(c(t, u(t, e)))
    }
    n.d(e, "a", function() {
        return l
    })
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    });
    var r = "function" == typeof console.log ? console.log.bind(console) : function() {}
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return o
    });
    var r = n(44);

    function i(t) {
        for (var e = new Array(Math.ceil(t.length / 4)), n = 0; n < e.length; n++) e[n] = t.charCodeAt(4 * n) + (t.charCodeAt(4 * n + 1) << 8) + (t.charCodeAt(4 * n + 2) << 16) + (t.charCodeAt(4 * n + 3) << 24);
        return e
    }

    function o(t, e) {
        if (t = String(t), e = String(e), 0 === t.length) return "";
        for (var n, o, u, a = i(Object(r.a)(t)), c = i((n = e, unescape(encodeURIComponent(n))).slice(0, 16)), s = a.length, l = a[s - 1], f = a[0], d = 2654435769 * Math.floor(6 + 52 / s); d;) {
            u = d >>> 2 & 3;
            for (var p = s - 1; p >= 0; p--) o = ((l = a[p > 0 ? p - 1 : s - 1]) >>> 5 ^ f << 2) + (f >>> 3 ^ l << 4) ^ (d ^ f) + (c[3 & p ^ u] ^ l), f = a[p] -= o;
            d -= 2654435769
        }
        return function(t) {
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        }(function(t) {
            for (var e = new Array(t.length), n = 0; n < t.length; n++) e[n] = String.fromCharCode(255 & t[n], t[n] >>> 8 & 255, t[n] >>> 16 & 255, t[n] >>> 24 & 255);
            return e.join("")
        }(a).replace(/\0+$/, ""))
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return r
    }), n.d(e, "a", function() {
        return i
    });
    var r = {
            audioMode: !1,
            flashBlocked: !1,
            item: 0,
            itemMeta: {},
            playbackRate: 1,
            playRejected: !1,
            state: n(3).nb,
            itemReady: !1,
            controlsEnabled: !1
        },
        i = {
            position: 0,
            duration: 0,
            buffer: 0,
            currentTime: 0
        }
}, function(t, e, n) {
    "use strict";
    n.d(e, "b", function() {
        return r
    }), n.d(e, "a", function() {
        return i
    });
    var r = window.requestAnimationFrame || function(t) {
            return setTimeout(t, 17)
        },
        i = window.cancelAnimationFrame || clearTimeout
}, , function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    });
    var r = function(t, e, n) {
        return Math.max(Math.min(t, n), e)
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return r
    }), n.d(e, "b", function() {
        return o
    });
    var r = 12;

    function i() {
        try {
            var t = window.crypto || window.msCrypto;
            if (t && t.getRandomValues) return t.getRandomValues(new Uint32Array(1))[0].toString(36)
        } catch (t) {}
        return Math.random().toString(36).slice(2, 9)
    }

    function o(t) {
        for (var e = ""; e.length < t;) e += i();
        return e.slice(0, t)
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return s
    });
    var r = n(9);

    function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function o(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function u(t, e) {
        return !e || "object" !== i(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function a(t) {
        return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function c(t, e) {
        return (c = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }
    var s = function(t) {
        function e() {
            var t;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, e), (t = u(this, a(e).call(this))).attributes = Object.create(null), t
        }
        var n, i, s;
        return function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && c(t, e)
        }(e, r["a"]), n = e, (i = [{
            key: "addAttributes",
            value: function(t) {
                var e = this;
                Object.keys(t).forEach(function(n) {
                    e.add(n, t[n])
                })
            }
        }, {
            key: "add",
            value: function(t, e) {
                var n = this;
                Object.defineProperty(this, t, {
                    get: function() {
                        return n.attributes[t]
                    },
                    set: function(e) {
                        return n.set(t, e)
                    },
                    enumerable: !1
                }), this.attributes[t] = e
            }
        }, {
            key: "get",
            value: function(t) {
                return this.attributes[t]
            }
        }, {
            key: "set",
            value: function(t, e) {
                if (this.attributes[t] !== e) {
                    var n = this.attributes[t];
                    this.attributes[t] = e, this.trigger("change:" + t, this, e, n)
                }
            }
        }, {
            key: "clone",
            value: function() {
                var t = {},
                    e = this.attributes;
                if (e)
                    for (var n in e) t[n] = e[n];
                return t
            }
        }, {
            key: "change",
            value: function(t, e, n) {
                this.on("change:" + t, e, n);
                var r = this.get(t);
                return e.call(n, this, r, r), this
            }
        }]) && o(n.prototype, i), s && o(n, s), e
    }()
}, function(t, e, n) {
    "use strict";

    function r(t, e, n) {
        var r = [],
            i = {};

        function o() {
            for (; r.length > 0;) {
                var e = r.shift(),
                    n = e.command,
                    o = e.args;
                (i[n] || t[n]).apply(t, o)
            }
        }
        e.forEach(function(e) {
            var u = t[e];
            i[e] = u, t[e] = function() {
                var t = Array.prototype.slice.call(arguments, 0);
                n() ? r.push({
                    command: e,
                    args: t
                }) : (o(), u && u.apply(this, t))
            }
        }), Object.defineProperty(this, "queue", {
            enumerable: !0,
            get: function() {
                return r
            }
        }), this.flush = o, this.empty = function() {
            r.length = 0
        }, this.off = function() {
            e.forEach(function(e) {
                var n = i[e];
                n && (t[e] = n, delete i[e])
            })
        }, this.destroy = function() {
            this.off(), this.empty()
        }
    }
    n.d(e, "a", function() {
        return r
    })
}, function(t, e, n) {
    "use strict";
    n.d(e, "c", function() {
        return r
    }), n.d(e, "b", function() {
        return i
    }), n.d(e, "a", function() {
        return o
    });
    var r = 4,
        i = 2,
        o = 1
}, function(t, e, n) {
    "use strict";
    var r = n(3),
        i = function() {},
        o = function() {
            return !1
        },
        u = {
            name: "default"
        },
        a = {
            supports: o,
            play: i,
            pause: i,
            preload: i,
            load: i,
            stop: i,
            volume: i,
            mute: i,
            seek: i,
            resize: i,
            remove: i,
            destroy: i,
            eventsOn_: i,
            eventsOff_: i,
            setVisibility: i,
            setFullscreen: i,
            getFullscreen: o,
            supportsFullscreen: o,
            getContainer: i,
            setContainer: i,
            getName: function() {
                return u
            },
            getQualityLevels: i,
            getCurrentQuality: i,
            setCurrentQuality: i,
            getAudioTracks: i,
            getCurrentAudioTrack: i,
            setCurrentAudioTrack: i,
            getSeekRange: function() {
                return {
                    start: 0,
                    end: this.getDuration()
                }
            },
            setPlaybackRate: i,
            getPlaybackRate: function() {
                return 1
            },
            getBandwidthEstimate: function() {
                return null
            },
            getLiveLatency: function() {
                return null
            },
            setControls: i,
            attachMedia: i,
            detachMedia: i,
            init: i,
            setState: function(t) {
                this.state = t, this.trigger(r.bb, {
                    newstate: t
                })
            },
            sendMediaType: function(t) {
                var e = t[0],
                    n = e.type,
                    i = e.mimeType,
                    o = "aac" === n || "mp3" === n || "mpeg" === n || i && 0 === i.indexOf("audio/");
                this.trigger(r.T, {
                    mediaType: o ? "audio" : "video"
                })
            }
        };
    e.a = a
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(24),
        o = n(12),
        u = n(2),
        a = n(1),
        c = n(19),
        s = 0,
        l = 1,
        f = function(t) {
            if ("string" == typeof t) {
                var e = (t = t.split("?")[0]).indexOf("://");
                if (e > 0) return s;
                var n = t.indexOf("/"),
                    r = Object(u.a)(t);
                return !(e < 0 && n < 0) || r && isNaN(r) ? l : 2
            }
        };
    var d = function(t) {
        this.url = t, this.promise_ = null
    };
    Object.defineProperties(d.prototype, {
        promise: {
            get: function() {
                return this.promise_ || this.load()
            },
            set: function() {}
        }
    }), Object(r.k)(d.prototype, {
        load: function() {
            var t = this,
                e = this.promise_;
            if (!e) {
                if (2 === f(this.url)) e = Promise.resolve(this);
                else {
                    var n = new i.a(function(t) {
                        switch (f(t)) {
                            case s:
                                return t;
                            case l:
                                return Object(o.getAbsolutePath)(t, window.location.href)
                        }
                    }(this.url));
                    this.loader = n, e = n.load().then(function() {
                        return t
                    })
                }
                this.promise_ = e
            }
            return e
        },
        registerPlugin: function(t, e, n) {
            this.name = t, this.target = e, this.js = n
        },
        getNewInstance: function(t, e, n) {
            var r = this.js;
            if ("function" != typeof r) throw new a.s(null, Object(c.c)(this.url) + 100);
            var i = new r(t, e, n);
            return i.addToPlayer = function() {
                var e = t.getContainer().querySelector(".jw-overlays");
                e && (n.left = e.style.left, n.top = e.style.top, e.appendChild(n), i.displayArea = e)
            }, i.resizeHandler = function() {
                var t = i.displayArea;
                t && i.resize(t.clientWidth, t.clientHeight)
            }, i
        }
    }), e.a = d
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(3),
        o = n(4),
        u = n(45),
        a = n(28),
        c = n(9),
        s = n(1);
    e.a = function() {
        var t = Object(r.k)(this, c.a);

        function e(e) {
            try {
                var a, c = e.responseXML ? e.responseXML.childNodes : null,
                    l = "";
                if (c) {
                    for (var f = 0; f < c.length && 8 === (l = c[f]).nodeType; f++);
                    if ("xml" === Object(o.b)(l) && (l = l.nextSibling), "rss" === Object(o.b)(l)) {
                        var d = Object(u.a)(l);
                        a = Object(r.k)({
                            playlist: d
                        }, d.feedData)
                    }
                }
                if (!a) try {
                    var p = JSON.parse(e.responseText);
                    if (Array.isArray(p)) a = {
                        playlist: p
                    };
                    else {
                        if (!Array.isArray(p.playlist)) throw Error("Playlist is not an array");
                        a = p
                    }
                } catch (t) {
                    throw new s.s(s.o, 621, t)
                }
                t.trigger(i.eb, a)
            } catch (t) {
                n(t)
            }
        }

        function n(e) {
            e.code || (e = new s.s(s.o, 0)), t.trigger(i.w, e)
        }
        this.load = function(t) {
            Object(a.a)(t, e, function(t, e, r, i) {
                n(i)
            })
        }, this.destroy = function() {
            this.off()
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return i
    });
    var r = n(0);

    function i(t, e) {
        return Object(r.k)({}, e, {
            prime: function() {
                t.src || t.load()
            },
            getPrimedElement: function() {
                return t
            },
            clean: function() {
                e.clean(t)
            },
            recycle: function() {
                e.clean(t)
            }
        })
    }
}, function(t, e, n) {
    "use strict";
    e.a = "hidden" in document ? function() {
        return !document.hidden
    } : "webkitHidden" in document ? function() {
        return !document.webkitHidden
    } : function() {
        return !0
    }
}, function(t, e, n) {
    "use strict";

    function r(t) {
        return (t = t || window.event) && /^(?:mouse|pointer|touch|gesture|click|key)/.test(t.type)
    }
    n.d(e, "a", function() {
        return r
    })
}, function(t, e, n) {
    "use strict";
    var r = n(0),
        i = n(54),
        o = n(20),
        u = n(12),
        a = n(5),
        c = n(40),
        s = n(14),
        l = {
            autoPause: {
                viewability: !1
            },
            autostart: !1,
            bandwidthEstimate: null,
            bitrateSelection: null,
            castAvailable: !1,
            controls: !0,
            cues: [],
            defaultPlaybackRate: 1,
            displaydescription: !0,
            displaytitle: !0,
            displayPlaybackLabel: !1,
            height: 360,
            intl: {},
            language: "en",
            liveTimeout: null,
            localization: c.a,
            mute: !1,
            nextUpDisplay: !0,
            playbackRateControls: !1,
            playbackRates: [.5, 1, 1.25, 1.5, 2],
            renderCaptionsNatively: !1,
            repeat: !1,
            stretching: "uniform",
            volume: 90,
            width: 640
        };

    function f(t) {
        return t.slice && "px" === t.slice(-2) && (t = t.slice(0, -2)), t
    }
    var d = function(t, e) {
            var i = Object(r.k)({}, (window.jwplayer || {}).defaults, e, t);
            ! function(t) {
                Object.keys(t).forEach(function(e) {
                    "id" !== e && (t[e] = Object(u.serialize)(t[e]))
                })
            }(i);
            var d = i.forceLocalizationDefaults ? l.language : Object(s.e)(),
                p = Object(s.j)(i.intl);
            i.localization = Object(s.a)(c.a, Object(s.c)(i, p, d));
            var h = Object(r.k)({}, l, i);
            "." === h.base && (h.base = Object(o.getScriptPath)("jwplayer.js")), h.base = (h.base || Object(o.loadFrom)()).replace(/\/?$/, "/"), n.p = h.base, h.width = f(h.width), h.height = f(h.height), h.aspectratio = function(t, e) {
                if (-1 === e.toString().indexOf("%")) return 0;
                if ("string" != typeof t || !t) return 0;
                if (/^\d*\.?\d+%$/.test(t)) return t;
                var n = t.indexOf(":");
                if (-1 === n) return 0;
                var r = parseFloat(t.substr(0, n)),
                    i = parseFloat(t.substr(n + 1));
                return r <= 0 || i <= 0 ? 0 : i / r * 100 + "%"
            }(h.aspectratio, h.width), h.volume = Object(r.A)(h.volume) ? Math.min(Math.max(0, h.volume), 100) : l.volume, h.mute = !!h.mute, h.language = d, h.intl = p;
            var v = i.autoPause;
            v && (h.autoPause.viewability = !("viewability" in v && !v.viewability));
            var g = h.playbackRateControls;
            if (g) {
                var b = h.playbackRates;
                Array.isArray(g) && (b = g), (b = b.filter(function(t) {
                    return Object(r.w)(t) && t >= .25 && t <= 4
                }).map(function(t) {
                    return Math.round(100 * t) / 100
                })).indexOf(1) < 0 && b.push(1), b.sort(), h.playbackRateControls = !0, h.playbackRates = b
            }(!h.playbackRateControls || h.playbackRates.indexOf(h.defaultPlaybackRate) < 0) && (h.defaultPlaybackRate = 1), h.playbackRate = h.defaultPlaybackRate, h.aspectratio || delete h.aspectratio;
            var m = h.playlist;
            if (m) Array.isArray(m.playlist) && (h.feedData = m, h.playlist = m.playlist);
            else {
                var y = Object(r.E)(h, ["title", "description", "type", "mediaid", "image", "file", "sources", "tracks", "preload", "duration"]);
                h.playlist = [y]
            }
            h.qualityLabels = h.qualityLabels || h.hlslabels, delete h.duration;
            var j = h.liveTimeout;
            null !== j && (Object(r.A)(j) ? 0 !== j && (j = Math.max(30, j)) : j = null, h.liveTimeout = j);
            var w, O, k = parseFloat(h.bandwidthEstimate),
                C = parseFloat(h.bitrateSelection);
            return h.bandwidthEstimate = Object(r.A)(k) ? k : (w = h.defaultBandwidthEstimate, O = parseFloat(w), Object(r.A)(O) ? Math.max(O, 1) : l.bandwidthEstimate), h.bitrateSelection = Object(r.A)(C) ? C : l.bitrateSelection, h.backgroundLoading = Object(r.s)(h.backgroundLoading) ? h.backgroundLoading : a.Features.backgroundLoading, h
        },
        p = n(26),
        h = n(8),
        v = n(23),
        g = "__CONTEXTUAL__";

    function b(t, e) {
        var n = t.querySelector(e);
        if (n) return n.getAttribute("content")
    }

    function m(t) {
        return "string" == typeof t && /^\/\/(?:content\.jwplatform|cdn\.jwplayer)\.com\//.test(t)
    }

    function y(t) {
        return "https:" + t
    }

    function j(t) {
        var e = "file:" === window.location.protocol ? "https:" : "",
            n = {
                jwpsrv: "//ssl.p.jwpcdn.com/player/v/8.9.3/jwpsrv.js",
                dai: "//ssl.p.jwpcdn.com/player/plugins/dai/v/0.4.9/dai.js",
                vast: "//ssl.p.jwpcdn.com/player/plugins/vast/v/8.6.1/vast.js",
                googima: "//ssl.p.jwpcdn.com/player/plugins/googima/v/8.6.2/googima.js",
                freewheel: "//ssl.p.jwpcdn.com/player/plugins/freewheel/v/2.2.4/freewheel.js",
                gapro: "//ssl.p.jwpcdn.com/player/plugins/gapro/v/2.1.5/gapro.js"
            } [t];
        return n ? e + n : ""
    }

    function w(t, e, n) {
        e && (t[e.client || j(n)] = e, delete e.client)
    }
    var O = function(t, e) {
            var i, u = d(t, e),
                a = u.key || window.jwplayer && window.jwplayer.key,
                c = new p.b(a),
                s = c.edition();
            if (u.key = a, u.edition = s, u.error = c.error(), "unlimited" === s) {
                var l = Object(o.getScriptPath)("jwplayer.js");
                if (!l) throw new Error("Error setting up player: Could not locate jwplayer.js script tag");
                n.p = l
            }
            if (u.flashplayer = function(t) {
                    var e = t.flashplayer;
                    return e || (e = (Object(o.getScriptPath)("jwplayer.js") || t.base) + "jwplayer.flash.swf"), "http:" === window.location.protocol && (e = e.replace(/^https/, "http")), e
                }(u), u.plugins = function(t) {
                    var e = Object(r.k)({}, t.plugins),
                        n = t.edition,
                        i = Object(v.a)(n);
                    if (i("ads")) {
                        var o = Object(r.k)({}, t.advertising),
                            u = o.client;
                        if (u) {
                            var a = j(u) || u;
                            e[a] = o, delete o.client
                        }
                    }
                    if (i("jwpsrv")) {
                        var c = t.analytics;
                        c !== Object(c) && (c = {}), w(e, c, "jwpsrv")
                    }
                    w(e, t.ga, "gapro");
                    var s = t.related,
                        l = !i("discovery") || s !== Object(s),
                        f = !s || "none" !== s.displayMode,
                        d = s || {},
                        p = void 0 === d.oncomplete ? "none" : d.oncomplete,
                        h = d.autoplaytimer;
                    !1 === p || t.repeat ? p = "hide" : "none" === p && (h = 0);
                    var g = "autoplay" === p && h <= 0 || "none" === p;
                    return t.related = Object(r.k)({}, s, {
                        disableRelated: l,
                        showButton: f,
                        oncomplete: p,
                        autoplaytimer: h,
                        shouldAutoAdvance: g
                    }), e
                }(u), u.ab && (u.ab = function(t) {
                    var e = t.ab;
                    return e.clone && (e = e.clone()), Object.keys(e.tests).forEach(function(n) {
                        e.tests[n].forEach(function(e) {
                            e.addConfig && e.addConfig(t, e.selection)
                        })
                    }), e
                }(u)), i = u.playlist, Object(r.y)(i) && i.indexOf(g) > -1 && (u.playlist = function(t, e) {
                    var n = (t.querySelector("title") || {}).textContent,
                        r = b(t, 'meta[property="og:title"]'),
                        i = encodeURIComponent(r || n || ""),
                        o = b(t, 'meta[property="og:description"]') || b(t, 'meta[name="description"]');
                    return o && (i += "&page_description=" + encodeURIComponent(o)), e.replace(g, i)
                }(document, u.playlist), u.contextual = !0), Object(h.isFileProtocol)()) {
                var f = u.playlist,
                    O = u.related;
                m(f) && (u.playlist = y(f)), O && m(O.file) && (O.file = y(O.file))
            }
            return u
        },
        k = n(10),
        C = n(25),
        P = n(3),
        x = n(58),
        S = n(30),
        E = n(24),
        T = n(1);

    function A(t) {
        var e = t.get("playlist");
        return new Promise(function(n, r) {
            if ("string" != typeof e) {
                var i = t.get("feedData") || {};
                return _(t, e, i), n()
            }
            var o = new x.a;
            o.on(P.eb, function(e) {
                var r = e.playlist;
                delete e.playlist, _(t, r, e), n()
            }), o.on(P.w, function(e) {
                _(t, [], {}), r(Object(T.z)(e, T.u))
            }), o.load(e)
        })
    }

    function _(t, e, n) {
        var r = t.attributes;
        r.playlist = Object(S.a)(e), r.feedData = n
    }

    function F(t) {
        return t.attributes._destroyed
    }
    var I = n(36);

    function M(t) {
        return D(t) ? Promise.resolve() : A(t).then(function() {
            if (t.get("drm") || Object(I.b)(t.get("playlist"))) return Object(I.d)(t.get("edition"))
        }).then(function() {
            return A(e = t).then(function() {
                if (!F(e)) {
                    var t = Object(S.b)(e.get("playlist"), e);
                    e.attributes.playlist = t;
                    try {
                        Object(S.e)(t)
                    } catch (t) {
                        throw t.code += T.u, t
                    }
                    var n = e.getProviders(),
                        r = n.choose(t[0].sources[0]),
                        i = r.provider,
                        o = r.name;
                    return "function" == typeof i ? i : k.a.html5 && "html5" === o ? k.a.html5 : n.load(o).catch(function(t) {
                        throw Object(T.z)(t, T.v)
                    })
                }
            });
            var e
        })
    }

    function N(t, e) {
        var n = [L(t)];
        return D(t) || n.push(Promise.resolve()), Promise.all(n)
    }

    function L(t) {
        var e = t.attributes,
            n = e.error;
        if (n && n.code === p.a) {
            var r = e.pid,
                i = e.ph,
                o = new p.b(e.key);
            if (i > 0 && i < 4 && r && o.duration() > -7776e6) return new E.a("//content.jwplatform.com/libraries/".concat(r, ".js")).load().then(function() {
                var t = window.jwplayer.defaults.key,
                    n = new p.b(t);
                n.error() || n.token() !== o.token() || (e.key = t, e.edition = n.edition(), e.error = n.error())
            }).catch(function() {})
        }
        return Promise.resolve()
    }

    function D(t) {
        var e = t.get("advertising");
        return !(!e || !e.outstream)
    }
    var R = function(t) {
            var e = t.get("skin") ? t.get("skin").url : void 0;
            if ("string" == typeof e && ! function(t) {
                    for (var e = document.styleSheets, n = 0, r = e.length; n < r; n++)
                        if (e[n].href === t) return !0;
                    return !1
                }(e)) return new E.a(e, !0).load().catch(function(t) {
                return t
            });
            return Promise.resolve()
        },
        B = function(t) {
            var e = t.attributes,
                n = e.language,
                r = e.base,
                i = e.setupConfig,
                o = e.intl,
                u = Object(s.c)(i, o, n);
            return !Object(s.h)(n) || Object(s.f)(u) ? Promise.resolve() : new Promise(function(i) {
                return Object(s.i)(r, n).then(function(n) {
                    var r = n.response;
                    if (!F(t)) {
                        if (!r) throw new T.s(null, T.g);
                        e.localization = Object(s.a)(r, u), i()
                    }
                }).catch(function(t) {
                    i(t.code === T.g ? t : Object(T.z)(t, T.f))
                })
            })
        };
    var q = function(t) {
            var e;
            this.start = function(n) {
                var r = Object(C.a)(t, n),
                    i = Promise.all([Object(k.d)(t), r, M(t), N(t), R(t), B(t)]),
                    o = new Promise(function(t, n) {
                        e = setTimeout(function() {
                            n(new T.s(T.m, T.x))
                        }, 6e4);
                        var r = function() {
                            clearTimeout(e), setTimeout(t, 6e4)
                        };
                        i.then(r).catch(r)
                    });
                return Promise.race([i, o]).catch(function(t) {
                    var e = function() {
                        throw t
                    };
                    return r.then(e).catch(e)
                }).then(function(t) {
                    return function(t) {
                        if (!t || !t.length) return {
                            core: null,
                            warnings: []
                        };
                        var e = t.reduce(function(t, e) {
                            return t.concat(e)
                        }, []).filter(function(t) {
                            return t && t.code
                        });
                        return {
                            core: t[0],
                            warnings: e
                        }
                    }(t)
                })
            }, this.destroy = function() {
                clearTimeout(e), t.set("_destroyed", !0), t = null
            }
        },
        z = n(42),
        V = n(32),
        Q = n(16),
        W = {
            removeItem: function() {}
        };
    try {
        W = window.localStorage || W
    } catch (t) {}

    function X(t, e) {
        this.namespace = t, this.items = e
    }
    Object(r.k)(X.prototype, {
        getAllItems: function() {
            var t = this;
            return this.items.reduce(function(e, n) {
                var r = W["".concat(t.namespace, ".").concat(n)];
                return r && (e[n] = Object(u.serialize)(r)), e
            }, {})
        },
        track: function(t) {
            var e = this;
            this.items.forEach(function(n) {
                t.on("change:".concat(n), function(t, r) {
                    try {
                        W["".concat(e.namespace, ".").concat(n)] = r
                    } catch (t) {
                        Q.a.debug && console.error(t)
                    }
                })
            })
        },
        clear: function() {
            var t = this;
            this.items.forEach(function(e) {
                W.removeItem("".concat(t.namespace, ".").concat(e))
            })
        }
    });
    var U = X,
        H = n(53),
        Y = n(48),
        K = n(9),
        J = n(43),
        $ = n(55);

    function G(t) {
        t.src || t.load()
    }

    function Z() {
        var t = document.createElement("video");
        return t.className = "jw-video jw-reset", t.setAttribute("tabindex", "-1"), t.setAttribute("disableRemotePlayback", ""), t.setAttribute("webkit-playsinline", ""), t.setAttribute("playsinline", ""), t
    }
    var tt = n(59),
        et = n(35);
    n(64), n(65);
    n.d(e, "b", function() {
        return ot
    });
    var nt = function(t) {
        this._events = {}, this.modelShim = new H.a, this.modelShim._qoeItem = new V.a, this.mediaShim = {}, this.setup = new q(this.modelShim), this.currentContainer = this.originalContainer = t, this.apiQueue = new i.a(this, ["load", "play", "pause", "seek", "stop", "playlistItem", "playlistNext", "playlistPrev", "next", "preload", "setConfig", "setCurrentAudioTrack", "setCurrentCaptions", "setCurrentQuality", "setFullscreen", "addButton", "removeButton", "castToggle", "setMute", "setVolume", "setPlaybackRate", "addCues", "setCues", "setPlaylistItem", "resize", "setCaptions", "setControls"], function() {
            return !0
        })
    };

    function rt(t, e) {
        e && e.code && (e.sourceError && console.error(e.sourceError), console.error(T.s.logMessage(e.code)))
    }

    function it(t) {
        t && t.code && console.warn(T.s.logMessage(t.code))
    }

    function ot(t, e) {
        if (!document.body.contains(t.currentContainer)) {
            var n = document.getElementById(t.get("id"));
            n && (t.currentContainer = n)
        }
        t.currentContainer.parentElement && t.currentContainer.parentElement.replaceChild(e, t.currentContainer), t.currentContainer = e
    }
    Object(r.k)(nt.prototype, {
        on: K.a.on,
        once: K.a.once,
        off: K.a.off,
        trigger: K.a.trigger,
        init: function(t, e) {
            var n = this,
                i = this.modelShim,
                o = new U("jwplayer", ["volume", "mute", "captionLabel", "bandwidthEstimate", "bitrateSelection", "qualityLabel"]),
                u = o && o.getAllItems();
            i.attributes = i.attributes || {}, Object(r.k)(this.mediaShim, Y.a);
            var a = t,
                c = O(Object(r.k)({}, t), u);
            c.id = e.id, c.setupConfig = a, Object(r.k)(i.attributes, c, Y.b), i.getProviders = function() {
                return new z.a(c)
            }, i.setProvider = function() {};
            var s = function() {
                for (var t = $.c, e = [], n = [], r = 0; r < t; r++) {
                    var i = Z();
                    e.push(i), n.push(i), G(i)
                }
                var o = n.shift(),
                    u = n.shift(),
                    a = !1;
                return {
                    primed: function() {
                        return a
                    },
                    prime: function() {
                        e.forEach(G), a = !0
                    },
                    played: function() {
                        a = !0
                    },
                    getPrimedElement: function() {
                        return n.length ? n.shift() : null
                    },
                    getAdElement: function() {
                        return o
                    },
                    getTestElement: function() {
                        return u
                    },
                    clean: function(t) {
                        if (t.src) {
                            t.removeAttribute("src");
                            try {
                                t.load()
                            } catch (t) {}
                        }
                    },
                    recycle: function(t) {
                        t && !n.some(function(e) {
                            return e === t
                        }) && (this.clean(t), n.push(t))
                    },
                    syncVolume: function(t) {
                        var n = Math.min(Math.max(0, t / 100), 1);
                        e.forEach(function(t) {
                            t.volume = n
                        })
                    },
                    syncMute: function(t) {
                        e.forEach(function(e) {
                            e.muted = t
                        })
                    }
                }
            }();
            i.get("backgroundLoading") || (s = Object(tt.a)(s.getPrimedElement(), s));
            var l = new et.a(Object(et.b)(this.originalContainer)).once("gesture", function() {
                s.prime(), n.preload(), l.destroy()
            });
            return i.on("change:errorEvent", rt), this.setup.start(e).then(function(t) {
                var u = t.core;
                if (!u) throw Object(T.z)(null, T.w);
                if (n.setup) {
                    n.on(P.ub, it), t.warnings.forEach(function(t) {
                        n.trigger(P.ub, t)
                    });
                    var a = n.modelShim.clone();
                    if (a.error) throw a.error;
                    var c = n.apiQueue.queue.slice(0);
                    n.apiQueue.destroy(), Object(r.k)(n, u.prototype), n.setup(a, e, n.originalContainer, n._events, c, s);
                    var l = n._model;
                    return i.off("change:errorEvent", rt), l.on("change:errorEvent", rt), o.track(l), n.updatePlaylist(l.get("playlist"), l.get("feedData")).catch(function(t) {
                        throw Object(T.z)(t, T.u)
                    })
                }
            }).then(function() {
                n.setup && n.playerReady()
            }).catch(function(t) {
                n.setup && function(t, e, n) {
                    Promise.resolve().then(function() {
                        var r = Object(T.A)(T.r, T.y, n),
                            i = t._model || t.modelShim;
                        r.message = r.message || i.get("localization").errors[r.key], delete r.key;
                        var o = i.get("contextual");
                        if (!o) {
                            var u = Object(J.a)(t, r);
                            J.a.cloneIcon && u.querySelector(".jw-icon").appendChild(J.a.cloneIcon("error")), ot(t, u)
                        }
                        i.set("errorEvent", r), i.set("state", P.mb), t.trigger(P.jb, r), o && e.remove()
                    })
                }(n, e, t)
            })
        },
        playerDestroy: function() {
            this.apiQueue && this.apiQueue.destroy(), this.setup && this.setup.destroy(), this.currentContainer !== this.originalContainer && ot(this, this.originalContainer), this.off(), this._events = this._model = this.modelShim = this.apiQueue = this.setup = null
        },
        getContainer: function() {
            return this.currentContainer
        },
        get: function(t) {
            if (this.modelShim) return t in this.mediaShim ? this.mediaShim[t] : this.modelShim.get(t)
        },
        getItemQoe: function() {
            return this.modelShim._qoeItem
        },
        getConfig: function() {
            return Object(r.k)({}, this.modelShim.attributes, this.mediaShim)
        },
        getCurrentCaptions: function() {
            return this.get("captionsIndex")
        },
        getWidth: function() {
            return this.get("containerWidth")
        },
        getHeight: function() {
            return this.get("containerHeight")
        },
        getMute: function() {
            return this.get("mute")
        },
        getProvider: function() {
            return this.get("provider")
        },
        getState: function() {
            return this.get("state")
        },
        getAudioTracks: function() {
            return null
        },
        getCaptionsList: function() {
            return null
        },
        getQualityLevels: function() {
            return null
        },
        getVisualQuality: function() {
            return null
        },
        getCurrentQuality: function() {
            return -1
        },
        getCurrentAudioTrack: function() {
            return -1
        },
        getSafeRegion: function() {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        },
        isBeforeComplete: function() {
            return !1
        },
        isBeforePlay: function() {
            return !1
        },
        createInstream: function() {
            return null
        },
        skipAd: function() {},
        attachMedia: function() {},
        detachMedia: function() {
            return null
        }
    });
    e.a = nt
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return i
    });
    var r = n(5);

    function i(t) {
        return "hls" === t.type && r.OS.android ? !1 !== t.androidhls && (!r.Browser.firefox && parseFloat(r.OS.version.version) >= 4.4) : null
    }
}, function(t, e, n) {
    "use strict";
    var r, i = n(60),
        o = n(5),
        u = [],
        a = [],
        c = {},
        s = "screen" in window && "orientation" in window.screen,
        l = o.OS.android && o.Browser.chrome;

    function f(t, e) {
        for (var n = e.length; n--;) {
            var r = e[n];
            if (t.target === r.getContainer()) {
                r.setIntersection(t);
                break
            }
        }
    }

    function d() {
        u.forEach(function(t) {
            var e = t.model;
            if (!(e.get("audioMode") || !e.get("controls") || e.get("visibility") < .75)) {
                var n = e.get("state"),
                    r = window.screen.orientation.type,
                    i = "landscape-primary" === r || "landscape-secondary" === r;
                !i && "paused" === n && t.api.getFullscreen() ? t.api.setFullscreen(!1) : "playing" === n && t.api.setFullscreen(i)
            }
        })
    }

    function p() {
        u.forEach(function(t) {
            t.model.set("activeTab", Object(i.a)())
        })
    }

    function h(t, e) {
        var n = e.indexOf(t); - 1 !== n && e.splice(n, 1)
    }
    document.addEventListener("visibilitychange", p), document.addEventListener("webkitvisibilitychange", p), l && s && window.screen.orientation.addEventListener("change", d), window.addEventListener("beforeunload", function() {
        document.removeEventListener("visibilitychange", p), document.removeEventListener("webkitvisibilitychange", p), l && s && window.screen.orientation.removeEventListener("change", d)
    }), e.a = {
        add: function(t) {
            u.push(t)
        },
        remove: function(t) {
            h(t, u)
        },
        addWidget: function(t) {
            a.push(t)
        },
        removeWidget: function(t) {
            h(t, a)
        },
        size: function() {
            return u.length
        },
        observe: function(t) {
            var e;
            e = window.IntersectionObserver, r || (r = new e(function(t) {
                if (t && t.length)
                    for (var e = t.length; e--;) {
                        var n = t[e];
                        f(n, u), f(n, a)
                    }
            }, {
                threshold: [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]
            })), c[t.id] || (c[t.id] = !0, r.observe(t))
        },
        unobserve: function(t) {
            r && c[t.id] && (delete c[t.id], r.unobserve(t))
        }
    }
}, function(t, e, n) {
    "use strict";
    n.d(e, "a", function() {
        return f
    });
    var r = n(0),
        i = n(49),
        o = n(7),
        u = n(11);

    function a(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    var c = [],
        s = -1;

    function l() {
        Object(i.a)(s), s = Object(i.b)(function() {
            c.forEach(function(t) {
                t.view.updateBounds();
                var e = t.view.model.get("containerWidth");
                t.resized = t.width !== e, t.width = e
            }), c.forEach(function(t) {
                t.contractElement.scrollLeft = 2 * t.width
            }), c.forEach(function(t) {
                Object(u.d)(t.expandChild, {
                    width: t.width + 1
                }), t.resized && t.view.model.get("visibility") && t.view.updateStyles()
            }), c.forEach(function(t) {
                t.expandElement.scrollLeft = t.width + 1
            }), c.forEach(function(t) {
                t.resized && t.view.checkResized()
            })
        })
    }
    var f = function() {
        function t(e, n, i) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var a = {
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                },
                s = {
                    width: "100%",
                    height: "100%"
                },
                f = Object(o.e)('<div style="opacity:0;visibility:hidden;overflow:hidden;"><div><div style="height:1px;"></div></div><div class="jw-contract-trigger"></div></div>'),
                d = f.firstChild,
                p = d.firstChild,
                h = d.nextSibling;
            Object(u.d)([d, h], Object(r.k)({
                overflow: "auto"
            }, a, s)), Object(u.d)(f, Object(r.k)({}, a, s)), this.expandElement = d, this.expandChild = p, this.contractElement = h, this.hiddenElement = f, this.element = e, this.view = n, this.model = i, this.width = 0, this.resized = !1, e.firstChild ? e.insertBefore(f, e.firstChild) : e.appendChild(f), e.addEventListener("scroll", l, !0), c.push(this), l()
        }
        var e, n, i;
        return e = t, (n = [{
            key: "destroy",
            value: function() {
                if (this.view) {
                    var t = c.indexOf(this); - 1 !== t && c.splice(t, 1), this.element.removeEventListener("scroll", l, !0), this.element.removeChild(this.hiddenElement), this.view = this.model = null
                }
            }
        }]) && a(e.prototype, n), i && a(e, i), t
    }()
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = setTimeout;

    function o() {}

    function u(t) {
        if (!(this instanceof u)) throw new TypeError("Promises must be constructed via new");
        if ("function" != typeof t) throw new TypeError("not a function");
        this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(t, this)
    }

    function a(t, e) {
        for (; 3 === t._state;) t = t._value;
        0 !== t._state ? (t._handled = !0, u._immediateFn(function() {
            var n = 1 === t._state ? e.onFulfilled : e.onRejected;
            if (null !== n) {
                var r;
                try {
                    r = n(t._value)
                } catch (t) {
                    return void s(e.promise, t)
                }
                c(e.promise, r)
            } else(1 === t._state ? c : s)(e.promise, t._value)
        })) : t._deferreds.push(e)
    }

    function c(t, e) {
        try {
            if (e === t) throw new TypeError("A promise cannot be resolved with itself.");
            if (e && ("object" == typeof e || "function" == typeof e)) {
                var n = e.then;
                if (e instanceof u) return t._state = 3, t._value = e, void l(t);
                if ("function" == typeof n) return void d((r = n, i = e, function() {
                    r.apply(i, arguments)
                }), t)
            }
            t._state = 1, t._value = e, l(t)
        } catch (e) {
            s(t, e)
        }
        var r, i
    }

    function s(t, e) {
        t._state = 2, t._value = e, l(t)
    }

    function l(t) {
        2 === t._state && 0 === t._deferreds.length && u._immediateFn(function() {
            t._handled || u._unhandledRejectionFn(t._value)
        });
        for (var e = 0, n = t._deferreds.length; e < n; e++) a(t, t._deferreds[e]);
        t._deferreds = null
    }

    function f(t, e, n) {
        this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = n
    }

    function d(t, e) {
        var n = !1;
        try {
            t(function(t) {
                n || (n = !0, c(e, t))
            }, function(t) {
                n || (n = !0, s(e, t))
            })
        } catch (t) {
            if (n) return;
            n = !0, s(e, t)
        }
    }
    u.prototype.catch = function(t) {
        return this.then(null, t)
    }, u.prototype.then = function(t, e) {
        var n = new this.constructor(o);
        return a(this, new f(t, e, n)), n
    }, u.prototype.finally = function(t) {
        var e = this.constructor;
        return this.then(function(n) {
            return e.resolve(t()).then(function() {
                return n
            })
        }, function(n) {
            return e.resolve(t()).then(function() {
                return e.reject(n)
            })
        })
    }, u.all = function(t) {
        return new u(function(e, n) {
            if (!t || void 0 === t.length) throw new TypeError("Promise.all accepts an array");
            var r = Array.prototype.slice.call(t);
            if (0 === r.length) return e([]);
            var i = r.length;

            function o(t, u) {
                try {
                    if (u && ("object" == typeof u || "function" == typeof u)) {
                        var a = u.then;
                        if ("function" == typeof a) return void a.call(u, function(e) {
                            o(t, e)
                        }, n)
                    }
                    r[t] = u, 0 == --i && e(r)
                } catch (t) {
                    n(t)
                }
            }
            for (var u = 0; u < r.length; u++) o(u, r[u])
        })
    }, u.resolve = function(t) {
        return t && "object" == typeof t && t.constructor === u ? t : new u(function(e) {
            e(t)
        })
    }, u.reject = function(t) {
        return new u(function(e, n) {
            n(t)
        })
    }, u.race = function(t) {
        return new u(function(e, n) {
            for (var r = 0, i = t.length; r < i; r++) t[r].then(e, n)
        })
    }, u._immediateFn = "function" == typeof setImmediate && function(t) {
        setImmediate(t)
    } || function(t) {
        i(t, 0)
    }, u._unhandledRejectionFn = function(t) {
        "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t)
    };
    var p = u;
    window.Promise || (window.Promise = p);
    var h = n(20),
        v = n(15),
        g = n(17),
        b = n(13),
        m = {
            availableProviders: g.a,
            registerProvider: b.a
        },
        y = n(25);
    m.registerPlugin = function(t, e, n) {
        "jwpsrv" !== t && Object(y.b)(t, e, n)
    };
    var j = m,
        w = n(31),
        O = n(16),
        k = n(5),
        C = n(62),
        P = n(3),
        x = n(32),
        S = n(9),
        E = n(8),
        T = n(12),
        A = n(2);

    function _(t, e) {
        this.name = t, this.message = e.message || e.toString(), this.error = e
    }
    var F = n(6),
        I = n(7),
        M = n(11),
        N = n(28),
        L = n(51),
        D = n(46),
        R = n(52);
    var B = Object(r.k)({}, T, E, h, {
            addClass: I.a,
            hasClass: I.h,
            removeClass: I.n,
            replaceClass: I.o,
            toggleClass: I.u,
            classList: I.d,
            styleDimension: I.t,
            createElement: I.e,
            emptyElement: I.g,
            addStyleSheet: I.b,
            bounds: I.c,
            openLink: I.k,
            css: M.b,
            clearCss: M.a,
            style: M.d,
            transform: M.e,
            getRgba: M.c,
            ajax: N.a,
            crossdomain: function(t) {
                var e = document.createElement("a"),
                    n = document.createElement("a");
                e.href = location.href;
                try {
                    return n.href = t, n.href = n.href, e.protocol + "//" + e.host != n.protocol + "//" + n.host
                } catch (t) {}
                return !0
            },
            tryCatch: function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                if (O.a.debug) return t.apply(e || this, n);
                try {
                    return t.apply(e || this, n)
                } catch (e) {
                    return new _(t.name, e)
                }
            },
            Error: _,
            Timer: x.a,
            log: D.a,
            genId: R.b,
            between: L.a,
            foreach: function(t, e) {
                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n])
            },
            flashVersion: F.a,
            isIframe: F.m,
            indexOf: r.q,
            trim: A.i,
            pad: A.e,
            extension: A.a,
            hms: A.b,
            seconds: A.g,
            prefix: A.f,
            suffix: A.h,
            noop: function() {}
        }),
        q = 0;

    function z(t, e) {
        var n = new C.a(e);
        return n.on(P.hb, function(e) {
            t._qoe.tick("ready"), e.setupTime = t._qoe.between("setup", "ready")
        }), n.on("all", function(e, n) {
            t.trigger(e, n)
        }), n
    }

    function V(t, e) {
        var n = t.plugins;
        Object.keys(n).forEach(function(t) {
            delete n[t]
        }), e.get("setupConfig") && t.trigger("remove"), t.off(), e.playerDestroy(), e.getContainer().removeAttribute("data-jwplayer-id")
    }

    function Q(t) {
        var e = ++q,
            n = t.id || "player-".concat(e),
            i = new x.a,
            o = {},
            u = z(this, t);
        i.tick("init"), t.setAttribute("data-jwplayer-id", n), Object.defineProperties(this, {
            id: {
                enumerable: !0,
                get: function() {
                    return n
                }
            },
            uniqueId: {
                enumerable: !0,
                get: function() {
                    return e
                }
            },
            plugins: {
                enumerable: !0,
                get: function() {
                    return o
                }
            },
            _qoe: {
                enumerable: !0,
                get: function() {
                    return i
                }
            },
            version: {
                enumerable: !0,
                get: function() {
                    return w.a
                }
            },
            Events: {
                enumerable: !0,
                get: function() {
                    return S.a
                }
            },
            utils: {
                enumerable: !0,
                get: function() {
                    return B
                }
            },
            _: {
                enumerable: !0,
                get: function() {
                    return r.g
                }
            }
        }), Object(r.k)(this, {
            _events: {},
            setup: function(e) {
                return i.clear("ready"), i.tick("setup"), V(this, u), (u = z(this, t)).init(e, this), this.on(e.events, null, this)
            },
            remove: function() {
                return function(t) {
                    for (var e = v.a.length; e--;)
                        if (v.a[e].uniqueId === t.uniqueId) {
                            v.a.splice(e, 1);
                            break
                        }
                }(this), V(this, u), this
            },
            qoe: function() {
                var t = u.getItemQoe();
                return {
                    setupTime: this._qoe.between("setup", "ready"),
                    firstFrame: t.getFirstFrame ? t.getFirstFrame() : null,
                    player: this._qoe.dump(),
                    item: t.dump()
                }
            },
            addCues: function(t) {
                return Array.isArray(t) && u.addCues(t), this
            },
            getAudioTracks: function() {
                return u.getAudioTracks()
            },
            getBuffer: function() {
                return u.get("buffer")
            },
            getCaptions: function() {
                return u.get("captions")
            },
            getCaptionsList: function() {
                return u.getCaptionsList()
            },
            getConfig: function() {
                return u.getConfig()
            },
            getContainer: function() {
                return u.getContainer()
            },
            getControls: function() {
                return u.get("controls")
            },
            getCues: function() {
                return u.get("cues")
            },
            getCurrentAudioTrack: function() {
                return u.getCurrentAudioTrack()
            },
            getCurrentCaptions: function() {
                return u.getCurrentCaptions()
            },
            getCurrentQuality: function() {
                return u.getCurrentQuality()
            },
            getCurrentTime: function() {
                return u.get("currentTime")
            },
            getDuration: function() {
                return u.get("duration")
            },
            getEnvironment: function() {
                return k
            },
            getFullscreen: function() {
                return u.get("fullscreen")
            },
            getHeight: function() {
                return u.getHeight()
            },
            getItemMeta: function() {
                return u.get("itemMeta") || {}
            },
            getMute: function() {
                return u.getMute()
            },
            getPlaybackRate: function() {
                return u.get("playbackRate")
            },
            getPlaylist: function() {
                return u.get("playlist")
            },
            getPlaylistIndex: function() {
                return u.get("item")
            },
            getPlaylistItem: function(t) {
                if (!B.exists(t)) return u.get("playlistItem");
                var e = this.getPlaylist();
                return e ? e[t] : null
            },
            getPosition: function() {
                return u.get("position")
            },
            getProvider: function() {
                return u.getProvider()
            },
            getQualityLevels: function() {
                return u.getQualityLevels()
            },
            getSafeRegion: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                return u.getSafeRegion(t)
            },
            getState: function() {
                return u.getState()
            },
            getStretching: function() {
                return u.get("stretching")
            },
            getViewable: function() {
                return u.get("viewable")
            },
            getVisualQuality: function() {
                return u.getVisualQuality()
            },
            getVolume: function() {
                return u.get("volume")
            },
            getWidth: function() {
                return u.getWidth()
            },
            setCaptions: function(t) {
                return u.setCaptions(t), this
            },
            setConfig: function(t) {
                return u.setConfig(t), this
            },
            setControls: function(t) {
                return u.setControls(t), this
            },
            setCurrentAudioTrack: function(t) {
                u.setCurrentAudioTrack(t)
            },
            setCurrentCaptions: function(t) {
                u.setCurrentCaptions(t)
            },
            setCurrentQuality: function(t) {
                u.setCurrentQuality(t)
            },
            setFullscreen: function(t) {
                return u.setFullscreen(t), this
            },
            setMute: function(t) {
                return u.setMute(t), this
            },
            setPlaybackRate: function(t) {
                return u.setPlaybackRate(t), this
            },
            setPlaylistItem: function(t, e) {
                return u.setPlaylistItem(t, e), this
            },
            setCues: function(t) {
                return Array.isArray(t) && u.setCues(t), this
            },
            setVolume: function(t) {
                return u.setVolume(t), this
            },
            load: function(t, e) {
                return u.load(t, e), this
            },
            play: function(t) {
                return u.play(t), this
            },
            pause: function(t) {
                return u.pause(t), this
            },
            playToggle: function(t) {
                switch (this.getState()) {
                    case P.qb:
                    case P.kb:
                        return this.pause(t);
                    default:
                        return this.play(t)
                }
            },
            seek: function(t, e) {
                return u.seek(t, e), this
            },
            playlistItem: function(t, e) {
                return u.playlistItem(t, e), this
            },
            playlistNext: function(t) {
                return u.playlistNext(t), this
            },
            playlistPrev: function(t) {
                return u.playlistPrev(t), this
            },
            next: function(t) {
                return u.next(t), this
            },
            castToggle: function() {
                return u.castToggle(), this
            },
            createInstream: function() {
                return u.createInstream()
            },
            skipAd: function() {
                return u.skipAd(), this
            },
            stop: function() {
                return u.stop(), this
            },
            resize: function(t, e) {
                return u.resize(t, e), this
            },
            addButton: function(t, e, n, r, i) {
                return u.addButton(t, e, n, r, i), this
            },
            removeButton: function(t) {
                return u.removeButton(t), this
            },
            attachMedia: function() {
                return u.attachMedia(), this
            },
            detachMedia: function() {
                return u.detachMedia(), this
            },
            isBeforeComplete: function() {
                return u.isBeforeComplete()
            },
            isBeforePlay: function() {
                return u.isBeforePlay()
            }
        })
    }
    Object(r.k)(Q.prototype, {
        on: function(t, e, n) {
            return S.c.call(this, t, e, n)
        },
        once: function(t, e, n) {
            return S.d.call(this, t, e, n)
        },
        off: function(t, e, n) {
            return S.b.call(this, t, e, n)
        },
        trigger: function(t, e) {
            return (e = r.g.isObject(e) ? Object(r.k)({}, e) : {}).type = t, O.a.debug ? S.e.call(this, t, e) : S.f.call(this, t, e)
        },
        getPlugin: function(t) {
            return this.plugins[t]
        },
        addPlugin: function(t, e) {
            this.plugins[t] = e, this.on("ready", e.addToPlayer), e.resize && this.on("resize", e.resizeHandler)
        },
        registerPlugin: function(t, e, n) {
            Object(y.b)(t, e, n)
        },
        getAdBlock: function() {
            return !1
        },
        playAd: function(t) {},
        pauseAd: function(t) {}
    }), n.p = Object(h.loadFrom)();
    var W = function(t) {
        var e, n;
        if (t ? "string" == typeof t ? (e = X(t)) || (n = document.getElementById(t)) : "number" == typeof t ? e = v.a[t] : t.nodeType && (e = X((n = t).id || n.getAttribute("data-jwplayer-id"))) : e = v.a[0], e) return e;
        if (n) {
            var r = new Q(n);
            return v.a.push(r), r
        }
        return {
            registerPlugin: y.b
        }
    };

    function X(t) {
        for (var e = 0; e < v.a.length; e++)
            if (v.a[e].id === t) return v.a[e];
        return null
    }

    function U(t) {
        Object.defineProperties(t, {
            api: {
                get: function() {
                    return j
                },
                set: function() {}
            },
            version: {
                get: function() {
                    return w.a
                },
                set: function() {}
            },
            debug: {
                get: function() {
                    return O.a.debug
                },
                set: function(t) {
                    O.a.debug = !!t
                }
            }
        })
    }
    U(W);
    var H = W,
        Y = n(35),
        K = n(26),
        J = n(24),
        $ = n(47),
        G = n(45),
        Z = n(39),
        tt = r.g.extend,
        et = {};
    et._ = r.g, et.utils = Object(r.k)(B, {
        key: K.b,
        extend: tt,
        scriptloader: J.a,
        rssparser: {
            parse: G.a
        },
        tea: $.a,
        UI: Y.a
    }), et.utils.css.style = et.utils.style, et.vid = Z.a;
    var nt = et,
        rt = n(61),
        it = /^(?:on(?:ce)?|off|trigger)$/;

    function ot(t) {
        ut(this, t, t), ut(this, t, Q.prototype)
    }

    function ut(t, e, n) {
        var r = Object.keys(n);
        r.forEach(function(i) {
            "function" == typeof n[i] && "Events" !== i ? t[i] = function t(e, n, r, i) {
                return function() {
                    var o = Array.prototype.slice.call(arguments),
                        u = o[0],
                        a = n._trackCallQueue || (n._trackCallQueue = []),
                        c = it.test(r),
                        s = c && o[1] && o[1]._callback;
                    if (s || a.push([r, u]), c) return ct(n, a), n[r].apply(e, o);
                    ! function(t, e) {
                        var n = {
                            reason: Object(rt.a)() ? "interaction" : "external"
                        };
                        switch (t) {
                            case "play":
                            case "pause":
                            case "playToggle":
                            case "playlistNext":
                            case "playlistPrev":
                            case "next":
                                e[0] = n;
                                break;
                            case "seek":
                            case "playlistItem":
                                e[1] = n
                        }
                    }(r, o);
                    var l = n[r].apply(n, o);
                    return "remove" === r ? n.off.call(e) : "setup" === r && (n.off.call(e), n.off(u.events, null, n), n.on.call(e, u.events, null, e), n.on("all", function(r, o) {
                        if ("ready" === r) {
                            var u = Object.keys(n).filter(function(t) {
                                    return "_" !== t[0] && -1 === i.indexOf(t) && "function" == typeof n[t]
                                }),
                                c = i.concat(u);
                            u.forEach(function(r) {
                                e[r] = t(e, n, r, c)
                            })
                        }
                        n.trigger.call(e, r, o), ct(n, a)
                    })), ct(n, a), l === n ? e : l
                }
            }(t, e, i, r) : "_events" === i ? t._events = {} : Object.defineProperty(t, i, {
                enumerable: !0,
                get: function() {
                    return n[i]
                }
            })
        })
    }

    function at(t, e, n) {
        try {
            var r = function(t, e) {
                switch (t) {
                    case "setup":
                        return !!e;
                    case "getSafeRegion":
                    case "pauseAd":
                    case "setControls":
                    case "setFullscreen":
                    case "setMute":
                        return !!e === e ? e : void 0;
                    case "setPlaylistItem":
                    case "getPlaylistItem":
                        return (0 | e) === e ? e : void 0;
                    case "setPlaybackRate":
                    case "setVolume":
                        return Number(e);
                    case "setConfig":
                        return Object.keys(Object(e)).join(",");
                    case "on":
                    case "once":
                    case "off":
                    case "trigger":
                    case "getPlugin":
                    case "addPlugin":
                    case "registerPlugin":
                        return "" + e
                }
                return null
            }(e, n);
            t.trackExternalAPIUsage(e, r)
        } catch (t) {
            O.a.debug && console.warn(t)
        }
    }

    function ct(t, e) {
        if (e.length) {
            var n = t.getPlugin("jwpsrv");
            n && n.trackExternalAPIUsage && (e.forEach(function(t) {
                at(n, t[0], t[1])
            }), e.length = 0)
        }
    }
    var st = window;
    Object(r.k)(H, nt);
    var lt = function(t) {
        var e = H(t);
        return e.uniqueId ? e._publicApi || (e._publicApi = new ot(e)) : e
    };
    Object(r.k)(lt, nt), U(lt), "function" == typeof st.define && st.define.amd && st.define([], function() {
        return lt
    });
    var ft = lt;
    st.jwplayer && (ft = st.jwplayer);
    e.default = ft
}]).default;


    // JQuery & Plugins
      /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
      !function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

      return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
      return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});
      var $ = jQuery.noConflict(true); 

      /*! jQuery UI - v1.11.4 - 2016-03-18 */
      (function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e($)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}};var s=0,n=Array.prototype.slice;e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var i,s,a=n.call(arguments,1),o=0,r=a.length;r>o;o++)for(i in a[o])s=a[o][i],a[o].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(a){var o="string"==typeof a,r=n.call(arguments,1),h=this;return o?this.each(function(){var i,n=e.data(this,s);return"instance"===a?(h=n,!1):n?e.isFunction(n[a])&&"_"!==a.charAt(0)?(i=n[a].apply(n,r),i!==n&&void 0!==i?(h=i&&i.jquery?h.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+a+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+a+"'")}):(r.length&&(a=e.widget.extend.apply(null,[a].concat(r))),this.each(function(){var t=e.data(this,s);t?(t.option(a||{}),t._init&&t._init()):e.data(this,s,new i(a,this))})),h}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=s++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget;var a=!1;e(document).mouseup(function(){a=!1}),e.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!a){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,n="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),a=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),a=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),e.widget("ui.draggable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,s._parent=i.helper.parent(),a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,_=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>_||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(n=m>=Math.abs(u-_),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||a||o||r,"outer"!==f.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-_),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable,e.widget("ui.slider",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"),this._refresh(),this._setOption("disabled",this.options.disabled),this._animateOff=!1
      },_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,i,s=this.options,n=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),a="<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",o=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),t=n.length;i>t;t++)o.push(a);this.handles=n.add(e(o.join("")).appendTo(this.element)),this.handle=this.handles.eq(0),this.handles.each(function(t){e(this).data("ui-slider-handle-index",t)})},_createRange:function(){var t=this.options,i="";t.range?(t.range===!0&&(t.values?t.values.length&&2!==t.values.length?t.values=[t.values[0],t.values[0]]:e.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({left:"",bottom:""}):(this.range=e("<div></div>").appendTo(this.element),i="ui-slider-range ui-widget-header ui-corner-all"),this.range.addClass(i+("min"===t.range||"max"===t.range?" ui-slider-range-"+t.range:""))):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"),this._mouseDestroy()},_mouseCapture:function(t){var i,s,n,a,o,r,h,l,u=this,d=this.options;return d.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:t.pageX,y:t.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var i=Math.abs(s-u.values(t));(n>i||n===i&&(t===u._lastChangedValue||u.values(t)===d.min))&&(n=i,a=e(this),o=t)}),r=this._start(t,o),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=o,a.addClass("ui-state-active").focus(),h=a.offset(),l=!e(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:t.pageX-h.left-a.width()/2,top:t.pageY-h.top-a.height()/2-(parseInt(a.css("borderTopWidth"),10)||0)-(parseInt(a.css("borderBottomWidth"),10)||0)+(parseInt(a.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(e){var t={x:e.pageX,y:e.pageY},i=this._normValueFromMouse(t);return this._slide(e,this._handleIndex,i),!1},_mouseStop:function(e){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(e,this._handleIndex),this._change(e,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(e){var t,i,s,n,a;return"horizontal"===this.orientation?(t=this.elementSize.width,i=e.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(t=this.elementSize.height,i=e.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/t,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),a=this._valueMin()+s*n,this._trimAlignValue(a)},_start:function(e,t){var i={handle:this.handles[t],value:this.value()};return this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("start",e,i)},_slide:function(e,t,i){var s,n,a;this.options.values&&this.options.values.length?(s=this.values(t?0:1),2===this.options.values.length&&this.options.range===!0&&(0===t&&i>s||1===t&&s>i)&&(i=s),i!==this.values(t)&&(n=this.values(),n[t]=i,a=this._trigger("slide",e,{handle:this.handles[t],value:i,values:n}),s=this.values(t?0:1),a!==!1&&this.values(t,i))):i!==this.value()&&(a=this._trigger("slide",e,{handle:this.handles[t],value:i}),a!==!1&&this.value(i))},_stop:function(e,t){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("stop",e,i)},_change:function(e,t){if(!this._keySliding&&!this._mouseSliding){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._lastChangedValue=t,this._trigger("change",e,i)}},value:function(e){return arguments.length?(this.options.value=this._trimAlignValue(e),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(t,i){var s,n,a;if(arguments.length>1)return this.options.values[t]=this._trimAlignValue(i),this._refreshValue(),this._change(null,t),void 0;if(!arguments.length)return this._values();if(!e.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(t):this.value();for(s=this.options.values,n=arguments[0],a=0;s.length>a;a+=1)s[a]=this._trimAlignValue(n[a]),this._change(null,a);this._refreshValue()},_setOption:function(t,i){var s,n=0;switch("range"===t&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),e.isArray(this.options.values)&&(n=this.options.values.length),"disabled"===t&&this.element.toggleClass("ui-state-disabled",!!i),this._super(t,i),t){case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue(),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=0;n>s;s+=1)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_value:function(){var e=this.options.value;return e=this._trimAlignValue(e)},_values:function(e){var t,i,s;if(arguments.length)return t=this.options.values[e],t=this._trimAlignValue(t);if(this.options.values&&this.options.values.length){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(e){if(this._valueMin()>=e)return this._valueMin();if(e>=this._valueMax())return this._valueMax();var t=this.options.step>0?this.options.step:1,i=(e-this._valueMin())%t,s=e-i;return 2*Math.abs(i)>=t&&(s+=i>0?t:-t),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var e=this.options.max,t=this._valueMin(),i=this.options.step,s=Math.floor(+(e-t).toFixed(this._precision())/i)*i;e=s+t,this.max=parseFloat(e.toFixed(this._precision()))},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshValue:function(){var t,i,s,n,a,o=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,u={};this.options.values&&this.options.values.length?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),u["horizontal"===h.orientation?"left":"bottom"]=i+"%",e(this).stop(1,1)[l?"animate":"css"](u,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-t+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-t+"%"},{queue:!1,duration:r.animate}))),t=i}):(s=this.value(),n=this._valueMin(),a=this._valueMax(),i=a!==n?100*((s-n)/(a-n)):0,u["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](u,r.animate),"min"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===o&&"horizontal"===this.orientation&&this.range[l?"animate":"css"]({width:100-i+"%"},{queue:!1,duration:r.animate}),"min"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===o&&"vertical"===this.orientation&&this.range[l?"animate":"css"]({height:100-i+"%"},{queue:!1,duration:r.animate}))},_handleEvents:{keydown:function(t){var i,s,n,a,o=e(t.target).data("ui-slider-handle-index");switch(t.keyCode){case e.ui.keyCode.HOME:case e.ui.keyCode.END:case e.ui.keyCode.PAGE_UP:case e.ui.keyCode.PAGE_DOWN:case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(t.preventDefault(),!this._keySliding&&(this._keySliding=!0,e(t.target).addClass("ui-state-active"),i=this._start(t,o),i===!1))return}switch(a=this.options.step,s=n=this.options.values&&this.options.values.length?this.values(o):this.value(),t.keyCode){case e.ui.keyCode.HOME:n=this._valueMin();break;case e.ui.keyCode.END:n=this._valueMax();break;case e.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+a);break;case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-a)}this._slide(t,o,n)},keyup:function(t){var i=e(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,i),this._change(t,i),e(t.target).removeClass("ui-state-active"))}}})});

      // JQTouch
      (function(){$.jQT=function(){function a(a){var j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A;this.tapHandlers=this.tapHandlers.concat([{name:"external-link",isSupported:function(a,b){return q(b.$el)},fn:function(a,b){return b.$el.removeClass("active"),!0}},{name:"back-selector",isSupported:function(a){return function(b,c){return c.$el.is(a.settings.backSelector)}}(this),fn:function(a){return function(b,c){return a.goBack(c.hash),!1}}(this)},{name:"submit-selector",isSupported:function(a){return function(b,c){return c.$el.is(a.settings.submitSelector)}}(this),fn:function(a,b){x(b.$el)}},{name:"webapp",isSupported:function(a,b){return"_webapp"===b.target},fn:function(a,b){return window.location=b.href,!1}},{name:"no-op",isSupported:function(a,b){return"#"===b.href},fn:function(a,b){return b.$el.removeClass("active"),!0}},{name:"standard",isSupported:function(a,b){return b.hash&&"#"!==b.hash},fn:function(a){return function(b,c){var d;return d=m(c.$el),c.$el.addClass("active"),a.goTo($(c.hash).data("referrer",c.$el),d,c.$el.hasClass("reverse")),!1}}(this)},{name:"external",isSupported:function(){return!0},fn:function(a,b){var c;return c=m(b.$el),b.$el.addClass("loading active"),u(b.$el.attr("href"),{animation:c,callback:function(){return b.$el.removeClass("loading"),setTimeout(function(){return b.$el.removeClass("active")},250)},$referrer:b.$el}),!1}}]),this.goTo=function(a){return function(a,b){var c,d,g,h,i;if(d=f[0].page,"string"==typeof b)for(h=0,i=e.length;i>h;h++)if(c=e[h],c.name===b){b=c;break}if("string"==typeof a){if(g=$(a),!g.length)return void u(a,{animation:b});a=g}return l(d,a,b)?void 0:(console.warn("Could not animate pages."),!1)}}(this),this.goBack=function(a){return function(a){var b,c,d,e,g,h,i;if(f.length<1&&console.warn("History is empty."),1===f.length&&(console.warn("You are on the first panel."),window.history.go(-1)),"number"==typeof a)a>0?f.splice(1,a):0>a&&f.splice(1,f.length+a-1);else if(/^#.+/.test(a)){for(b=0,e=h=0,i=f.length;i>h;e=++h)if(d=f[e],d.hash===a){b=e;break}f.splice(1,b-1)}return c=f[0],g=f[1],null!=c&&null!=g?l(c.page,g.page,c.animation,!0)?void 0:(console.warn("Could not go back."),!1):void 0}}(this),this.history=f,o=function(a){return function(){var b,c,e,f,g,h,i;for(i=a.settings.preloadImages,g=0,h=i.length;h>g;g++)c=i[g],(new Image).src=a.settings.preloadImages[c];return b=[],e=a.settings.addGlossToIcon?"":"-precomposed",a.settings.icon&&b.push('<link rel="apple-touch-icon'+e+'" href="'+a.settings.icon+'">'),a.settings.icon4&&b.push('<link rel="apple-touch-icon'+e+'" sizes="114x114" href="'+a.settings.icon4+'">'),a.settings.startupScreen&&b.push('<link rel="apple-touch-startup-image" href="'+a.settings.startupScreen+'">'),f=[],a.settings.fixedViewport&&f.push("initial-scale=1.0","maximum-scale=1.0","user-scalable=0"),a.settings.minimalUIViewport&&f.push("minimal-ui"),f&&b.push('<meta name="viewport" content="'+f.join(", ")+'">'),a.settings.fullScreen&&(b.push('<meta name="apple-mobile-web-app-capable" content="yes" />'),a.settings.statusBar&&b.push('<meta name="apple-mobile-web-app-status-bar-style" content="'+a.settings.statusBar+'">')),b.length?d.prepend(b.join("")):void 0}}(this),p=function(a){return function(c,d){var e;return e=null,$(c).each(function(){var a;return a=$(this),a.attr("id")||a.attr("id","page-"+ ++g),$("#"+a.attr("id")).remove(),b.append(a),b.trigger("pageInserted",{page:a}),a.hasClass("current")||!e?e=a:void 0}),null==e?!1:void a.goTo(e,d)}}(this),j=function(a,b){var c;return c=a.attr("id"),f.unshift({page:a,animation:b,hash:"#"+c,id:c})},k=function(){return function(a){var b;b=$(a.target),b.is(i.join(", "))||(b=b.closest(i.join(", "))),b&&b.attr("href")&&!q(b)?(console.warn("Need to prevent default click behavior."),a.preventDefault()):console.warn("No need to prevent default click behavior."),y.touch||(console.warn("Converting click event to a tap event because touch handlers are not present or off."),$(a.target).trigger("tap",a))}}(this),n=function(a){return function(){return location.hash===f[0].hash?(console.log("We are on the right panel."),!0):""===location.hash?(a.goBack(),!0):f[1]&&location.hash===f[1].hash?(a.goBack(),!0):(console.warn("Could not find ID in history, just forwarding to DOM element."),void a.goTo($(location.hash),a.settings.defaultAnimation))}}(this),q=function(a){return"_blank"===a.attr("target")||"external"===a.attr("rel")||a.is('a[href^="http://maps.google.com"], a[href^="mailto:"], a[href^="tel:"], a[href^="javascript:"], a[href*="youtube.com/v"], a[href*="youtube.com/watch"]')},m=function(a){return function(b){var c,d,f,g;for(f=0,g=e.length;g>f;f++)if(c=e[f],b.is(c.selector)){d=c;break}return d||(console.warn("Animation could not be found. Using "+a.settings.defaultAnimation+"."),d=a.settings.defaultAnimation),d}}(this),u=function(a){return function(b,c){return c=$.extend({},{data:null,method:"GET",animation:null,$referrer:null},c),"#"!==b.charAt(0)?$.ajax({url:b,data:c.data,type:c.method,success:function(b){var d;return d=p(b,c.animation),d&&"GET"===c.method&&a.settings.cacheGetRequests===!0&&c.$referrer?c.$referrer.attr("href","#"+d.attr("id")):void 0},error:function(){return c.$referrer?c.$referrer.removeClass("active"):void 0}}):c.$referrer?c.$referrer.removeClass("active"):void 0}}(this),y=void 0,v=function(a){return function(){var e,f,g,h,l,m,o;for(y=$.support||{},$.extend(y,{animationEvents:"undefined"!=typeof window.WebKitAnimationEvent,touch:"undefined"!=typeof window.TouchEvent&&window.navigator.userAgent.indexOf("Mobile")>-1&&a.settings.useFastTouch,transform3d:function(){var a,b,c,e,f;return c=d.get(0),a=document.body,f=document.createElement("style"),f.textContent="@media (transform-3d),(-o-transform-3d),(-moz-transform-3d),(-webkit-transform-3d){#jqt-3dtest{height:3px}}",b=document.createElement("div"),b.id="jqt-3dtest",c.appendChild(f),a.appendChild(b),e=3===b.offsetHeight,f.parentNode.removeChild(f),b.parentNode.removeChild(b),console.warn("Support for 3d transforms: "+e+"."),e}}),y.touch||console.warn("This device does not support touch interaction, or it has been deactivated by the developer. Some features might be unavailable."),y.transform3d||console.warn("This device does not support 3d animation. 2d animations will be used instead."),o=a.extensions,l=0,m=o.length;m>l;l++)g=o[l],$.isFunction(g)&&$.extend(a,g(a));return i.push(a.settings.touchSelector.concat(a.settings.backSelector,a.settings.submitSelector)),e=$(i.join(", ")).css("-webkit-touch-callout","none"),b=$("#jqt"),f=[],b.length||(console.warn('Could not find an element with the id “jqt”, so the body id has been set to "jqt". If you are having any problems, wrapping your panels in a div with the id “jqt” might help.'),b=$(document.body).attr("id","jqt")),y.transform3d&&f.push("supports3d"),f.push(a.settings.useTouchScroll?"touchscroll":"autoscroll"),a.settings.fullScreenClass&&window.navigator.standalone&&f.push(a.settings.fullScreenClass,a.settings.statusBar),b.addClass(f.join(" ")).on("click",k).on("orientationchange",r).on("submit",w).on("tap",z).on(y.touch?"touchstart":"mousedown",A).trigger("orientationchange"),a.settings.updateHash&&$(window).on("hashchange",n),h=location.hash,c=$("#jqt > .current").length?$("#jqt > .current"):$("#jqt > *:first-child").addClass("current"),t(c.attr("id")),j(c),a.settings.updateHash&&$(h).length?a.goTo(h):void 0}}(this),r=function(){var a;return scrollTo(0,0),a=90===Math.abs(window.orientation)?"landscape":"portrait",b.removeClass("portrait landscape").addClass(a).trigger("turn",{orientation:a})},s=function(a){var b;return b={up:"down",down:"up",left:"right",right:"left","in":"out",out:"in"},b[a]||a},t=function(a){return function(b){return a.settings.updateHash?location.hash="#"+b.replace(/^#/,""):void 0}}(this),w=function(a){return function(b,c){var d;return $(":focus").trigger("blur"),d="string"==typeof b?$(b).eq(0):$(b.target?b.target:b),d.length&&d.is(a.settings.formSelector)&&d.attr("action")?(b.preventDefault(),u(d.attr("action"),{data:d.serialize(),method:d.attr("method")||"POST",animation:m(d),callback:c})):void 0}}(this),x=function(a){var b;return b=a.closest("form"),b.length?(console.warn("About to submit parent form."),b.trigger("submit"),!1):(console.warn("No parent form found."),!0)},z=function(a){return function(b){var c,d,e,f,g,h,j,k,l,m,n;if(b.isDefaultPrevented())return!0;if(c=$(b.target),j=i.join(","),c.is(j)||(c=c.closest(j)),!c.length||!c.attr("href"))return console.warn("Could not find a link related to tapped element."),!0;for(k=c.attr("target"),f=c.prop("hash"),g=c.attr("href"),h={e:b,$el:c,target:k,hash:f,href:g},n=a.tapHandlers,l=0,m=n.length;m>l;l++)if(e=n[l],e.isSupported(b,h))return d=e.fn(b,h)}}(this),A=function(a){var b,c;return b=$(a.target),c=i.join(", "),b.is(c)||(b=b.closest(c)),b.length&&b.attr("href")&&b.addClass("active"),b.on(y.touch?"touchmove":"mousemove",function(){return b.removeClass("active")}),b.on("touchend",function(){return b.off("touchend mouseup"),b.off("touchmove mousemove")})},l=function(a){return function(d,e,g,i){var k,l,m;return null==i&&(i=!1),m=function(){return y.animationEvents&&g&&a.settings.useAnimations?(d.off("webkitAnimationEnd",m),d.removeClass(k+" out"),k&&e.removeClass(k),b.removeClass("animating animating3d")):(d.removeClass(k+" out"),k&&e.removeClass(k)),setTimeout(function(){return e.removeClass("in"),window.scroll(0,0)},h),d.find(".active").removeClass("active"),e.trigger("pageAnimationEnd",{direction:"in",animation:g,back:i}),d.trigger("pageAnimationEnd",{direction:"out",animation:g,back:i})},e.length?e.hasClass("current")?($(".active").removeClass("active"),console.warn("You are already on the page you are trying to navigate to."),!1):($(":focus").trigger("blur"),d.trigger("pageAnimationStart",{direction:"out",back:i}),e.trigger("pageAnimationStart",{direction:"in",back:i}),y.animationEvents&&g&&a.settings.useAnimations?(k=g.name,l=g.is3d?" animating3d":"",!y.transform3d&&g.is3d&&(console.warn("Did not detect support for 3d animations, falling back to "+a.settings.defaultAnimation+"."),k=a.settings.defaultAnimation,l=""),i&&(k=k.replace(/left|right|up|down|in|out/,s)),null==k&&(k=a.settings.defaultAnimation),console.warn("finalAnimationName:",k),d.on("webkitAnimationEnd",m),b.addClass("animating"+l),e.addClass(k+" in current"),d.removeClass("current").addClass(k+" out")):(e.addClass("current in"),d.removeClass("current"),m()),c=e,i?f.shift():j(c,g),t(c.attr("id")),!0):($(".active").removeClass("active"),console.warn("Target element is missing."),!1)}}(this),this.settings=$.extend({},this.defaults,a),o(),this.settings.starter(v)}var b,c,d,e,f,g,h,i;return a.prototype.extensions=[],a.prototype.animations=[{name:"cubeleft",selector:".cubeleft, .cube",is3d:!0},{name:"cuberight",selector:".cuberight",is3d:!0},{name:"dissolve",selector:".dissolve"},{name:"fade",selector:".fade"},{name:"flipleft",selector:".flipleft, .flip",is3d:!0},{name:"flipright",selector:".flipright",is3d:!0},{name:"pop",selector:".pop",is3d:!0},{name:"swapleft",selector:".swapleft, .swap",is3d:!0},{name:"swapright",selector:".swapright",is3d:!0},{name:"slidedown",selector:".slidedown"},{name:"slideright",selector:".slideright"},{name:"slideup",selector:".slideup"},{name:"slideleft",selector:".slideleft, .slide, #jqt > * > ul li a"}],a.prototype.orientation="portrait",a.prototype.tapHandlers=[],a.prototype.defaults={addGlossToIcon:!0,backSelector:".back, .cancel, .goback",cacheGetRequests:!0,defaultAnimation:"slideleft",fixedViewport:!0,formSelector:"form",fullScreen:!0,fullScreenClass:"fullscreen",icon:null,icon4:null,minimalUIViewport:!0,preloadImages:!1,starter:$(document).ready,startupScreen:null,statusBar:"default",submitSelector:".submit",touchSelector:"a, .touch",updateHash:!0,useAnimations:!0,useFastTouch:!0,useTouchScroll:!0},a.addExtension=function(a){return this.prototype.extensions.push(a)},a.addTapHandler=function(a){return"string"==typeof a.name&&"function"==typeof a.isSupported&&"function"==typeof a.fn?this.prototype.tapHandlers.push(a):void 0},a.addAnimation=function(a){return"string"==typeof a.selector&&"string"==typeof a.name?this.animations.push(a):void 0},b=void 0,d=$("head"),e=a.prototype.animations,f=[],g=0,c="",i=[],h=100,a}(),$.jQTouch=$.jQT}).call(this);

      /* https://github.com/MoonScript/jQuery-ajaxTransport-XDomainRequest */ 
      !function(t){if(t.support.cors||!t.ajaxTransport||!window.XDomainRequest)return t;var e=/^(https?:)?\/\//i,n=/^get|post$/i,o=new RegExp("^(//|"+location.protocol+")","i");return t.ajaxTransport("* text html xml json",function(r,s){if(r.crossDomain&&r.async&&n.test(r.type)&&e.test(r.url)&&o.test(r.url)){var a=null;return{send:function(e,n){var o="",i=(s.dataType||"").toLowerCase();a=new XDomainRequest,/^\d+$/.test(s.timeout)&&(a.timeout=s.timeout),a.ontimeout=function(){n(500,"timeout")},a.onload=function(){var e="Content-Length: "+a.responseText.length+"\r\nContent-Type: "+a.contentType,o={code:200,message:"success"},r={text:a.responseText};try{if("html"===i||/text\/html/i.test(a.contentType))r.html=a.responseText;else if("json"===i||"text"!==i&&/\/json/i.test(a.contentType))try{r.json=t.parseJSON(a.responseText)}catch(s){o.code=500,o.message="parseerror"}else if("xml"===i||"text"!==i&&/\/xml/i.test(a.contentType)){var c=new ActiveXObject("Microsoft.XMLDOM");c.async=!1;try{c.loadXML(a.responseText)}catch(s){c=void 0}if(!c||!c.documentElement||c.getElementsByTagName("parsererror").length)throw o.code=500,o.message="parseerror","Invalid XML: "+a.responseText;r.xml=c}}catch(p){throw p}finally{n(o.code,o.message,r,e)}},a.onprogress=function(){},a.onerror=function(){n(500,"error",{text:a.responseText})},s.data&&(o="string"===t.type(s.data)?s.data:t.param(s.data)),a.open(r.type,r.url),a.send(o)},abort:function(){a&&a.abort()}}}}),t}($);

      // JQuery Upload
      /*
 * jQuery File Upload Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, require */
/* eslint-disable new-cap */


  'use strict';

  // Detect file input support, based on
  // https://viljamis.com/2012/file-upload-support-on-mobile/
  $.support.fileInput = !(
    new RegExp(
      // Handle devices which give false positives for the feature detection:
      '(Android (1\\.[0156]|2\\.[01]))' +
        '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
        '|(w(eb)?OSBrowser)|(webOS)' +
        '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
    // Feature detection for all other devices:
    $('<input type="file"/>').prop('disabled')
  );

  // The FileReader API is not actually used, but works as feature detection,
  // as some Safari versions (5?) support XHR file uploads via the FormData API,
  // but not non-multipart XHR file uploads.
  // window.XMLHttpRequestUpload is not available on IE10, so we check for
  // window.ProgressEvent instead to detect XHR2 file upload capability:
  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
  $.support.xhrFormDataFileUpload = !!window.FormData;

  // Detect support for Blob slicing (required for chunked uploads):
  $.support.blobSlice =
    window.Blob &&
    (Blob.prototype.slice ||
      Blob.prototype.webkitSlice ||
      Blob.prototype.mozSlice);

  /**
   * Helper function to create drag handlers for dragover/dragenter/dragleave
   *
   * @param {string} type Event type
   * @returns {Function} Drag handler
   */
  function getDragHandler(type) {
    var isDragOver = type === 'dragover';
    return function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var dataTransfer = e.dataTransfer;
      if (
        dataTransfer &&
        $.inArray('Files', dataTransfer.types) !== -1 &&
        this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false
      ) {
        e.preventDefault();
        if (isDragOver) {
          dataTransfer.dropEffect = 'copy';
        }
      }
    };
  }

  // The fileupload widget listens for change events on file input fields defined
  // via fileInput setting and paste or drop events of the given dropZone.
  // In addition to the default jQuery Widget methods, the fileupload widget
  // exposes the "add" and "send" methods, to add or directly send files using
  // the fileupload API.
  // By default, files added via file input selection, paste, drag & drop or
  // "add" method are uploaded immediately, but it is possible to override
  // the "add" callback option to queue file uploads.
  $.widget('blueimp.fileupload', {
    options: {
      // The drop target element(s), by the default the complete document.
      // Set to null to disable drag & drop support:
      dropZone: $(document),
      // The paste target element(s), by the default undefined.
      // Set to a DOM node or jQuery object to enable file pasting:
      pasteZone: undefined,
      // The file input field(s), that are listened to for change events.
      // If undefined, it is set to the file input fields inside
      // of the widget element on plugin initialization.
      // Set to null to disable the change listener.
      fileInput: undefined,
      // By default, the file input field is replaced with a clone after
      // each input field change event. This is required for iframe transport
      // queues and allows change events to be fired for the same file
      // selection, but can be disabled by setting the following option to false:
      replaceFileInput: true,
      // The parameter name for the file form data (the request argument name).
      // If undefined or empty, the name property of the file input field is
      // used, or "files[]" if the file input name property is also empty,
      // can be a string or an array of strings:
      paramName: undefined,
      // By default, each file of a selection is uploaded using an individual
      // request for XHR type uploads. Set to false to upload file
      // selections in one request each:
      singleFileUploads: true,
      // To limit the number of files uploaded with one XHR request,
      // set the following option to an integer greater than 0:
      limitMultiFileUploads: undefined,
      // The following option limits the number of files uploaded with one
      // XHR request to keep the request size under or equal to the defined
      // limit in bytes:
      limitMultiFileUploadSize: undefined,
      // Multipart file uploads add a number of bytes to each uploaded file,
      // therefore the following option adds an overhead for each file used
      // in the limitMultiFileUploadSize configuration:
      limitMultiFileUploadSizeOverhead: 512,
      // Set the following option to true to issue all file upload requests
      // in a sequential order:
      sequentialUploads: false,
      // To limit the number of concurrent uploads,
      // set the following option to an integer greater than 0:
      limitConcurrentUploads: undefined,
      // Set the following option to true to force iframe transport uploads:
      forceIframeTransport: false,
      // Set the following option to the location of a redirect url on the
      // origin server, for cross-domain iframe transport uploads:
      redirect: undefined,
      // The parameter name for the redirect url, sent as part of the form
      // data and set to 'redirect' if this option is empty:
      redirectParamName: undefined,
      // Set the following option to the location of a postMessage window,
      // to enable postMessage transport uploads:
      postMessage: undefined,
      // By default, XHR file uploads are sent as multipart/form-data.
      // The iframe transport is always using multipart/form-data.
      // Set to false to enable non-multipart XHR uploads:
      multipart: true,
      // To upload large files in smaller chunks, set the following option
      // to a preferred maximum chunk size. If set to 0, null or undefined,
      // or the browser does not support the required Blob API, files will
      // be uploaded as a whole.
      maxChunkSize: undefined,
      // When a non-multipart upload or a chunked multipart upload has been
      // aborted, this option can be used to resume the upload by setting
      // it to the size of the already uploaded bytes. This option is most
      // useful when modifying the options object inside of the "add" or
      // "send" callbacks, as the options are cloned for each file upload.
      uploadedBytes: undefined,
      // By default, failed (abort or error) file uploads are removed from the
      // global progress calculation. Set the following option to false to
      // prevent recalculating the global progress data:
      recalculateProgress: true,
      // Interval in milliseconds to calculate and trigger progress events:
      progressInterval: 100,
      // Interval in milliseconds to calculate progress bitrate:
      bitrateInterval: 500,
      // By default, uploads are started automatically when adding files:
      autoUpload: true,
      // By default, duplicate file names are expected to be handled on
      // the server-side. If this is not possible (e.g. when uploading
      // files directly to Amazon S3), the following option can be set to
      // an empty object or an object mapping existing filenames, e.g.:
      // { "image.jpg": true, "image (1).jpg": true }
      // If it is set, all files will be uploaded with unique filenames,
      // adding increasing number suffixes if necessary, e.g.:
      // "image (2).jpg"
      uniqueFilenames: undefined,

      // Error and info messages:
      messages: {
        uploadedBytes: 'Uploaded bytes exceed file size'
      },

      // Translation function, gets the message key to be translated
      // and an object with context specific data as arguments:
      i18n: function (message, context) {
        // eslint-disable-next-line no-param-reassign
        message = this.messages[message] || message.toString();
        if (context) {
          $.each(context, function (key, value) {
            // eslint-disable-next-line no-param-reassign
            message = message.replace('{' + key + '}', value);
          });
        }
        return message;
      },

      // Additional form data to be sent along with the file uploads can be set
      // using this option, which accepts an array of objects with name and
      // value properties, a function returning such an array, a FormData
      // object (for XHR file uploads), or a simple object.
      // The form of the first fileInput is given as parameter to the function:
      formData: function (form) {
        return form.serializeArray();
      },

      // The add callback is invoked as soon as files are added to the fileupload
      // widget (via file input selection, drag & drop, paste or add API call).
      // If the singleFileUploads option is enabled, this callback will be
      // called once for each file in the selection for XHR file uploads, else
      // once for each file selection.
      //
      // The upload starts when the submit method is invoked on the data parameter.
      // The data object contains a files property holding the added files
      // and allows you to override plugin options as well as define ajax settings.
      //
      // Listeners for this callback can also be bound the following way:
      // .on('fileuploadadd', func);
      //
      // data.submit() returns a Promise object and allows to attach additional
      // handlers using jQuery's Deferred callbacks:
      // data.submit().done(func).fail(func).always(func);
      add: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        if (
          data.autoUpload ||
          (data.autoUpload !== false &&
            $(this).fileupload('option', 'autoUpload'))
        ) {
          data.process().done(function () {
            data.submit();
          });
        }
      },

      // Other callbacks:

      // Callback for the submit event of each file upload:
      // submit: function (e, data) {}, // .on('fileuploadsubmit', func);

      // Callback for the start of each file upload request:
      // send: function (e, data) {}, // .on('fileuploadsend', func);

      // Callback for successful uploads:
      // done: function (e, data) {}, // .on('fileuploaddone', func);

      // Callback for failed (abort or error) uploads:
      // fail: function (e, data) {}, // .on('fileuploadfail', func);

      // Callback for completed (success, abort or error) requests:
      // always: function (e, data) {}, // .on('fileuploadalways', func);

      // Callback for upload progress events:
      // progress: function (e, data) {}, // .on('fileuploadprogress', func);

      // Callback for global upload progress events:
      // progressall: function (e, data) {}, // .on('fileuploadprogressall', func);

      // Callback for uploads start, equivalent to the global ajaxStart event:
      // start: function (e) {}, // .on('fileuploadstart', func);

      // Callback for uploads stop, equivalent to the global ajaxStop event:
      // stop: function (e) {}, // .on('fileuploadstop', func);

      // Callback for change events of the fileInput(s):
      // change: function (e, data) {}, // .on('fileuploadchange', func);

      // Callback for paste events to the pasteZone(s):
      // paste: function (e, data) {}, // .on('fileuploadpaste', func);

      // Callback for drop events of the dropZone(s):
      // drop: function (e, data) {}, // .on('fileuploaddrop', func);

      // Callback for dragover events of the dropZone(s):
      // dragover: function (e) {}, // .on('fileuploaddragover', func);

      // Callback before the start of each chunk upload request (before form data initialization):
      // chunkbeforesend: function (e, data) {}, // .on('fileuploadchunkbeforesend', func);

      // Callback for the start of each chunk upload request:
      // chunksend: function (e, data) {}, // .on('fileuploadchunksend', func);

      // Callback for successful chunk uploads:
      // chunkdone: function (e, data) {}, // .on('fileuploadchunkdone', func);

      // Callback for failed (abort or error) chunk uploads:
      // chunkfail: function (e, data) {}, // .on('fileuploadchunkfail', func);

      // Callback for completed (success, abort or error) chunk upload requests:
      // chunkalways: function (e, data) {}, // .on('fileuploadchunkalways', func);

      // The plugin options are used as settings object for the ajax calls.
      // The following are jQuery ajax settings required for the file uploads:
      processData: false,
      contentType: false,
      cache: false,
      timeout: 0
    },

    // jQuery versions before 1.8 require promise.pipe if the return value is
    // used, as promise.then in older versions has a different behavior, see:
    // https://blog.jquery.com/2012/08/09/jquery-1-8-released/
    // https://bugs.jquery.com/ticket/11010
    // https://github.com/blueimp/jQuery-File-Upload/pull/3435
    _promisePipe: (function () {
      var parts = $.fn.jquery.split('.');
      return Number(parts[0]) > 1 || Number(parts[1]) > 7 ? 'then' : 'pipe';
    })(),

    // A list of options that require reinitializing event listeners and/or
    // special initialization code:
    _specialOptions: [
      'fileInput',
      'dropZone',
      'pasteZone',
      'multipart',
      'forceIframeTransport'
    ],

    _blobSlice:
      $.support.blobSlice &&
      function () {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
      },

    _BitrateTimer: function () {
      this.timestamp = Date.now ? Date.now() : new Date().getTime();
      this.loaded = 0;
      this.bitrate = 0;
      this.getBitrate = function (now, loaded, interval) {
        var timeDiff = now - this.timestamp;
        if (!this.bitrate || !interval || timeDiff > interval) {
          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
          this.loaded = loaded;
          this.timestamp = now;
        }
        return this.bitrate;
      };
    },

    _isXHRUpload: function (options) {
      return (
        !options.forceIframeTransport &&
        ((!options.multipart && $.support.xhrFileUpload) ||
          $.support.xhrFormDataFileUpload)
      );
    },

    _getFormData: function (options) {
      var formData;
      if ($.type(options.formData) === 'function') {
        return options.formData(options.form);
      }
      if ($.isArray(options.formData)) {
        return options.formData;
      }
      if ($.type(options.formData) === 'object') {
        formData = [];
        $.each(options.formData, function (name, value) {
          formData.push({ name: name, value: value });
        });
        return formData;
      }
      return [];
    },

    _getTotal: function (files) {
      var total = 0;
      $.each(files, function (index, file) {
        total += file.size || 1;
      });
      return total;
    },

    _initProgressObject: function (obj) {
      var progress = {
        loaded: 0,
        total: 0,
        bitrate: 0
      };
      if (obj._progress) {
        $.extend(obj._progress, progress);
      } else {
        obj._progress = progress;
      }
    },

    _initResponseObject: function (obj) {
      var prop;
      if (obj._response) {
        for (prop in obj._response) {
          if (Object.prototype.hasOwnProperty.call(obj._response, prop)) {
            delete obj._response[prop];
          }
        }
      } else {
        obj._response = {};
      }
    },

    _onProgress: function (e, data) {
      if (e.lengthComputable) {
        var now = Date.now ? Date.now() : new Date().getTime(),
          loaded;
        if (
          data._time &&
          data.progressInterval &&
          now - data._time < data.progressInterval &&
          e.loaded !== e.total
        ) {
          return;
        }
        data._time = now;
        loaded =
          Math.floor(
            (e.loaded / e.total) * (data.chunkSize || data._progress.total)
          ) + (data.uploadedBytes || 0);
        // Add the difference from the previously loaded state
        // to the global loaded counter:
        this._progress.loaded += loaded - data._progress.loaded;
        this._progress.bitrate = this._bitrateTimer.getBitrate(
          now,
          this._progress.loaded,
          data.bitrateInterval
        );
        data._progress.loaded = data.loaded = loaded;
        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
          now,
          loaded,
          data.bitrateInterval
        );
        // Trigger a custom progress event with a total data property set
        // to the file size(s) of the current upload and a loaded data
        // property calculated accordingly:
        this._trigger(
          'progress',
          $.Event('progress', { delegatedEvent: e }),
          data
        );
        // Trigger a global progress event for all current file uploads,
        // including ajax calls queued for sequential file uploads:
        this._trigger(
          'progressall',
          $.Event('progressall', { delegatedEvent: e }),
          this._progress
        );
      }
    },

    _initProgressListener: function (options) {
      var that = this,
        xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      // Accesss to the native XHR object is required to add event listeners
      // for the upload progress event:
      if (xhr.upload) {
        $(xhr.upload).on('progress', function (e) {
          var oe = e.originalEvent;
          // Make sure the progress event properties get copied over:
          e.lengthComputable = oe.lengthComputable;
          e.loaded = oe.loaded;
          e.total = oe.total;
          that._onProgress(e, options);
        });
        options.xhr = function () {
          return xhr;
        };
      }
    },

    _deinitProgressListener: function (options) {
      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      if (xhr.upload) {
        $(xhr.upload).off('progress');
      }
    },

    _isInstanceOf: function (type, obj) {
      // Cross-frame instanceof check
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    },

    _getUniqueFilename: function (name, map) {
      // eslint-disable-next-line no-param-reassign
      name = String(name);
      if (map[name]) {
        // eslint-disable-next-line no-param-reassign
        name = name.replace(/(?: \(([\d]+)\))?(\.[^.]+)?$/, function (
          _,
          p1,
          p2
        ) {
          var index = p1 ? Number(p1) + 1 : 1;
          var ext = p2 || '';
          return ' (' + index + ')' + ext;
        });
        return this._getUniqueFilename(name, map);
      }
      map[name] = true;
      return name;
    },

    _initXHRData: function (options) {
      var that = this,
        formData,
        file = options.files[0],
        // Ignore non-multipart setting if not supported:
        multipart = options.multipart || !$.support.xhrFileUpload,
        paramName =
          $.type(options.paramName) === 'array'
            ? options.paramName[0]
            : options.paramName;
      options.headers = $.extend({}, options.headers);
      if (options.contentRange) {
        options.headers['Content-Range'] = options.contentRange;
      }
      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
        options.headers['Content-Disposition'] =
          'attachment; filename="' +
          encodeURI(file.uploadName || file.name) +
          '"';
      }
      if (!multipart) {
        options.contentType = file.type || 'application/octet-stream';
        options.data = options.blob || file;
      } else if ($.support.xhrFormDataFileUpload) {
        if (options.postMessage) {
          // window.postMessage does not allow sending FormData
          // objects, so we just add the File/Blob objects to
          // the formData array and let the postMessage window
          // create the FormData object out of this array:
          formData = this._getFormData(options);
          if (options.blob) {
            formData.push({
              name: paramName,
              value: options.blob
            });
          } else {
            $.each(options.files, function (index, file) {
              formData.push({
                name:
                  ($.type(options.paramName) === 'array' &&
                    options.paramName[index]) ||
                  paramName,
                value: file
              });
            });
          }
        } else {
          if (that._isInstanceOf('FormData', options.formData)) {
            formData = options.formData;
          } else {
            formData = new FormData();
            $.each(this._getFormData(options), function (index, field) {
              formData.append(field.name, field.value);
            });
          }
          if (options.blob) {
            formData.append(
              paramName,
              options.blob,
              file.uploadName || file.name
            );
          } else {
            $.each(options.files, function (index, file) {
              // This check allows the tests to run with
              // dummy objects:
              if (
                that._isInstanceOf('File', file) ||
                that._isInstanceOf('Blob', file)
              ) {
                var fileName = file.uploadName || file.name;
                if (options.uniqueFilenames) {
                  fileName = that._getUniqueFilename(
                    fileName,
                    options.uniqueFilenames
                  );
                }
                formData.append(
                  ($.type(options.paramName) === 'array' &&
                    options.paramName[index]) ||
                    paramName,
                  file,
                  fileName
                );
              }
            });
          }
        }
        options.data = formData;
      }
      // Blob reference is not needed anymore, free memory:
      options.blob = null;
    },

    _initIframeSettings: function (options) {
      var targetHost = $('<a></a>').prop('href', options.url).prop('host');
      // Setting the dataType to iframe enables the iframe transport:
      options.dataType = 'iframe ' + (options.dataType || '');
      // The iframe transport accepts a serialized array as form data:
      options.formData = this._getFormData(options);
      // Add redirect url to form data on cross-domain uploads:
      if (options.redirect && targetHost && targetHost !== location.host) {
        options.formData.push({
          name: options.redirectParamName || 'redirect',
          value: options.redirect
        });
      }
    },

    _initDataSettings: function (options) {
      if (this._isXHRUpload(options)) {
        if (!this._chunkedUpload(options, true)) {
          if (!options.data) {
            this._initXHRData(options);
          }
          this._initProgressListener(options);
        }
        if (options.postMessage) {
          // Setting the dataType to postmessage enables the
          // postMessage transport:
          options.dataType = 'postmessage ' + (options.dataType || '');
        }
      } else {
        this._initIframeSettings(options);
      }
    },

    _getParamName: function (options) {
      var fileInput = $(options.fileInput),
        paramName = options.paramName;
      if (!paramName) {
        paramName = [];
        fileInput.each(function () {
          var input = $(this),
            name = input.prop('name') || 'files[]',
            i = (input.prop('files') || [1]).length;
          while (i) {
            paramName.push(name);
            i -= 1;
          }
        });
        if (!paramName.length) {
          paramName = [fileInput.prop('name') || 'files[]'];
        }
      } else if (!$.isArray(paramName)) {
        paramName = [paramName];
      }
      return paramName;
    },

    _initFormSettings: function (options) {
      // Retrieve missing options from the input field and the
      // associated form, if available:
      if (!options.form || !options.form.length) {
        options.form = $(options.fileInput.prop('form'));
        // If the given file input doesn't have an associated form,
        // use the default widget file input's form:
        if (!options.form.length) {
          options.form = $(this.options.fileInput.prop('form'));
        }
      }
      options.paramName = this._getParamName(options);
      if (!options.url) {
        options.url = options.form.prop('action') || location.href;
      }
      // The HTTP request method must be "POST" or "PUT":
      options.type = (
        options.type ||
        ($.type(options.form.prop('method')) === 'string' &&
          options.form.prop('method')) ||
        ''
      ).toUpperCase();
      if (
        options.type !== 'POST' &&
        options.type !== 'PUT' &&
        options.type !== 'PATCH'
      ) {
        options.type = 'POST';
      }
      if (!options.formAcceptCharset) {
        options.formAcceptCharset = options.form.attr('accept-charset');
      }
    },

    _getAJAXSettings: function (data) {
      var options = $.extend({}, this.options, data);
      this._initFormSettings(options);
      this._initDataSettings(options);
      return options;
    },

    // jQuery 1.6 doesn't provide .state(),
    // while jQuery 1.8+ removed .isRejected() and .isResolved():
    _getDeferredState: function (deferred) {
      if (deferred.state) {
        return deferred.state();
      }
      if (deferred.isResolved()) {
        return 'resolved';
      }
      if (deferred.isRejected()) {
        return 'rejected';
      }
      return 'pending';
    },

    // Maps jqXHR callbacks to the equivalent
    // methods of the given Promise object:
    _enhancePromise: function (promise) {
      promise.success = promise.done;
      promise.error = promise.fail;
      promise.complete = promise.always;
      return promise;
    },

    // Creates and returns a Promise object enhanced with
    // the jqXHR methods abort, success, error and complete:
    _getXHRPromise: function (resolveOrReject, context, args) {
      var dfd = $.Deferred(),
        promise = dfd.promise();
      // eslint-disable-next-line no-param-reassign
      context = context || this.options.context || promise;
      if (resolveOrReject === true) {
        dfd.resolveWith(context, args);
      } else if (resolveOrReject === false) {
        dfd.rejectWith(context, args);
      }
      promise.abort = dfd.promise;
      return this._enhancePromise(promise);
    },

    // Adds convenience methods to the data callback argument:
    _addConvenienceMethods: function (e, data) {
      var that = this,
        getPromise = function (args) {
          return $.Deferred().resolveWith(that, args).promise();
        };
      data.process = function (resolveFunc, rejectFunc) {
        if (resolveFunc || rejectFunc) {
          data._processQueue = this._processQueue = (this._processQueue ||
            getPromise([this]))
            [that._promisePipe](function () {
              if (data.errorThrown) {
                return $.Deferred().rejectWith(that, [data]).promise();
              }
              return getPromise(arguments);
            })
            [that._promisePipe](resolveFunc, rejectFunc);
        }
        return this._processQueue || getPromise([this]);
      };
      data.submit = function () {
        if (this.state() !== 'pending') {
          data.jqXHR = this.jqXHR =
            that._trigger(
              'submit',
              $.Event('submit', { delegatedEvent: e }),
              this
            ) !== false && that._onSend(e, this);
        }
        return this.jqXHR || that._getXHRPromise();
      };
      data.abort = function () {
        if (this.jqXHR) {
          return this.jqXHR.abort();
        }
        this.errorThrown = 'abort';
        that._trigger('fail', null, this);
        return that._getXHRPromise(false);
      };
      data.state = function () {
        if (this.jqXHR) {
          return that._getDeferredState(this.jqXHR);
        }
        if (this._processQueue) {
          return that._getDeferredState(this._processQueue);
        }
      };
      data.processing = function () {
        return (
          !this.jqXHR &&
          this._processQueue &&
          that._getDeferredState(this._processQueue) === 'pending'
        );
      };
      data.progress = function () {
        return this._progress;
      };
      data.response = function () {
        return this._response;
      };
    },

    // Parses the Range header from the server response
    // and returns the uploaded bytes:
    _getUploadedBytes: function (jqXHR) {
      var range = jqXHR.getResponseHeader('Range'),
        parts = range && range.split('-'),
        upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
      return upperBytesPos && upperBytesPos + 1;
    },

    // Uploads a file in multiple, sequential requests
    // by splitting the file up in multiple blob chunks.
    // If the second parameter is true, only tests if the file
    // should be uploaded in chunks, but does not invoke any
    // upload requests:
    _chunkedUpload: function (options, testOnly) {
      options.uploadedBytes = options.uploadedBytes || 0;
      var that = this,
        file = options.files[0],
        fs = file.size,
        ub = options.uploadedBytes,
        mcs = options.maxChunkSize || fs,
        slice = this._blobSlice,
        dfd = $.Deferred(),
        promise = dfd.promise(),
        jqXHR,
        upload;
      if (
        !(
          this._isXHRUpload(options) &&
          slice &&
          (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)
        ) ||
        options.data
      ) {
        return false;
      }
      if (testOnly) {
        return true;
      }
      if (ub >= fs) {
        file.error = options.i18n('uploadedBytes');
        return this._getXHRPromise(false, options.context, [
          null,
          'error',
          file.error
        ]);
      }
      // The chunk upload method:
      upload = function () {
        // Clone the options object for each chunk upload:
        var o = $.extend({}, options),
          currentLoaded = o._progress.loaded;
        o.blob = slice.call(
          file,
          ub,
          ub + ($.type(mcs) === 'function' ? mcs(o) : mcs),
          file.type
        );
        // Store the current chunk size, as the blob itself
        // will be dereferenced after data processing:
        o.chunkSize = o.blob.size;
        // Expose the chunk bytes position range:
        o.contentRange =
          'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;
        // Trigger chunkbeforesend to allow form data to be updated for this chunk
        that._trigger('chunkbeforesend', null, o);
        // Process the upload data (the blob and potential form data):
        that._initXHRData(o);
        // Add progress listeners for this chunk upload:
        that._initProgressListener(o);
        jqXHR = (
          (that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
          that._getXHRPromise(false, o.context)
        )
          .done(function (result, textStatus, jqXHR) {
            ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
            // Create a progress event if no final progress event
            // with loaded equaling total has been triggered
            // for this chunk:
            if (currentLoaded + o.chunkSize - o._progress.loaded) {
              that._onProgress(
                $.Event('progress', {
                  lengthComputable: true,
                  loaded: ub - o.uploadedBytes,
                  total: ub - o.uploadedBytes
                }),
                o
              );
            }
            options.uploadedBytes = o.uploadedBytes = ub;
            o.result = result;
            o.textStatus = textStatus;
            o.jqXHR = jqXHR;
            that._trigger('chunkdone', null, o);
            that._trigger('chunkalways', null, o);
            if (ub < fs) {
              // File upload not yet complete,
              // continue with the next chunk:
              upload();
            } else {
              dfd.resolveWith(o.context, [result, textStatus, jqXHR]);
            }
          })
          .fail(function (jqXHR, textStatus, errorThrown) {
            o.jqXHR = jqXHR;
            o.textStatus = textStatus;
            o.errorThrown = errorThrown;
            that._trigger('chunkfail', null, o);
            that._trigger('chunkalways', null, o);
            dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);
          })
          .always(function () {
            that._deinitProgressListener(o);
          });
      };
      this._enhancePromise(promise);
      promise.abort = function () {
        return jqXHR.abort();
      };
      upload();
      return promise;
    },

    _beforeSend: function (e, data) {
      if (this._active === 0) {
        // the start callback is triggered when an upload starts
        // and no other uploads are currently running,
        // equivalent to the global ajaxStart event:
        this._trigger('start');
        // Set timer for global bitrate progress calculation:
        this._bitrateTimer = new this._BitrateTimer();
        // Reset the global progress values:
        this._progress.loaded = this._progress.total = 0;
        this._progress.bitrate = 0;
      }
      // Make sure the container objects for the .response() and
      // .progress() methods on the data object are available
      // and reset to their initial state:
      this._initResponseObject(data);
      this._initProgressObject(data);
      data._progress.loaded = data.loaded = data.uploadedBytes || 0;
      data._progress.total = data.total = this._getTotal(data.files) || 1;
      data._progress.bitrate = data.bitrate = 0;
      this._active += 1;
      // Initialize the global progress values:
      this._progress.loaded += data.loaded;
      this._progress.total += data.total;
    },

    _onDone: function (result, textStatus, jqXHR, options) {
      var total = options._progress.total,
        response = options._response;
      if (options._progress.loaded < total) {
        // Create a progress event if no final progress event
        // with loaded equaling total has been triggered:
        this._onProgress(
          $.Event('progress', {
            lengthComputable: true,
            loaded: total,
            total: total
          }),
          options
        );
      }
      response.result = options.result = result;
      response.textStatus = options.textStatus = textStatus;
      response.jqXHR = options.jqXHR = jqXHR;
      this._trigger('done', null, options);
    },

    _onFail: function (jqXHR, textStatus, errorThrown, options) {
      var response = options._response;
      if (options.recalculateProgress) {
        // Remove the failed (error or abort) file upload from
        // the global progress calculation:
        this._progress.loaded -= options._progress.loaded;
        this._progress.total -= options._progress.total;
      }
      response.jqXHR = options.jqXHR = jqXHR;
      response.textStatus = options.textStatus = textStatus;
      response.errorThrown = options.errorThrown = errorThrown;
      this._trigger('fail', null, options);
    },

    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
      // jqXHRorResult, textStatus and jqXHRorError are added to the
      // options object via done and fail callbacks
      this._trigger('always', null, options);
    },

    _onSend: function (e, data) {
      if (!data.submit) {
        this._addConvenienceMethods(e, data);
      }
      var that = this,
        jqXHR,
        aborted,
        slot,
        pipe,
        options = that._getAJAXSettings(data),
        send = function () {
          that._sending += 1;
          // Set timer for bitrate progress calculation:
          options._bitrateTimer = new that._BitrateTimer();
          jqXHR =
            jqXHR ||
            (
              ((aborted ||
                that._trigger(
                  'send',
                  $.Event('send', { delegatedEvent: e }),
                  options
                ) === false) &&
                that._getXHRPromise(false, options.context, aborted)) ||
              that._chunkedUpload(options) ||
              $.ajax(options)
            )
              .done(function (result, textStatus, jqXHR) {
                that._onDone(result, textStatus, jqXHR, options);
              })
              .fail(function (jqXHR, textStatus, errorThrown) {
                that._onFail(jqXHR, textStatus, errorThrown, options);
              })
              .always(function (jqXHRorResult, textStatus, jqXHRorError) {
                that._deinitProgressListener(options);
                that._onAlways(
                  jqXHRorResult,
                  textStatus,
                  jqXHRorError,
                  options
                );
                that._sending -= 1;
                that._active -= 1;
                if (
                  options.limitConcurrentUploads &&
                  options.limitConcurrentUploads > that._sending
                ) {
                  // Start the next queued upload,
                  // that has not been aborted:
                  var nextSlot = that._slots.shift();
                  while (nextSlot) {
                    if (that._getDeferredState(nextSlot) === 'pending') {
                      nextSlot.resolve();
                      break;
                    }
                    nextSlot = that._slots.shift();
                  }
                }
                if (that._active === 0) {
                  // The stop callback is triggered when all uploads have
                  // been completed, equivalent to the global ajaxStop event:
                  that._trigger('stop');
                }
              });
          return jqXHR;
        };
      this._beforeSend(e, options);
      if (
        this.options.sequentialUploads ||
        (this.options.limitConcurrentUploads &&
          this.options.limitConcurrentUploads <= this._sending)
      ) {
        if (this.options.limitConcurrentUploads > 1) {
          slot = $.Deferred();
          this._slots.push(slot);
          pipe = slot[that._promisePipe](send);
        } else {
          this._sequence = this._sequence[that._promisePipe](send, send);
          pipe = this._sequence;
        }
        // Return the piped Promise object, enhanced with an abort method,
        // which is delegated to the jqXHR object of the current upload,
        // and jqXHR callbacks mapped to the equivalent Promise methods:
        pipe.abort = function () {
          aborted = [undefined, 'abort', 'abort'];
          if (!jqXHR) {
            if (slot) {
              slot.rejectWith(options.context, aborted);
            }
            return send();
          }
          return jqXHR.abort();
        };
        return this._enhancePromise(pipe);
      }
      return send();
    },

    _onAdd: function (e, data) {
      var that = this,
        result = true,
        options = $.extend({}, this.options, data),
        files = data.files,
        filesLength = files.length,
        limit = options.limitMultiFileUploads,
        limitSize = options.limitMultiFileUploadSize,
        overhead = options.limitMultiFileUploadSizeOverhead,
        batchSize = 0,
        paramName = this._getParamName(options),
        paramNameSet,
        paramNameSlice,
        fileSet,
        i,
        j = 0;
      if (!filesLength) {
        return false;
      }
      if (limitSize && files[0].size === undefined) {
        limitSize = undefined;
      }
      if (
        !(options.singleFileUploads || limit || limitSize) ||
        !this._isXHRUpload(options)
      ) {
        fileSet = [files];
        paramNameSet = [paramName];
      } else if (!(options.singleFileUploads || limitSize) && limit) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i += limit) {
          fileSet.push(files.slice(i, i + limit));
          paramNameSlice = paramName.slice(i, i + limit);
          if (!paramNameSlice.length) {
            paramNameSlice = paramName;
          }
          paramNameSet.push(paramNameSlice);
        }
      } else if (!options.singleFileUploads && limitSize) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i = i + 1) {
          batchSize += files[i].size + overhead;
          if (
            i + 1 === filesLength ||
            batchSize + files[i + 1].size + overhead > limitSize ||
            (limit && i + 1 - j >= limit)
          ) {
            fileSet.push(files.slice(j, i + 1));
            paramNameSlice = paramName.slice(j, i + 1);
            if (!paramNameSlice.length) {
              paramNameSlice = paramName;
            }
            paramNameSet.push(paramNameSlice);
            j = i + 1;
            batchSize = 0;
          }
        }
      } else {
        paramNameSet = paramName;
      }
      data.originalFiles = files;
      $.each(fileSet || files, function (index, element) {
        var newData = $.extend({}, data);
        newData.files = fileSet ? element : [element];
        newData.paramName = paramNameSet[index];
        that._initResponseObject(newData);
        that._initProgressObject(newData);
        that._addConvenienceMethods(e, newData);
        result = that._trigger(
          'add',
          $.Event('add', { delegatedEvent: e }),
          newData
        );
        return result;
      });
      return result;
    },

    _replaceFileInput: function (data) {
      var input = data.fileInput,
        inputClone = input.clone(true),
        restoreFocus = input.is(document.activeElement);
      // Add a reference for the new cloned file input to the data argument:
      data.fileInputClone = inputClone;
      $('<form></form>').append(inputClone)[0].reset();
      // Detaching allows to insert the fileInput on another form
      // without loosing the file input value:
      input.after(inputClone).detach();
      // If the fileInput had focus before it was detached,
      // restore focus to the inputClone.
      if (restoreFocus) {
        inputClone.trigger('focus');
      }
      // Avoid memory leaks with the detached file input:
      $.cleanData(input.off('remove'));
      // Replace the original file input element in the fileInput
      // elements set with the clone, which has been copied including
      // event handlers:
      this.options.fileInput = this.options.fileInput.map(function (i, el) {
        if (el === input[0]) {
          return inputClone[0];
        }
        return el;
      });
      // If the widget has been initialized on the file input itself,
      // override this.element with the file input clone:
      if (input[0] === this.element[0]) {
        this.element = inputClone;
      }
    },

    _handleFileTreeEntry: function (entry, path) {
      var that = this,
        dfd = $.Deferred(),
        entries = [],
        dirReader,
        errorHandler = function (e) {
          if (e && !e.entry) {
            e.entry = entry;
          }
          // Since $.when returns immediately if one
          // Deferred is rejected, we use resolve instead.
          // This allows valid files and invalid items
          // to be returned together in one set:
          dfd.resolve([e]);
        },
        successHandler = function (entries) {
          that
            ._handleFileTreeEntries(entries, path + entry.name + '/')
            .done(function (files) {
              dfd.resolve(files);
            })
            .fail(errorHandler);
        },
        readEntries = function () {
          dirReader.readEntries(function (results) {
            if (!results.length) {
              successHandler(entries);
            } else {
              entries = entries.concat(results);
              readEntries();
            }
          }, errorHandler);
        };
      // eslint-disable-next-line no-param-reassign
      path = path || '';
      if (entry.isFile) {
        if (entry._file) {
          // Workaround for Chrome bug #149735
          entry._file.relativePath = path;
          dfd.resolve(entry._file);
        } else {
          entry.file(function (file) {
            file.relativePath = path;
            dfd.resolve(file);
          }, errorHandler);
        }
      } else if (entry.isDirectory) {
        dirReader = entry.createReader();
        readEntries();
      } else {
        // Return an empty list for file system items
        // other than files or directories:
        dfd.resolve([]);
      }
      return dfd.promise();
    },

    _handleFileTreeEntries: function (entries, path) {
      var that = this;
      return $.when
        .apply(
          $,
          $.map(entries, function (entry) {
            return that._handleFileTreeEntry(entry, path);
          })
        )
        [this._promisePipe](function () {
          return Array.prototype.concat.apply([], arguments);
        });
    },

    _getDroppedFiles: function (dataTransfer) {
      // eslint-disable-next-line no-param-reassign
      dataTransfer = dataTransfer || {};
      var items = dataTransfer.items;
      if (
        items &&
        items.length &&
        (items[0].webkitGetAsEntry || items[0].getAsEntry)
      ) {
        return this._handleFileTreeEntries(
          $.map(items, function (item) {
            var entry;
            if (item.webkitGetAsEntry) {
              entry = item.webkitGetAsEntry();
              if (entry) {
                // Workaround for Chrome bug #149735:
                entry._file = item.getAsFile();
              }
              return entry;
            }
            return item.getAsEntry();
          })
        );
      }
      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
    },

    _getSingleFileInputFiles: function (fileInput) {
      // eslint-disable-next-line no-param-reassign
      fileInput = $(fileInput);
      var entries =
          fileInput.prop('webkitEntries') || fileInput.prop('entries'),
        files,
        value;
      if (entries && entries.length) {
        return this._handleFileTreeEntries(entries);
      }
      files = $.makeArray(fileInput.prop('files'));
      if (!files.length) {
        value = fileInput.prop('value');
        if (!value) {
          return $.Deferred().resolve([]).promise();
        }
        // If the files property is not available, the browser does not
        // support the File API and we add a pseudo File object with
        // the input value as name with path information removed:
        files = [{ name: value.replace(/^.*\\/, '') }];
      } else if (files[0].name === undefined && files[0].fileName) {
        // File normalization for Safari 4 and Firefox 3:
        $.each(files, function (index, file) {
          file.name = file.fileName;
          file.size = file.fileSize;
        });
      }
      return $.Deferred().resolve(files).promise();
    },

    _getFileInputFiles: function (fileInput) {
      if (!(fileInput instanceof $) || fileInput.length === 1) {
        return this._getSingleFileInputFiles(fileInput);
      }
      return $.when
        .apply($, $.map(fileInput, this._getSingleFileInputFiles))
        [this._promisePipe](function () {
          return Array.prototype.concat.apply([], arguments);
        });
    },

    _onChange: function (e) {
      var that = this,
        data = {
          fileInput: $(e.target),
          form: $(e.target.form)
        };
      this._getFileInputFiles(data.fileInput).always(function (files) {
        data.files = files;
        if (that.options.replaceFileInput) {
          that._replaceFileInput(data);
        }
        if (
          that._trigger(
            'change',
            $.Event('change', { delegatedEvent: e }),
            data
          ) !== false
        ) {
          that._onAdd(e, data);
        }
      });
    },

    _onPaste: function (e) {
      var items =
          e.originalEvent &&
          e.originalEvent.clipboardData &&
          e.originalEvent.clipboardData.items,
        data = { files: [] };
      if (items && items.length) {
        $.each(items, function (index, item) {
          var file = item.getAsFile && item.getAsFile();
          if (file) {
            data.files.push(file);
          }
        });
        if (
          this._trigger(
            'paste',
            $.Event('paste', { delegatedEvent: e }),
            data
          ) !== false
        ) {
          this._onAdd(e, data);
        }
      }
    },

    _onDrop: function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var that = this,
        dataTransfer = e.dataTransfer,
        data = {};
      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
        e.preventDefault();
        this._getDroppedFiles(dataTransfer).always(function (files) {
          data.files = files;
          if (
            that._trigger(
              'drop',
              $.Event('drop', { delegatedEvent: e }),
              data
            ) !== false
          ) {
            that._onAdd(e, data);
          }
        });
      }
    },

    _onDragOver: getDragHandler('dragover'),

    _onDragEnter: getDragHandler('dragenter'),

    _onDragLeave: getDragHandler('dragleave'),

    _initEventHandlers: function () {
      if (this._isXHRUpload(this.options)) {
        this._on(this.options.dropZone, {
          dragover: this._onDragOver,
          drop: this._onDrop,
          // event.preventDefault() on dragenter is required for IE10+:
          dragenter: this._onDragEnter,
          // dragleave is not required, but added for completeness:
          dragleave: this._onDragLeave
        });
        this._on(this.options.pasteZone, {
          paste: this._onPaste
        });
      }
      if ($.support.fileInput) {
        this._on(this.options.fileInput, {
          change: this._onChange
        });
      }
    },

    _destroyEventHandlers: function () {
      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
      this._off(this.options.pasteZone, 'paste');
      this._off(this.options.fileInput, 'change');
    },

    _destroy: function () {
      this._destroyEventHandlers();
    },

    _setOption: function (key, value) {
      var reinit = $.inArray(key, this._specialOptions) !== -1;
      if (reinit) {
        this._destroyEventHandlers();
      }
      this._super(key, value);
      if (reinit) {
        this._initSpecialOptions();
        this._initEventHandlers();
      }
    },

    _initSpecialOptions: function () {
      var options = this.options;
      if (options.fileInput === undefined) {
        options.fileInput = this.element.is('input[type="file"]')
          ? this.element
          : this.element.find('input[type="file"]');
      } else if (!(options.fileInput instanceof $)) {
        options.fileInput = $(options.fileInput);
      }
      if (!(options.dropZone instanceof $)) {
        options.dropZone = $(options.dropZone);
      }
      if (!(options.pasteZone instanceof $)) {
        options.pasteZone = $(options.pasteZone);
      }
    },

    _getRegExp: function (str) {
      var parts = str.split('/'),
        modifiers = parts.pop();
      parts.shift();
      return new RegExp(parts.join('/'), modifiers);
    },

    _isRegExpOption: function (key, value) {
      return (
        key !== 'url' &&
        $.type(value) === 'string' &&
        /^\/.*\/[igm]{0,3}$/.test(value)
      );
    },

    _initDataAttributes: function () {
      var that = this,
        options = this.options,
        data = this.element.data();
      // Initialize options set via HTML5 data-attributes:
      $.each(this.element[0].attributes, function (index, attr) {
        var key = attr.name.toLowerCase(),
          value;
        if (/^data-/.test(key)) {
          // Convert hyphen-ated key to camelCase:
          key = key.slice(5).replace(/-[a-z]/g, function (str) {
            return str.charAt(1).toUpperCase();
          });
          value = data[key];
          if (that._isRegExpOption(key, value)) {
            value = that._getRegExp(value);
          }
          options[key] = value;
        }
      });
    },

    _create: function () {
      this._initDataAttributes();
      this._initSpecialOptions();
      this._slots = [];
      this._sequence = this._getXHRPromise(true);
      this._sending = this._active = 0;
      this._initProgressObject(this);
      this._initEventHandlers();
    },

    // This method is exposed to the widget API and allows to query
    // the number of active uploads:
    active: function () {
      return this._active;
    },

    // This method is exposed to the widget API and allows to query
    // the widget upload progress.
    // It returns an object with loaded, total and bitrate properties
    // for the running uploads:
    progress: function () {
      return this._progress;
    },

    // This method is exposed to the widget API and allows adding files
    // using the fileupload API. The data parameter accepts an object which
    // must have a files property and can contain additional options:
    // .fileupload('add', {files: filesList});
    add: function (data) {
      var that = this;
      if (!data || this.options.disabled) {
        return;
      }
      if (data.fileInput && !data.files) {
        this._getFileInputFiles(data.fileInput).always(function (files) {
          data.files = files;
          that._onAdd(null, data);
        });
      } else {
        data.files = $.makeArray(data.files);
        this._onAdd(null, data);
      }
    },

    // This method is exposed to the widget API and allows sending files
    // using the fileupload API. The data parameter accepts an object which
    // must have a files or fileInput property and can contain additional options:
    // .fileupload('send', {files: filesList});
    // The method returns a Promise object for the file upload call.
    send: function (data) {
      if (data && !this.options.disabled) {
        if (data.fileInput && !data.files) {
          var that = this,
            dfd = $.Deferred(),
            promise = dfd.promise(),
            jqXHR,
            aborted;
          promise.abort = function () {
            aborted = true;
            if (jqXHR) {
              return jqXHR.abort();
            }
            dfd.reject(null, 'abort', 'abort');
            return promise;
          };
          this._getFileInputFiles(data.fileInput).always(function (files) {
            if (aborted) {
              return;
            }
            if (!files.length) {
              dfd.reject();
              return;
            }
            data.files = files;
            jqXHR = that._onSend(null, data);
            jqXHR.then(
              function (result, textStatus, jqXHR) {
                dfd.resolve(result, textStatus, jqXHR);
              },
              function (jqXHR, textStatus, errorThrown) {
                dfd.reject(jqXHR, textStatus, errorThrown);
              }
            );
          });
          return this._enhancePromise(promise);
        }
        data.files = $.makeArray(data.files);
        if (data.files.length) {
          return this._onSend(null, data);
        }
      }
      return this._getXHRPromise(false, data && data.context);
    }
  });


    // International Tel Input
      /*https://github.com/Bluefieldscom/intl-tel-input.git */
      (function(a,b,c,d){"use strict";function e(b,c){this.a=b,c&&(a.extend(c, c, {a:c.autoFormat,h:c.autoHideDialCode,d:c.defaultCountry,i:c.ipinfoToken,n:c.nationalMode,t:c.numberType,o:c.onlyCountries,p:c.preferredCountries,v:c.preventInvalidNumbers,u:c.utilsScript})),this.b=a.extend({},h,c),this.c=h,this.ns="."+f+g++,this.d=Boolean(b.setSelectionRange),this.e=Boolean(a(b).attr("placeholder")),this.f=f}var f="intlTelInput",g=1,h={allowExtensions:!1,a:!0,h:!0,autoPlaceholder:!0,d:"",geoIpLookup:null,n:!0,t:"MOBILE",o:[],p:["us","gb"],u:""},i={b:38,c:40,d:13,e:27,f:43,A:65,Z:90,g:48,h:57,i:32,Bi:8,TAB:9,k:46,l:17,m:91,n:224},j=!1;a(b).load(function(){j=!0}),e.prototype={_init:function(){return this.b.n&&(this.b.h=!1),navigator.userAgent.match(/IEMobile/i)&&(this.b.a=!1),this.isMobile=/Android.+Mobile|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.autoCountryDeferred=new a.Deferred,this.utilsScriptDeferred=new a.Deferred,this._b(),this._f(),this._h(),this._i(),this._initRequests(),[this.autoCountryDeferred,this.utilsScriptDeferred]},_b:function(){this._d(),this._e()},_c:function(a,b,c){b in this.m||(this.m[b]=[]);var d=c||0;this.m[b][d]=a},_d:function(){var b;if(this.b.o.length){for(b=0;b<this.b.o.length;b++)this.b.o[b]=this.b.o[b].toLowerCase();for(this.l=[],b=0;b<k.length;b++)-1!=a.inArray(k[b].iso2,this.b.o)&&this.l.push(k[b])}else this.l=k;for(this.m={},b=0;b<this.l.length;b++){var c=this.l[b];if(this._c(c.iso2,c.dialCode,c.priority),c.areaCodes)for(var d=0;d<c.areaCodes.length;d++)this._c(c.iso2,c.dialCode+c.areaCodes[d])}},_e:function(){this.n=[];for(var a=0;a<this.b.p.length;a++){var b=this.b.p[a].toLowerCase(),c=this._y(b,!1,!0);c&&this.n.push(c)}},_f:function(){this.g=a(this.a),this.g.attr("autocomplete","off"),this.g.wrap(a("<div>",{"class":"intl-tel-input"})),this.flagsContainer=a("<div>",{"class":"flag-dropdown"}).insertBefore(this.g);var b=a("<div>",{tabindex:"0","class":"selected-flag"}).appendTo(this.flagsContainer);this.h=a("<div>",{"class":"iti-flag"}).appendTo(b),a("<div>",{"class":"arrow"}).appendTo(b),this.isMobile?this.i=a("<select>",{"class":"iti-mobile-select"}).appendTo(this.flagsContainer):(this.i=a("<ul>",{"class":"country-list v-hide"}).appendTo(this.flagsContainer),this.n.length&&!this.isMobile&&(this._g(this.n,"preferred"),a("<li>",{"class":"divider"}).appendTo(this.i))),this._g(this.l,""),this.isMobile||(this.j=this.i.outerHeight(),this.i.removeClass("v-hide").addClass("hide"),this.k=this.i.children(".country"))},_g:function(a,b){for(var c="",d=0;d<a.length;d++){var e=a[d];this.isMobile?(c+="<option data-dial-code='"+e.dialCode+"' value='"+e.iso2+"'>",c+=e.name+" +"+e.dialCode,c+="</option>"):(c+="<li class='country "+b+"' data-dial-code='"+e.dialCode+"' data-country-code='"+e.iso2+"'>",c+="<div class='flag'><div class='iti-flag "+e.iso2+"'></div></div>",c+="<span class='country-name'>"+e.name+"</span>",c+="<span class='dial-code'>+"+e.dialCode+"</span>",c+="</li>")}this.i.append(c)},_h:function(){var a=this.g.val();this._af(a)?this._v(a,!0):"auto"!=this.b.d&&(this.b.d=this.b.d?this._y(this.b.d.toLowerCase(),!1,!1):this.n.length?this.n[0]:this.l[0],this._z(this.b.d.iso2),a||this._ae(this.b.d.dialCode,!1)),a&&this._u(a)},_i:function(){var b=this;if(this._j(),(this.b.h||this.b.a)&&this._l(),this.isMobile)this.i.on("change"+this.ns,function(){b._ab(a(this).find("option:selected"))});else{var c=this.g.closest("label");c.length&&c.on("click"+this.ns,function(a){b.i.hasClass("hide")?b.g.focus():a.preventDefault()});var d=this.h.parent();d.on("click"+this.ns,function(){!b.i.hasClass("hide")||b.g.prop("disabled")||b.g.prop("readonly")||b._n()})}this.flagsContainer.on("keydown"+b.ns,function(a){var c=b.i.hasClass("hide");!c||a.which!=i.b&&a.which!=i.c&&a.which!=i.i&&a.which!=i.d||(a.preventDefault(),a.stopPropagation(),b._n()),a.which==i.TAB&&b._ac()})},_initRequests:function(){var c=this;this.b.u?j?this.loadUtils():a(b).load(function(){c.loadUtils()}):this.utilsScriptDeferred.resolve(),"auto"==this.b.d?this._loadAutoCountry():this.autoCountryDeferred.resolve()},_loadAutoCountry:function(){var b=a.cookie?a.cookie("itiAutoCountry"):"";b&&(a.fn[f].autoCountry=b),a.fn[f].autoCountry?this.autoCountryLoaded():a.fn[f].startedLoadingAutoCountry||(a.fn[f].startedLoadingAutoCountry=!0,"function"==typeof this.b.geoIpLookup&&this.b.geoIpLookup(function(b){a.fn[f].autoCountry=b.toLowerCase(),a.cookie&&a.cookie("itiAutoCountry",a.fn[f].autoCountry,{path:"/"}),setTimeout(function(){a(".intl-tel-input input").intlTelInput("autoCountryLoaded")})}))},_j:function(){var a=this;this.b.a&&this.g.on("keypress"+this.ns,function(c){if(c.which>=i.i&&!c.ctrlKey&&!c.metaKey&&b.intlTelInputUtils&&!a.g.prop("readonly")){c.preventDefault();var d=c.which>=i.g&&c.which<=i.h||c.which==i.f,e=a.g[0],f=a.d&&e.selectionStart==e.selectionEnd,g=a.g.attr("maxlength"),h=a.g.val(),j=g?h.length<g:!0;if(j&&(d||f)){var k=d?String.fromCharCode(c.which):null;a._k(k,!0,d),h!=a.g.val()&&a.g.trigger("input")}d||a._handleInvalidKey()}}),this.g.on("cut"+this.ns+" paste"+this.ns,function(){setTimeout(function(){if(a.b.a&&b.intlTelInputUtils){var c=a.d&&a.g[0].selectionStart==a.g.val().length;a._k(null,c),a._ensurePlus()}else a._v(a.g.val())})}),this.g.on("keyup"+this.ns,function(c){if(c.which==i.d||a.g.prop("readonly"));else if(a.b.a&&b.intlTelInputUtils){var d=a.d&&a.g[0].selectionStart==a.g.val().length;a.g.val()?(c.which==i.k&&!d||c.which==i.Bi)&&a._k():a._v(""),a._ensurePlus()}else a._v(a.g.val())})},_ensurePlus:function(){if(!this.b.n){var a=this.g.val(),b=this.g[0];if("+"!=a.charAt(0)){var c=this.d?b.selectionStart+1:0;this.g.val("+"+a),this.d&&b.setSelectionRange(c,c)}}},_handleInvalidKey:function(){var a=this;this.g.trigger("invalidkey").addClass("iti-invalid-key"),setTimeout(function(){a.g.removeClass("iti-invalid-key")},100)},_k:function(a,b,c){var d,e=this.g.val(),f=(this._getClean(e),this.g[0]),g=0;if(this.d?(g=this._getDigitsOnRight(e,f.selectionEnd),a?e=e.substr(0,f.selectionStart)+a+e.substring(f.selectionEnd,e.length):d=e.substr(f.selectionStart-2,2)):a&&(e+=a),this.setNumber(e,null,b,!0,c),this.d){var h;e=this.g.val(),g?(h=this._getCursorFromDigitsOnRight(e,g),a||(h=this._getCursorFromLeftChar(e,h,d))):h=e.length,f.setSelectionRange(h,h)}},_getCursorFromLeftChar:function(b,c,d){for(var e=c;e>0;e--){var f=b.charAt(e-1);if(a.isNumeric(f)||b.substr(e-2,2)==d)return e}return 0},_getCursorFromDigitsOnRight:function(b,c){for(var d=b.length-1;d>=0;d--)if(a.isNumeric(b.charAt(d))&&0===--c)return d;return 0},_getDigitsOnRight:function(b,c){for(var d=0,e=c;e<b.length;e++)a.isNumeric(b.charAt(e))&&d++;return d},_l:function(){var a=this;this.b.h&&this.g.on("mousedown"+this.ns,function(b){a.g.is(":focus")||a.g.val()||(b.preventDefault(),a.g.focus())}),this.g.on("focus"+this.ns,function(){var c=a.g.val();a.g.data("focusVal",c),a.b.h&&!c&&!a.g.prop("readonly")&&a.o.dialCode&&(a._u("+"+a.o.dialCode,null,!0),a.g.one("keypress.plus"+a.ns,function(c){if(c.which==i.f){var d=a.b.a&&b.intlTelInputUtils?"+":"";a.g.val(d)}}),setTimeout(function(){var b=a.g[0];if(a.d){var c=a.g.val().length;b.setSelectionRange(c,c)}}))}),this.g.on("blur"+this.ns,function(){if(a.b.h){var c=a.g.val(),d="+"==c.charAt(0);if(d){var e=a._m(c);e&&a.o.dialCode!=e||a.g.val("")}a.g.off("keypress.plus"+a.ns)}a.b.a&&b.intlTelInputUtils&&a.g.val()!=a.g.data("focusVal")&&a.g.trigger("change")})},_m:function(a){return a.replace(/\D/g,"")},_getClean:function(a){var b="+"==a.charAt(0)?"+":"";return b+this._m(a)},_n:function(){this._o();var a=this.i.children(".active");a.length&&this._x(a),this.i.removeClass("hide"),a.length&&this._ad(a),this._p(),this.h.children(".arrow").addClass("up")},_o:function(){var c=this.g.offset().top,d=a(b).scrollTop(),e=c+this.g.outerHeight()+this.j<d+a(b).height(),f=c-this.j>d,g=!e&&f?"-"+(this.j-1)+"px":"";this.i.css("top",g)},_p:function(){var b=this;this.i.on("mouseover"+this.ns,".country",function(){b._x(a(this))}),this.i.on("click"+this.ns,".country",function(){b._ab(a(this))});var d=!0;a("html").on("click"+this.ns,function(){d||b._ac(),d=!1});var e="",f=null;a(c).on("keydown"+this.ns,function(a){a.preventDefault(),a.which==i.b||a.which==i.c?b._q(a.which):a.which==i.d?b._r():a.which==i.e?b._ac():(a.which>=i.A&&a.which<=i.Z||a.which==i.i)&&(f&&clearTimeout(f),e+=String.fromCharCode(a.which),b._s(e),f=setTimeout(function(){e=""},1e3))})},_q:function(a){var b=this.i.children(".highlight").first(),c=a==i.b?b.prev():b.next();c.length&&(c.hasClass("divider")&&(c=a==i.b?c.prev():c.next()),this._x(c),this._ad(c))},_r:function(){var a=this.i.children(".highlight").first();a.length&&this._ab(a)},_s:function(a){for(var b=0;b<this.l.length;b++)if(this._t(this.l[b].name,a)){var c=this.i.children("[data-country-code="+this.l[b].iso2+"]").not(".preferred");this._x(c),this._ad(c,!0);break}},_t:function(a,b){return a.substr(0,b.length).toUpperCase()==b},_u:function(a,c,d,e,f){var g;if(this.b.a&&b.intlTelInputUtils&&this.o){g="number"==typeof c&&intlTelInputUtils.isValidNumber(a,this.o.iso2)?intlTelInputUtils.formatNumberByType(a,this.o.iso2,c):!e&&this.b.n&&"+"==a.charAt(0)&&intlTelInputUtils.isValidNumber(a,this.o.iso2)?intlTelInputUtils.formatNumberByType(a,this.o.iso2,intlTelInputUtils.numberFormat.NATIONAL):intlTelInputUtils.formatNumber(a,this.o.iso2,d,this.b.allowExtensions,f);var h=this.g.attr("maxlength");h&&g.length>h&&(g=g.substr(0,h))}else g=a;this.g.val(g)},_v:function(b,c){b&&this.b.n&&this.o&&"1"==this.o.dialCode&&"+"!=b.charAt(0)&&("1"!=b.charAt(0)&&(b="1"+b),b="+"+b);var d=this._af(b),e=null;if(d){var f=this.m[this._m(d)],g=this.o&&-1!=a.inArray(this.o.iso2,f);if(!g||this._w(b,d))for(var h=0;h<f.length;h++)if(f[h]){e=f[h];break}}else"+"==b.charAt(0)&&this._m(b).length?e="":b&&"+"!=b||(e=this.b.d.iso2);null!==e&&this._z(e,c)},_w:function(a,b){return"+1"==b&&this._m(a).length>=4},_x:function(a){this.k.removeClass("highlight"),a.addClass("highlight")},_y:function(a,b,c){for(var d=b?k:this.l,e=0;e<d.length;e++)if(d[e].iso2==a)return d[e];if(c)return null;throw new Error("No country data for '"+a+"'")},_z:function(a,b){this.o=a?this._y(a,!1,!1):{},b&&this.o.iso2&&(this.b.d={iso2:this.o.iso2}),this.h.attr("class","iti-flag "+a);var c=a?this.o.name+": +"+this.o.dialCode:"Unknown";this.h.parent().attr("title",c),this._aa(),this.isMobile?this.i.val(a):(this.k.removeClass("active"),a&&this.k.find(".iti-flag."+a).first().closest(".country").addClass("active"))},_aa:function(){if(b.intlTelInputUtils&&!this.e&&this.b.autoPlaceholder&&this.o){var a=this.o.iso2,c=intlTelInputUtils.numberType[this.b.t||"FIXED_LINE"],d=a?intlTelInputUtils.getExampleNumber(a,this.b.n,c):"";this.g.attr("placeholder",d)}},_ab:function(a){var b=this.isMobile?"value":"data-country-code";if(this._z(a.attr(b),!0),this.isMobile||this._ac(),this._ae(a.attr("data-dial-code"),!0),this.g.trigger("change"),this.g.focus(),this.d){var c=this.g.val().length;this.g[0].setSelectionRange(c,c)}},_ac:function(){this.i.addClass("hide"),this.h.children(".arrow").removeClass("up"),a(c).off(this.ns),a("html").off(this.ns),this.i.off(this.ns)},_ad:function(a,b){var c=this.i,d=c.height(),e=c.offset().top,f=e+d,g=a.outerHeight(),h=a.offset().top,i=h+g,j=h-e+c.scrollTop(),k=d/2-g/2;if(e>h)b&&(j-=k),c.scrollTop(j);else if(i>f){b&&(j+=k);var l=d-g;c.scrollTop(j-l)}},_ae:function(b,c){var d,e=this.g.val();if(b="+"+b,this.b.n&&"+"!=e.charAt(0))d=e;else if(e){var f=this._af(e);if(f.length>1)d=e.replace(f,b);else{var g="+"!=e.charAt(0)?a.trim(e):"";d=b+g}}else d=!this.b.h||c?b:"";this._u(d,null,c)},_af:function(b){var c="";if("+"==b.charAt(0))for(var d="",e=0;e<b.length;e++){var f=b.charAt(e);if(a.isNumeric(f)&&(d+=f,this.m[d]&&(c=b.substr(0,e+1)),4==d.length))break}return c},autoCountryLoaded:function(){"auto"==this.b.d&&(this.b.d=a.fn[f].autoCountry,this._h(),this.autoCountryDeferred.resolve())},destroy:function(){this.isMobile||this._ac(),this.g.off(this.ns),this.isMobile?this.i.off(this.ns):(this.h.parent().off(this.ns),this.g.closest("label").off(this.ns));var a=this.g.parent();a.before(this.g).remove()},getExtension:function(){return this.g.val().split(" ext. ")[1]||""},getNumber:function(a){return b.intlTelInputUtils?intlTelInputUtils.formatNumberByType(this.g.val(),this.o.iso2,a):""},getNumberType:function(){return b.intlTelInputUtils?intlTelInputUtils.getNumberType(this.g.val(),this.o.iso2):-99},getSelectedCountryData:function(){return this.o||{}},getValidationError:function(){return b.intlTelInputUtils?intlTelInputUtils.getValidationError(this.g.val(),this.o.iso2):-99},isValidNumber:function(){var c=a.trim(this.g.val()),d=this.b.n?this.o.iso2:"";return b.intlTelInputUtils?intlTelInputUtils.isValidNumber(c,d):!1},loadUtils:function(b){var c=this,d=b||this.b.u;!a.fn[f].loadedUtilsScript&&d?(a.fn[f].loadedUtilsScript=!0,a.ajax({url:d,success:function(){a(".intl-tel-input input").intlTelInput("utilsLoaded")},complete:function(){c.utilsScriptDeferred.resolve()},dataType:"script",cache:!0})):this.utilsScriptDeferred.resolve()},selectCountry:function(a){a=a.toLowerCase(),this.h.hasClass(a)||(this._z(a,!0),this._ae(this.o.dialCode,!1))},setNumber:function(a,b,c,d,e){this.b.n||"+"==a.charAt(0)||(a="+"+a),this._v(a),this._u(a,b,c,d,e)},utilsLoaded:function(){this.b.a&&this.g.val()&&this._u(this.g.val()),this._aa()}},a.fn[f]=function(b){var c=arguments;if(b===d||"object"==typeof b){var g=[];return this.each(function(){if(!a.data(this,"plugin_"+f)){var c=new e(this,b),d=c._init();g.push(d[0]),g.push(d[1]),a.data(this,"plugin_"+f,c)}}),a.when.apply(null,g)}if("string"==typeof b&&"_"!==b[0]){var h;return this.each(function(){var d=a.data(this,"plugin_"+f);d instanceof e&&"function"==typeof d[b]&&(h=d[b].apply(d,Array.prototype.slice.call(c,1))),"destroy"===b&&a.data(this,"plugin_"+f,null)}),h!==d?h:this}},a.fn[f].getCountryData=function(){return k},a.fn[f].version="6.0.6";for(var k=[["Afghanistan (‫افغانستان‬‎)","af","93"],["Albania (Shqipëri)","al","355"],["Algeria (‫الجزائر‬‎)","dz","213"],["American Samoa","as","1684"],["Andorra","ad","376"],["Angola","ao","244"],["Anguilla","ai","1264"],["Antigua and Barbuda","ag","1268"],["Argentina","ar","54"],["Armenia (Հայաստան)","am","374"],["Aruba","aw","297"],["Australia","au","61"],["Austria (Österreich)","at","43"],["Azerbaijan (Azərbaycan)","az","994"],["Bahamas","bs","1242"],["Bahrain (‫البحرين‬‎)","bh","973"],["Bangladesh (বাংলাদেশ)","bd","880"],["Barbados","bb","1246"],["Belarus (Беларусь)","by","375"],["Belgium (België)","be","32"],["Belize","bz","501"],["Benin (Bénin)","bj","229"],["Bermuda","bm","1441"],["Bhutan (འབྲུག)","bt","975"],["Bolivia","bo","591"],["Bosnia and Herzegovina (Босна и Херцеговина)","ba","387"],["Botswana","bw","267"],["Brazil (Brasil)","br","55"],["British Indian Ocean Territory","io","246"],["British Virgin Islands","vg","1284"],["Brunei","bn","673"],["Bulgaria (България)","bg","359"],["Burkina Faso","bf","226"],["Burundi (Uburundi)","bi","257"],["Cambodia (កម្ពុជា)","kh","855"],["Cameroon (Cameroun)","cm","237"],["Canada","ca","1",1,["204","226","236","249","250","289","306","343","365","387","403","416","418","431","437","438","450","506","514","519","548","579","581","587","604","613","639","647","672","705","709","742","778","780","782","807","819","825","867","873","902","905"]],["Cape Verde (Kabu Verdi)","cv","238"],["Caribbean Netherlands","bq","599",1],["Cayman Islands","ky","1345"],["Central African Republic (République centrafricaine)","cf","236"],["Chad (Tchad)","td","235"],["Chile","cl","56"],["China (中国)","cn","86"],["Colombia","co","57"],["Comoros (‫جزر القمر‬‎)","km","269"],["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)","cd","243"],["Congo (Republic) (Congo-Brazzaville)","cg","242"],["Cook Islands","ck","682"],["Costa Rica","cr","506"],["Côte d’Ivoire","ci","225"],["Croatia (Hrvatska)","hr","385"],["Cuba","cu","53"],["Curaçao","cw","599",0],["Cyprus (Κύπρος)","cy","357"],["Czech Republic (Česká republika)","cz","420"],["Denmark (Danmark)","dk","45"],["Djibouti","dj","253"],["Dominica","dm","1767"],["Dominican Republic (República Dominicana)","do","1",2,["809","829","849"]],["Ecuador","ec","593"],["Egypt (‫مصر‬‎)","eg","20"],["El Salvador","sv","503"],["Equatorial Guinea (Guinea Ecuatorial)","gq","240"],["Eritrea","er","291"],["Estonia (Eesti)","ee","372"],["Ethiopia","et","251"],["Falkland Islands (Islas Malvinas)","fk","500"],["Faroe Islands (Føroyar)","fo","298"],["Fiji","fj","679"],["Finland (Suomi)","fi","358"],["France","fr","33"],["French Guiana (Guyane française)","gf","594"],["French Polynesia (Polynésie française)","pf","689"],["Gabon","ga","241"],["Gambia","gm","220"],["Georgia (საქართველო)","ge","995"],["Germany (Deutschland)","de","49"],["Ghana (Gaana)","gh","233"],["Gibraltar","gi","350"],["Greece (Ελλάδα)","gr","30"],["Greenland (Kalaallit Nunaat)","gl","299"],["Grenada","gd","1473"],["Guadeloupe","gp","590",0],["Guam","gu","1671"],["Guatemala","gt","502"],["Guinea (Guinée)","gn","224"],["Guinea-Bissau (Guiné Bissau)","gw","245"],["Guyana","gy","592"],["Haiti","ht","509"],["Honduras","hn","504"],["Hong Kong (香港)","hk","852"],["Hungary (Magyarország)","hu","36"],["Iceland (Ísland)","is","354"],["India (भारत)","in","91"],["Indonesia","id","62"],["Iran (‫ایران‬‎)","ir","98"],["Iraq (‫العراق‬‎)","iq","964"],["Ireland","ie","353"],["Israel (‫ישראל‬‎)","il","972"],["Italy (Italia)","it","39",0],["Jamaica","jm","1876"],["Japan (日本)","jp","81"],["Jordan (‫الأردن‬‎)","jo","962"],["Kazakhstan (Казахстан)","kz","7",1],["Kenya","ke","254"],["Kiribati","ki","686"],["Kuwait (‫الكويت‬‎)","kw","965"],["Kyrgyzstan (Кыргызстан)","kg","996"],["Laos (ລາວ)","la","856"],["Latvia (Latvija)","lv","371"],["Lebanon (‫لبنان‬‎)","lb","961"],["Lesotho","ls","266"],["Liberia","lr","231"],["Libya (‫ليبيا‬‎)","ly","218"],["Liechtenstein","li","423"],["Lithuania (Lietuva)","lt","370"],["Luxembourg","lu","352"],["Macau (澳門)","mo","853"],["Macedonia (FYROM) (Македонија)","mk","389"],["Madagascar (Madagasikara)","mg","261"],["Malawi","mw","265"],["Malaysia","my","60"],["Maldives","mv","960"],["Mali","ml","223"],["Malta","mt","356"],["Marshall Islands","mh","692"],["Martinique","mq","596"],["Mauritania (‫موريتانيا‬‎)","mr","222"],["Mauritius (Moris)","mu","230"],["Mexico (México)","mx","52"],["Micronesia","fm","691"],["Moldova (Republica Moldova)","md","373"],["Monaco","mc","377"],["Mongolia (Монгол)","mn","976"],["Montenegro (Crna Gora)","me","382"],["Montserrat","ms","1664"],["Morocco (‫المغرب‬‎)","ma","212"],["Mozambique (Moçambique)","mz","258"],["Myanmar (Burma) (မြန်မာ)","mm","95"],["Namibia (Namibië)","na","264"],["Nauru","nr","674"],["Nepal (नेपाल)","np","977"],["Netherlands (Nederland)","nl","31"],["New Caledonia (Nouvelle-Calédonie)","nc","687"],["New Zealand","nz","64"],["Nicaragua","ni","505"],["Niger (Nijar)","ne","227"],["Nigeria","ng","234"],["Niue","nu","683"],["Norfolk Island","nf","672"],["North Korea (조선 민주주의 인민 공화국)","kp","850"],["Northern Mariana Islands","mp","1670"],["Norway (Norge)","no","47"],["Oman (‫عُمان‬‎)","om","968"],["Pakistan (‫پاکستان‬‎)","pk","92"],["Palau","pw","680"],["Palestine (‫فلسطين‬‎)","ps","970"],["Panama (Panamá)","pa","507"],["Papua New Guinea","pg","675"],["Paraguay","py","595"],["Peru (Perú)","pe","51"],["Philippines","ph","63"],["Poland (Polska)","pl","48"],["Portugal","pt","351"],["Puerto Rico","pr","1",3,["787","939"]],["Qatar (‫قطر‬‎)","qa","974"],["Réunion (La Réunion)","re","262"],["Romania (România)","ro","40"],["Russia (Россия)","ru","7",0],["Rwanda","rw","250"],["Saint Barthélemy (Saint-Barthélemy)","bl","590",1],["Saint Helena","sh","290"],["Saint Kitts and Nevis","kn","1869"],["Saint Lucia","lc","1758"],["Saint Martin (Saint-Martin (partie française))","mf","590",2],["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)","pm","508"],["Saint Vincent and the Grenadines","vc","1784"],["Samoa","ws","685"],["San Marino","sm","378"],["São Tomé and Príncipe (São Tomé e Príncipe)","st","239"],["Saudi Arabia (‫المملكة العربية السعودية‬‎)","sa","966"],["Senegal (Sénégal)","sn","221"],["Serbia (Србија)","rs","381"],["Seychelles","sc","248"],["Sierra Leone","sl","232"],["Singapore","sg","65"],["Sint Maarten","sx","1721"],["Slovakia (Slovensko)","sk","421"],["Slovenia (Slovenija)","si","386"],["Solomon Islands","sb","677"],["Somalia (Soomaaliya)","so","252"],["South Africa","za","27"],["South Korea (대한민국)","kr","82"],["South Sudan (‫جنوب السودان‬‎)","ss","211"],["Spain (España)","es","34"],["Sri Lanka (ශ්‍රී ලංකාව)","lk","94"],["Sudan (‫السودان‬‎)","sd","249"],["Suriname","sr","597"],["Swaziland","sz","268"],["Sweden (Sverige)","se","46"],["Switzerland (Schweiz)","ch","41"],["Syria (‫سوريا‬‎)","sy","963"],["Taiwan (台灣)","tw","886"],["Tajikistan","tj","992"],["Tanzania","tz","255"],["Thailand (ไทย)","th","66"],["Timor-Leste","tl","670"],["Togo","tg","228"],["Tokelau","tk","690"],["Tonga","to","676"],["Trinidad and Tobago","tt","1868"],["Tunisia (‫تونس‬‎)","tn","216"],["Turkey (Türkiye)","tr","90"],["Turkmenistan","tm","993"],["Turks and Caicos Islands","tc","1649"],["Tuvalu","tv","688"],["U.S. Virgin Islands","vi","1340"],["Uganda","ug","256"],["Ukraine (Україна)","ua","380"],["United Arab Emirates (‫الإمارات العربية المتحدة‬‎)","ae","971"],["United Kingdom","gb","44"],["United States","us","1",0],["Uruguay","uy","598"],["Uzbekistan (Oʻzbekiston)","uz","998"],["Vanuatu","vu","678"],["Vatican City (Città del Vaticano)","va","39",1],["Venezuela","ve","58"],["Vietnam (Việt Nam)","vn","84"],["Wallis and Futuna","wf","681"],["Yemen (‫اليمن‬‎)","ye","967"],["Zambia","zm","260"],["Zimbabwe","zw","263"]],l=0;l<k.length;l++){var m=k[l];k[l]={name:m[0],iso2:m[1],dialCode:m[2],priority:m[3]||0,areaCodes:m[4]||null}}})($, window, document, null);

    // AssetGrid
      var AssetGrid=function(t,e,i){var r=[],n=this,a=$(t),h=$(e);i=parseInt(i)||250;var s=function(t,e){e-=5*t.length;for(var i=0,r=0;r<t.length;++r)i+=$(t[r]).data("width")/$(t[r]).data("height");return e/i},d=function(t,e){r.push(e);for(var i=0;i<t.length;++i)$(t[i]).css({width:e*$(t[i]).data("width")/$(t[i]).data("height"),height:e})};n.resize=function(){var t=i,e=a.width()-30,r=0,n=h;t:for(;n.length>0;){for(var o=1;o<n.length+1;++o){var f=n.slice(0,o),v=s(f,e);if(t>v){d(f,v),r++,n=n.slice(o);continue t}}d(f,Math.min(t,v)),r++;break}},window.addEventListener("resize",n.resize),n.resize()};

    // Audio Meter
    var createAudioMeter = function (audioContext,clipLevel,averaging,clipLag) {
      var processor = audioContext.createScriptProcessor(512);
      processor.onaudioprocess = volumeAudioProcess;
      processor.clipping = false;
      processor.lastClip = 0;
      processor.volume = 0;
      processor.clipLevel = clipLevel || 0.98;
      processor.averaging = averaging || 0.0;
      processor.clipLag = clipLag || 750;

      // this will have no effect, since we don't copy the input to the output,
      // but works around a current Chrome bug.
      processor.connect(audioContext.destination);

      processor.checkClipping =
        function(){
          if (!this.clipping)
            return false;
          if ((this.lastClip + this.clipLag) < window.performance.now())
            this.clipping = false;
          return this.clipping;
        };

      processor.shutdown =
        function(){
          this.disconnect();
          this.onaudioprocess = null;
        };

      return processor;
    }

    var volumeAudioProcess = function( event ) {
      var buf = event.inputBuffer.getChannelData(0);
        var bufLength = buf.length;
      var sum = 0;
        var x;

      // Do a root-mean-square on the samples: sum up the squares...
        for (var i=0; i<bufLength; i++) {
          x = buf[i];
          if (Math.abs(x)>=this.clipLevel) {
            this.clipping = true;
            this.lastClip = window.performance.now();
          }
          sum += x * x;
        }

        // ... then take the square root of the sum.
        var rms =  Math.sqrt(sum / bufLength);

        // Now smooth this out with the averaging factor applied
        // to the previous sample - take the max here because we
        // want "fast attack, slow release."
        this.volume = Math.max(rms, this.volume*this.averaging);
    }


    var createCookie = function(name, value) {
      document.cookie = name + "=" + value + "; path=/";
    }

    var getCookie = function(c_name) {
      if (document.cookie.length > 0) {
        c_start = document.cookie.indexOf(c_name + "=");
        if (c_start != -1) {
          c_start = c_start + c_name.length + 1;
          c_end = document.cookie.indexOf(";", c_start);
          if (c_end == -1) {
            c_end = document.cookie.length;
          }
          return unescape(document.cookie.substring(c_start, c_end));
        }
      }
      return null;
    }

    $(init);

  };

}



if (!Array.prototype.indexOf)
{
  Array.prototype.indexOf = function(elt /*, from*/)
  {
    var len = this.length >>> 0;

    var from = Number(arguments[1]) || 0;
    from = (from < 0)
         ? Math.ceil(from)
         : Math.floor(from);
    if (from < 0)
      from += len;

    for (; from < len; from++)
    {
      if (from in this &&
          this[from] === elt)
        return from;
    }
    return -1;
  };
}